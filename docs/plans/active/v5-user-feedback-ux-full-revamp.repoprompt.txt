<file_map>
/Users/austin/dev/kink
├── design-mockups
│   ├── 01-ink-and-paper.html *
│   ├── 02-phosphor.html
│   ├── 03-velvet.html
│   └── 04-signal.html
├── docs
│   ├── design
│   │   ├── architecture.md *
│   │   ├── frontend.md *
│   │   ├── deployment.md
│   │   └── mcps.md
│   ├── plans
│   │   ├── active
│   │   │   ├── ux-excellence.md *
│   │   │   ├── v5-user-feedback-ux.md *
│   │   │   ├── column-quality.md
│   │   │   ├── v2-next-steps.md
│   │   │   ├── v3-ux-overhaul.md
│   │   │   ├── v3-ux-remediation.md
│   │   │   ├── v4-plain-language-remediation.md
│   │   │   └── v5-user-feedback-ux.repoprompt.txt
│   │   └── completed
│   │       ├── 2026-02-12-plan-continuation.md
│   │       ├── 2026-02-13-ai-agents-docs.md
│   │       ├── 2026-02-13-survey-basepath-deploy.md
│   │       ├── 2026-02-14-explore-hub-nav-dropdown.md
│   │       └── 2026-02-14-v3-ux-testing.md
│   ├── schema
│   │   ├── README.md
│   │   ├── column-quality.md
│   │   ├── data-exploration.md
│   │   └── interesting-findings.md
│   ├── repomix.md
│   └── worklog.md
├── scripts
│   ├── profile-schema.mjs *
│   ├── precompute-relationships.mjs
│   ├── sync-public-data.mjs
│   └── validate-chart-presets.mjs
├── src
│   ├── components
│   │   ├── charts
│   │   │   ├── bar-chart.tsx * +
│   │   │   ├── chart-config.ts * +
│   │   │   ├── grouped-bar-chart.tsx * +
│   │   │   └── line-chart.tsx +
│   │   ├── ui
│   │   │   ├── badge.tsx +
│   │   │   ├── button.tsx +
│   │   │   ├── checkbox.tsx +
│   │   │   ├── input.tsx +
│   │   │   ├── scroll-area.tsx +
│   │   │   ├── select.tsx +
│   │   │   ├── table.tsx +
│   │   │   ├── textarea.tsx +
│   │   │   └── tooltip.tsx +
│   │   ├── column-combobox.tsx * +
│   │   ├── column-name-tooltip.tsx * +
│   │   ├── data-table.tsx * +
│   │   ├── loading-skeleton.tsx * +
│   │   ├── section-header.tsx * +
│   │   ├── stat-card.tsx * +
│   │   ├── column-inspector.tsx +
│   │   ├── feedback-dialog.tsx +
│   │   ├── missingness-badge.tsx +
│   │   ├── pivot-matrix.tsx +
│   │   └── sample-size-display.tsx +
│   ├── lib
│   │   ├── api
│   │   │   ├── contracts.ts * +
│   │   │   └── contracts.test.ts +
│   │   ├── duckdb
│   │   │   ├── sql-helpers.ts * +
│   │   │   ├── init.ts +
│   │   │   ├── provider.tsx +
│   │   │   └── use-query.ts +
│   │   ├── schema
│   │   │   ├── types.ts * +
│   │   │   ├── caveats.extended.test.ts +
│   │   │   ├── caveats.test.ts +
│   │   │   ├── caveats.ts +
│   │   │   ├── column-flags.ts +
│   │   │   ├── columns.generated.json
│   │   │   ├── human-labels.json
│   │   │   ├── metadata.test.ts +
│   │   │   ├── metadata.ts +
│   │   │   ├── null-meaning.ts +
│   │   │   ├── relationships.generated.json
│   │   │   └── value-labels.ts +
│   │   ├── client
│   │   │   └── api.ts +
│   │   ├── server
│   │   │   ├── api-response.test.ts +
│   │   │   ├── api-response.ts +
│   │   │   ├── db.test.ts +
│   │   │   ├── db.ts +
│   │   │   ├── rate-limit.ts +
│   │   │   ├── ses.ts +
│   │   │   ├── sql-guards.extended.test.ts +
│   │   │   ├── sql-guards.test.ts +
│   │   │   └── sql-guards.ts +
│   │   ├── chart-presets.ts * +
│   │   ├── format-labels.ts * +
│   │   ├── format.ts +
│   │   ├── notebook-store.ts +
│   │   └── utils.ts +
│   ├── routes
│   │   ├── api
│   │   │   ├── crosstab.ts +
│   │   │   ├── feedback.ts +
│   │   │   ├── health.ts +
│   │   │   ├── query.ts +
│   │   │   ├── schema.ts +
│   │   │   └── stats.$column.ts +
│   │   ├── explore
│   │   │   ├── crosstab.tsx +
│   │   │   └── index.tsx +
│   │   ├── __root.tsx * +
│   │   ├── index.tsx * +
│   │   ├── profile.tsx * +
│   │   ├── relationships.tsx * +
│   │   ├── about.tsx +
│   │   ├── columns.tsx +
│   │   ├── data-quality.tsx +
│   │   ├── llms[.]txt.ts +
│   │   ├── notebook.tsx +
│   │   └── sql.tsx +
│   ├── styles.css *
│   ├── routeTree.gen.ts +
│   └── router.tsx +
├── .husky
│   └── pre-commit
├── analysis
│   ├── scripts
│   │   └── bootstrap_cis.py +
│   ├── swarm
│   │   ├── 01-age-onset.md
│   │   ├── 02-mental-health.md
│   │   ├── 03-personality-kinks.md
│   │   ├── 04-politics-deep.md
│   │   ├── 05-gender-deep.md
│   │   ├── 06-taboo-clusters.md
│   │   ├── 07-relationships.md
│   │   ├── 08-orientation-identity.md
│   │   ├── 09-porn-media.md
│   │   ├── 10-surprises.md
│   │   ├── 11-bootstrap-cis.md
│   │   ├── 12-multivariate.md
│   │   ├── 12-multivariate.py +
│   │   ├── 13-interactions.md
│   │   ├── 14-missingness.md
│   │   └── 15-clustering.md
│   ├── tests
│   │   ├── test_findings.py +
│   │   └── test_toolkit.py +
│   ├── META-FINDINGS.md
│   ├── README.md
│   ├── __init__.py
│   ├── build_findings.py +
│   ├── explore.py +
│   ├── findings.json
│   ├── pyproject.toml
│   ├── toolkit.py +
│   └── uv.lock
├── data
│   ├── BKSPublic.parquet
│   ├── BKSPublic_column_notes.txt
│   └── Big Kink Survey (970k cleaned).md
├── e2e
│   ├── capture-explore-detail.cjs
│   ├── capture-explore-filters.cjs
│   ├── capture-explore.cjs
│   ├── capture-explore.mjs
│   ├── capture-profile-relationships.mjs
│   ├── columns.spec.ts +
│   ├── dashboard.spec.ts +
│   ├── explore.spec.ts +
│   ├── interactive-test-about.mjs
│   ├── interactive-test-combobox.mjs
│   ├── interactive-test-combobox2.mjs
│   ├── interactive-test-combobox3.mjs
│   ├── interactive-test-dashboard.mjs
│   ├── interactive-test-focus.mjs
│   ├── interactive-test-fresh-nav.mjs
│   ├── interactive-test-href.mjs
│   ├── interactive-test-nav-urls.mjs
│   ├── navigation.spec.ts +
│   ├── profile-rel-sql-notebook.spec.ts +
│   ├── screenshot-columns.cjs
│   ├── screenshot-columns2.cjs
│   ├── screenshot-notebook-with-entry.mjs
│   ├── screenshot-sql-detail.mjs
│   ├── screenshot-sql-notebook.mjs
│   ├── screenshot-sql-results.mjs
│   ├── take-screenshots-zoom.mjs
│   ├── take-screenshots-zoom2.mjs
│   ├── take-screenshots.mjs
│   ├── visual-review-columns.md
│   ├── visual-review-dashboard-about.md
│   ├── visual-review-explore.md
│   ├── visual-review-profile-relationships.md
│   └── visual-review-sql-notebook.md
├── mcp-server
│   ├── Dockerfile
│   ├── pyproject.toml
│   ├── server.py +
│   └── uv.lock
├── public
│   ├── BKSPublic.parquet
│   ├── favicon.ico
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   ├── robots.txt
│   ├── tanstack-circle-logo.png
│   └── tanstack-word-logo-white.svg
├── package.json *
├── tsconfig.json *
├── vite.config.ts * +
├── .gitignore
├── .mcp.json
├── .npmrc
├── CLAUDE.md
├── META-PLAN.md
├── playwright.config.ts +
└── pnpm-lock.yaml


(* denotes selected files)
(+ denotes code-map available)

File: /Users/austin/dev/kink/src/lib/server/sql-guards.ts
Imports:
---
Classes:
  - SqlGuardError
    Methods:
      - L36: constructor(code: string, message: string)
    Properties:
      - readonly code: string

Type-aliases:
  - FilterValue
  - FilterInput

Functions:
  - L43: export function normalizeSql(rawSql: string): string
  - L47: export function ensureReadOnlySql(rawSql: string): string
  - L78: export function clampLimit(limit: number | undefined, defaultLimit = DEFAULT_QUERY_LIMIT): number
  - L94: export function applyLimitToQuery(sql: string, limit: number): string
  - L104: export function quoteIdentifier(identifier: string): string
  - L108: export function quoteLiteral(value: string | number | boolean | null): string
  - L131: export function buildWhereClause(filters: Record<string, FilterInput> | undefined): string

Global vars:
  - DEFAULT_QUERY_LIMIT
  - HARD_QUERY_LIMIT
  - DEFAULT_QUERY_TIMEOUT_MS
  - allowedLeadingKeywords
  - blockedTokens
  - blockedRegex

Exports:
  - export const DEFAULT_QUERY_LIMIT = 1_000;
  - export const HARD_QUERY_LIMIT = 10_000;
  - export const DEFAULT_QUERY_TIMEOUT_MS = 5_000;
  - export class SqlGuardError extends Error {
  - export function normalizeSql(rawSql: string): string {
  - export function ensureReadOnlySql(rawSql: string): string {
  - export function clampLimit(limit: number | undefined, defaultLimit = DEFAULT_QUERY_LIMIT): number {
  - export function applyLimitToQuery(sql: string, limit: number): string {
  - export function quoteIdentifier(identifier: string): string {
  - export function quoteLiteral(value: string | number | boolean | null): string {
  - export type FilterValue = string | number | boolean | null;
  - export type FilterInput = FilterValue | FilterValue[];
  - export function buildWhereClause(filters: Record<string, FilterInput> | undefined): string {
---


File: /Users/austin/dev/kink/src/lib/schema/null-meaning.ts
Imports:
  - import type { CaveatKey } from "./caveats";
---

Type-aliases:
  - NullMeaning

Functions:
  - L20: export function inferNullMeaning(columnName: string, nullRatio: number, caveatKeys: CaveatKey[]): NullMeaning

Global vars:
  - NOT_APPLICABLE_PATTERNS: RegExp[]

Exports:
  - export type NullMeaning = "GATED" | "LATE_ADDED" | "NOT_APPLICABLE" | "UNKNOWN";
  - export function inferNullMeaning(columnName: string, nullRatio: number, caveatKeys: CaveatKey[]): NullMeaning {
---


File: /Users/austin/dev/kink/src/lib/duckdb/init.ts
Imports:
  - import * as duckdb from "@duckdb/duckdb-wasm";
  - import duckdbMvpWasm from "@duckdb/duckdb-wasm/dist/duckdb-mvp.wasm?url";
  - import duckdbMvpWorker from "@duckdb/duckdb-wasm/dist/duckdb-browser-mvp.worker.js?url";
  - import duckdbEhWasm from "@duckdb/duckdb-wasm/dist/duckdb-eh.wasm?url";
  - import duckdbEhWorker from "@duckdb/duckdb-wasm/dist/duckdb-browser-eh.worker.js?url";
---

Type-aliases:
  - DuckDBInitPhase
  - PhaseListener

Functions:
  - L23: function setPhase(phase: DuckDBInitPhase): void
  - L30: export function subscribeDuckDBPhase(listener: PhaseListener): () =>
  - L38: async function createDb(): Promise<duckdb.AsyncDuckDB>
  - L73: export function getDuckDB(): Promise<duckdb.AsyncDuckDB>

Global vars:
  - PARQUET_URL
  - dbPromise: Promise<duckdb.AsyncDuckDB> | null
  - currentPhase: DuckDBInitPhase
  - phaseListeners

Exports:
  - export type DuckDBInitPhase =
  - export function subscribeDuckDBPhase(listener: PhaseListener): () => void {
  - export function getDuckDB(): Promise<duckdb.AsyncDuckDB> {
---

</file_map>
<file_contents>
File: /Users/austin/dev/kink/docs/plans/active/v5-user-feedback-ux.md
(lines 1-203)
```md
# Plan: V5 User Feedback UX Improvements

Status: Draft
Created: 2026-02-14
Source: Direct user testing feedback

## Context

A real user tested the app and gave three pieces of feedback, all related to discoverability and visual clarity:

1. **What's Connected page**: "When it says 'of these options what is the most erotic' it doesn't show the answer... So it's not relevant." Multiple questions share identical display names (e.g., "Of these options, which one is the most erotic?" appears 4+ times). The hash suffix that differentiates them (`35jn7ei`, `35jn7ej`, etc.) is stripped by `getColumnDisplayName()`. Users can't tell them apart. Same problem with "How old were you when you first experienced..." questions.

2. **Profile page — visuals**: "I think in the profile building it would be more fun to be able to see all the questions and how they compare with the average visually like in your graphs." The profile results (sections 03-04) are pure data tables. The user wants visual bar charts like the featured findings on the home page.

3. **Profile page — layout/compare**: "Or compare to another profile / But also visually / The way it's laid out is kind of confusing." Compare mode exists but results are tables. The overall layout is hard to follow.

---

## Issue 1: Ambiguous Question Names on What's Connected

### Root Cause

- Column names in the parquet include a hash suffix: `"Of these options, which one is the most erotic? (35jn7ei)"`
- `getColumnDisplayName()` strips the hash via `stripHashSuffix()`, producing identical display text
- The relationships table shows ~20 related questions with no way to distinguish duplicates
- The actual answer options (e.g., "Affection, Cuddling, Romance..." vs "Octopi/squid, Foxes, Dolphins...") are the real differentiator but are never shown

### Options

**Option A: Show top answer values as subtitle (Recommended)**

Under each question link in the relationships table, show the top 2-3 answer values from the schema as a gray subtitle. E.g.:

> Of these options, which one is the most erotic?
> _Affection · Cuddling · Romance · ..._

Implementation:
- Add `approxTopValues` to `columns.generated.json` during schema profiling (run `pnpm profile-schema` to populate)
- OR query DuckDB at page load for columns that have duplicate display names (lazy, only when needed)
- Render as a secondary line in the relationships table, styled in `mono-value` at smaller size

Pros: Immediately disambiguates. Tells the user what the question is actually about.
Cons: Need to either extend schema generation or add a DuckDB query. Adds vertical space to the table.

**Option B: Keep hash suffix for duplicates only**

If a display name appears more than once in the list, append the hash suffix back: "Of these options, which one is the most erotic? (35jn7ei)".

Pros: Zero data changes, pure display logic.
Cons: Hash suffix is meaningless to users — they still can't tell what the question is about.

**Option C: Use a tooltip to show answer options on hover**

Keep the current display but add a hover tooltip (or click-to-expand) showing the column's top values.

Pros: Doesn't change layout. Progressive disclosure.
Cons: Discoverability problem — user won't know to hover. Doesn't solve the "it's not relevant" feeling.

### Recommendation

**Option A**. The answer values ARE the question identity for these "Of these options..." columns. Showing them inline makes the page actually useful. Option B is a minimal fallback if Option A is too much work.

---

## Issue 2: Profile Results Need Visual Charts

### Current State

- **Section 03 "How This Group Compares"**: DataTable with columns [Metric, Group Median, Ranking vs. Everyone, N]. Shows 5 personality/kink metrics.
- **Section 04 "What Makes This Group Different"**: DataTable with columns [Column, Value, Times more likely, Group % (N), Global % (N)]. Shows top 8 over-indexed traits.

The user wants charts "like your graphs" (referring to the grouped bar charts on the home page).

### Options

**Option A: Horizontal bar chart for over-indexing (Recommended)**

Replace or supplement section 04's table with a horizontal bar chart showing the top over-indexed traits. Each bar shows group % vs global %, with the ratio as a label.

```
Age: 25-28          ████████████████████ 100% group  ▎▎▎▎ 21% global  (4.73x)
Biological Sex: Male  ████████████████████ 100% group  ██████████ 51% global  (1.95x)
Bondage: Chastity     ██ 2.4% group  ▎ 1.6% global  (1.53x)
```

Implementation:
- New component: `OverIndexChart` — horizontal paired bars (group vs global), sorted by ratio
- Data is already available in `summary.overIndexing`
- Keep the table below as a "detailed view" toggle for power users

Pros: Immediately visual. Reuses existing data. The ratio (4.73x) becomes viscerally clear.
Cons: New component to build. Need to handle long column+value labels.

**Option B: Radar/spider chart for personality metrics**

Section 03's 5 personality metrics (kink count, powerlessness, openness, extroversion, neuroticism) as a radar chart showing the group's percentile vs the 50th percentile baseline.

Pros: Compelling "personality profile" visualization.
Cons: Radar charts are notoriously hard to read. Only 5 data points — might be underwhelming.

**Option C: Simple bar chart for section 03, keep table for section 04**

Replace section 03's table with a vertical bar chart where each bar is the group's percentile (0-100%), with a 50% reference line.

```
Kink Categories  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 54%
Powerlessness    ▓▓▓▓▓▓▓▓▓▓▓▓ 48%
Openness         ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 60%  ← above average
Extroversion     ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 62%  ← above average
Neuroticism      ▓▓▓▓▓▓▓▓▓▓ 42%
                 ──────────50%──────────
```

Pros: Simple, clear, easy to build with existing `SimpleBarChart`. The 50% line makes "above/below average" instantly obvious.
Cons: Doesn't address section 04 (over-indexing), which is the more interesting part.

**Option D: Combined approach (A + C)**

Use Option C for section 03 (percentile bar chart with 50% reference line) AND Option A for section 04 (horizontal over-indexing bars). This gives both sections visual treatment.

Pros: Full visual overhaul. Both sections become scannable.
Cons: More work, but each component is independently simple.

### Recommendation

**Option D** — both sections deserve visualization. Section 03 is a quick win with `SimpleBarChart` + reference line. Section 04 is the big payoff (the "what makes you different" is the most interesting part of the page).

---

## Issue 3: Profile Page Layout & Compare Mode

### Current Problems

1. **Confusing flow**: The page jumps from filter controls → stat cards → data table → data table with no visual breaks or narrative
2. **Compare mode results are dense**: Two side-by-side DataTables with 6+ columns each
3. **No visual distinction between group and global**: Just numbers in columns

### Options

**Option A: Narrative layout with chart sections (Recommended)**

Restructure the results into a clear story flow:

```
01. Choose your group          [existing, keep as-is]
02. Your group at a glance     [stat cards — existing, minor cleanup]
03. Personality snapshot        [NEW: bar chart of percentiles vs 50% baseline]
04. What stands out             [NEW: horizontal bar chart of over-indexed traits]
05. Explore deeper              [links to crosstab with pre-populated filters]
```

For compare mode, sections 03-04 show side-by-side or overlaid charts:
- Section 03: Grouped bar chart (Group A vs Group B percentiles)
- Section 04: Paired horizontal bars (Group A over-indexing vs Group B)

Implementation:
- Reorder existing sections for better narrative flow
- Add chart components from Issue 2
- For compare mode: use `GroupedBarChart` (already exists) for section 03
- Keep tables available as expandable "Show data" toggles

**Option B: Tab-based results**

Put single/compare results in tabs: "Summary | Personality | What's Different | Raw Data"

Pros: Clean separation. Each tab is focused.
Cons: Hides information. User has to click through tabs to see everything.

**Option C: Minimal cleanup — just add visual breathing room**

Keep current structure but add:
- Clearer section dividers
- Better section headers with descriptions
- Larger stat cards
- Slightly wider tables

Pros: Least work.
Cons: Doesn't address the core "it's confusing" feedback.

### Recommendation

**Option A**. The narrative flow is what makes the home page work well (per the UX testing report). Apply the same principle here: lead with a clear story, use charts as the primary view, tables as secondary detail.

---

## Implementation Scope Estimate

| Item | Effort | Dependencies |
|------|--------|-------------|
| Issue 1: Answer value subtitles on relationships | Small | Schema profiling or DuckDB query |
| Issue 2: Percentile bar chart (section 03) | Small | Extend `SimpleBarChart` with reference line |
| Issue 2: Over-indexing horizontal bars (section 04) | Medium | New `OverIndexChart` component |
| Issue 3: Layout restructure + compare charts | Medium | Builds on Issue 2 components |

Suggested order: Issue 1 → Issue 2 (section 03) → Issue 2 (section 04) → Issue 3

---

## Open Questions

1. Should the over-indexing chart show group % vs global %, or just the ratio? (Ratio is more dramatic; both percentages give full context.)
2. For compare mode charts, overlay on same axes or side-by-side? (Overlay is more compact; side-by-side is clearer.)
3. Should we add "category context" to the column schema more broadly (not just for relationships page)? This would help everywhere column names are truncated.

```

File: /Users/austin/dev/kink/docs/design/frontend.md
(lines 1-155)
```md
# Frontend Design System — "Ink & Paper"

Direction: editorial research journal. The UI should feel like a beautifully typeset academic publication — warm, authoritative, and clear. Think NYT data journalism meets a well-set research paper.

## Design Tokens

### Colors (CSS variables)

```css
--paper: #f5f0e8;          /* primary background */
--paper-warm: #ede6d8;      /* secondary/sidebar background */
--ink: #1a1612;             /* primary text */
--ink-light: #4a4238;       /* secondary text */
--ink-faded: #8a7e70;       /* tertiary/muted text */
--rule: #c8bfb0;            /* borders, horizontal rules */
--rule-light: #ddd5c8;      /* subtle dividers */
--accent: #b8432f;          /* emphasis, links, active states */
--accent-hover: #9a3625;    /* accent hover/pressed */
--highlight: #e8d5a0;       /* selection, highlight backgrounds */
--sidebar-bg: #eae3d5;      /* raised panel backgrounds */
```

**Principle**: Dominant warm cream with ink-dark text. Red accent used sparingly — section numbers, active nav, percentage highlights. No gradients. No neon. No purple.

### Typography

| Role | Font | Weight | Size | Tracking |
|---|---|---|---|---|
| Display / H1 | Fraunces | 700 | 2.75rem | -0.03em |
| Section headers | Fraunces | 600 | 1.2rem | normal |
| Body text | Source Serif 4 | 400 | 1rem (16px) | normal |
| Body emphasis | Source Serif 4 | 600 | 0.95rem | normal |
| Subtitle/italic | Source Serif 4 italic | 400 | 1.1rem | normal |
| Data / mono | JetBrains Mono | 400-500 | 0.8rem | normal |
| Labels / caps | JetBrains Mono | 400 | 0.65rem | 0.12em, uppercase |
| Large numbers | Fraunces | 700 | 2.5rem | -0.03em |

**Google Fonts import**:
```
Fraunces:ital,opsz,wght@0,9..144,300;0,9..144,400;0,9..144,600;0,9..144,700;1,9..144,400
Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;1,8..60,400
JetBrains+Mono:wght@400;500
```

**Rules**:
- Never use system fonts, Inter, Roboto, or Arial
- Fraunces for headlines and large numbers only — never body
- Source Serif 4 for all body/paragraph text
- JetBrains Mono for data values, column names, SQL, code, and all-caps labels
- Pair font sizes with appropriate line-height: display 1.1, body 1.6, data 1.4

### Spacing

Base unit: `1rem` (16px). Use multiples: 0.5, 0.75, 1, 1.5, 2, 3.

- Page padding: `3rem 2rem` (top/bottom, left/right)
- Section gaps: `3rem` between major sections
- Card padding: `1.5rem 2rem`
- Table cell padding: `0.6rem 0`
- Max content width: `1200px`, centered

### Borders & Rules

- Primary divider: `2px solid var(--ink)` (nav bottom, section separators)
- Section divider: `1px solid var(--rule)` (between content areas)
- Table header border: `2px solid var(--ink)` bottom
- Table row borders: `1px solid var(--rule-light)` bottom
- Card borders: `1px solid var(--rule)` or `1px solid var(--ink)` for emphasis
- **No border-radius anywhere** — square corners are part of the editorial identity

### Backgrounds & Texture

- Apply a subtle paper noise texture via SVG filter overlay on `body::before` at ~3% opacity
- No solid color cards — use `var(--paper)` base with `var(--sidebar-bg)` for raised panels
- The accent bar on stat sections: a `3px` solid red line above the panel
- No box shadows. Depth comes from borders and background contrast only.

## Component Patterns

### Navigation

- Horizontal bar with `2px solid var(--ink)` bottom border
- Logo: Fraunces 700, 1.5rem. Subtitle in Source Serif italic, faded
- Links: Source Serif 0.85rem, uppercase with 0.06em tracking
- Active state: `var(--accent)` color + `2px` bottom border in accent
- No pills, no background highlights — editorial underline style

### Stat Cards

- Grid row with no gaps, shared `1px solid var(--ink)` outer border
- Internal dividers: `1px solid var(--rule)` between cells
- Label: JetBrains Mono, 0.65rem, uppercase, faded
- Value: Fraunces 700, 2.5rem
- Optional note: Source Serif italic, 0.8rem, faded

### Data Tables

- Full-width, no outer border
- Header: JetBrains Mono, 0.65rem, uppercase, faded. Bottom border `2px solid var(--ink)`
- Rows: `1px solid var(--rule-light)` bottom. No zebra striping
- First column (names): JetBrains Mono, ink color
- Numeric columns: JetBrains Mono, right-aligned
- Optional inline bar: 4px height, accent color at 30% opacity, positioned absolutely

### Section Headers

- Fraunces 600, 1.2rem
- Bottom border: `1px solid var(--rule)`
- Numbered: JetBrains Mono section number in accent color (e.g., "01", "02")
- Use `display: flex; align-items: baseline; gap: 0.75rem;`

### Form Controls (selects, inputs)

- JetBrains Mono, 0.8rem
- `1px solid var(--rule)` border, `var(--paper)` background
- No border-radius
- Custom dropdown arrow via `::after` pseudo-element
- Focus: border-color to `var(--ink)`

### Raised Panels (Column Inspector, etc.)

- Background: `var(--sidebar-bg)`
- Border: `1px solid var(--rule)`
- Top accent bar: `3px solid var(--accent)` via `::before` pseudo-element
- Internal stat grids: `1px` gap with `var(--rule)` background showing through

### Caveats / Callouts

- No background color — just content with rule dividers
- Title: Source Serif 600, 0.95rem
- Body: Source Serif 400, 0.85rem, `var(--ink-light)`
- Guidance: Source Serif italic, 0.75rem, `var(--ink-faded)`

## Animation

- Entrance: `fadeUp` — opacity 0→1, translateY 12px→0, 0.6s ease-out
- Stagger delays: 0.1s increments for sequential sections
- No hover animations on cards (editorial, not SaaS)
- Transitions on nav links: color 0.2s

## Anti-Patterns — Never Do These

- **No dark mode** — this is a light, warm design. The paper IS the identity
- **No border-radius** — square corners everywhere
- **No gradients** — flat colors, borders, and typography create hierarchy
- **No box-shadows** — depth via background contrast and rules
- **No Inter/Roboto/system fonts** — always Fraunces + Source Serif + JetBrains
- **No purple, blue, or neon accents** — only red (`#b8432f`) as accent
- **No pill buttons or rounded chips** — square, bordered elements
- **No emoji or icons in headers** — numbered sections and typography only
- **No card hover lift effects** — this is a journal, not a dashboard

## Reference Mockup

The canonical mockup is at `design-mockups/01-ink-and-paper.html`. Open it in a browser to see the full dashboard rendered in this design system. All implementation should match this aesthetic.

```

File: /Users/austin/dev/kink/docs/design/architecture.md
(lines 1-100)
```md
# Architecture

## Stack
- **Framework**: TanStack Start (React) + Nitro (server runtime)
- **Styling**: Tailwind v4
- **Build**: Vite 7, TypeScript strict mode
- **Data engine (web/API)**: DuckDB CLI (`duckdb -json`) over `data/BKSPublic.parquet`
- **Data engine (metadata generation)**: `@duckdb/node-api` in `scripts/profile-schema.mjs`
- **Data engine (MCP)**: DuckDB Python bindings in `mcp-server/server.py`
- **Deploy**: Railway (web service + optional MCP service)

## Key Technical Decisions

### Nitro plugin required for deployment
TanStack Start needs `nitro` from `nitro/vite` in `vite.config.ts` to produce `.output/` build artifacts. Without it, Vite outputs to `dist/` which does not include the Nitro server runtime.

### `verbatimModuleSyntax` disabled
TanStack docs warn that `verbatimModuleSyntax: true` can leak server bundles into client bundles. `tsconfig.json` sets it to `false`.

### Entry files
`src/router.tsx` exports `getRouter()`. `src/routeTree.gen.ts` is auto-generated by TanStack during `pnpm dev`/`pnpm build`.

### API route model
Server routes under `src/routes/api/*` are thin wrappers that:
1. Validate request boundaries via Zod contracts in `src/lib/api/contracts.ts`.
2. Apply SQL/read-only guardrails in `src/lib/server/sql-guards.ts`.
3. Execute bounded queries via `src/lib/server/db.ts`.
4. Return typed JSON envelopes (`ok`/`error`) via `src/lib/server/api-response.ts`.

### Why DuckDB CLI in the server layer
`@duckdb/node-api` is used for schema profiling scripts but currently avoided as the primary runtime engine because Nitro build/bundling with native `.node` bindings is fragile. Runtime API queries execute via the `duckdb` binary and JSON output, with timeout and row-limit controls. A fallback to `@duckdb/node-api` activates automatically when the CLI binary is not available (e.g., on Railway), with bigint normalization for JSON compatibility.

## Data and Metadata Flow
1. Source parquet lives at `data/BKSPublic.parquet`.
2. `pnpm sync-public-data` copies parquet to `public/BKSPublic.parquet`.
3. `pnpm profile-schema` regenerates `src/lib/schema/columns.generated.json`.
4. `/api/schema`, `/api/stats/$column`, `/api/crosstab`, `/api/query` consume that metadata and parquet data.
5. UI pages and AI docs route (`/llms.txt`) call the shared schema metadata layer and API endpoints.

## Current Route Coverage

### UI Pages
- `/about` — intro page: dataset background, methodology caveats, feature guide, credits (links to Aella's blog post)
- `/` — dashboard with schema stats, global caveats, missingness histogram, tag breakdown, column inspector
- `/explore` — Explore hub landing page with navigation cards for Compare Questions, Browse Topics, Build a Profile, What's Connected?, and Data Quality
- `/explore/crosstab` — cross-tab explorer with pivot matrix, Cramer's V, normalization modes, demographic filters, value-label rendering, URL state sync, cell drilldown, notebook save
- `/columns` — Column Atlas with search, tag filters, sort modes, Column Inspector panel, URL state sync
- `/profile` — cohort builder with single/compare modes, percentile cards, over-indexing signals, cohort rarity metric, URL state sync, notebook save
- `/relationships` — Relationship Finder with precomputed Cramer's V and Pearson correlations for 159 columns, URL state sync
- `/sql` — SQL console with templates, click-to-insert quoted identifiers, CSV export, notebook save
- `/notebook` — Research Notebook with localStorage persistence, inline editing, source links, JSON export

### AI Discovery Route
- `/llms.txt` — machine-readable AI integration docs generated from schema metadata (`getSchemaMetadata`, `listColumns`)

### API Endpoints
- `/api/health`, `/api/schema`, `/api/query`, `/api/stats/$column`, `/api/crosstab`

## Shared Components
- `src/components/pivot-matrix.tsx` — pivot table with normalization, marginals, and bucket metadata for drilldown SQL
- `src/components/column-inspector.tsx` — column detail panel with stats queries
- `src/components/column-combobox.tsx` — searchable column picker used across major routes
- `src/components/data-table.tsx` — generic editorial data table
- `src/components/loading-skeleton.tsx` — phase-aware loading skeletons
- `src/components/missingness-badge.tsx` — null meaning badge (GATED, LATE_ADDED, etc.)
- `src/components/sample-size-display.tsx` — N/non-null/used display
- `src/components/section-header.tsx` — numbered section headers
- `src/components/stat-card.tsx` — stat display card

## Ad-Hoc Data Queries (for agents)

The `duckdb` CLI is installed locally and can query the parquet file directly. This is the fastest way to inspect data without starting the dev server.

```bash
# Basic query
duckdb -c "SELECT column_name, count(*) FROM read_parquet('data/BKSPublic.parquet') WHERE column_name IS NOT NULL GROUP BY 1 ORDER BY 2 DESC"

# JSON output (for piping/parsing)
duckdb -json -c "SELECT DISTINCT whowears FROM read_parquet('data/BKSPublic.parquet') WHERE whowears IS NOT NULL"

# Describe all columns
duckdb -c "DESCRIBE SELECT * FROM read_parquet('data/BKSPublic.parquet')"

# Sample rows
duckdb -c "SELECT * FROM read_parquet('data/BKSPublic.parquet') LIMIT 5"
```

Note: `@duckdb/node-api` and Python `duckdb` are also available but require their respective runtimes. The CLI is the simplest option — no imports or environment setup needed.

## Key Libraries
- `src/lib/notebook-store.ts` — localStorage CRUD for notebook entries
- `src/lib/format.ts` — number/percent formatting utilities
- `src/lib/format-labels.ts` — shared value-label and column display-name formatting
- `src/lib/schema/null-meaning.ts` — null meaning inference (NOT_APPLICABLE, GATED, LATE_ADDED, UNKNOWN)
- `src/lib/schema/metadata.ts` — schema metadata access layer
- `src/lib/schema/relationships.generated.json` — precomputed pairwise associations (3,065 entries)
- `src/lib/duckdb/init.ts` — DuckDB initialization with phase callbacks (`idle -> downloading-wasm -> initializing -> loading-parquet -> ready`)
- `src/lib/duckdb/provider.tsx` — React context exposing `db`, `loading`, `error`, and init `phase`
- `src/lib/duckdb/use-query.ts` — React hook for DuckDB-WASM queries
- `src/lib/duckdb/sql-helpers.ts` — SQL quoting and WHERE clause builder

```

File: /Users/austin/dev/kink/src/routes/profile.tsx
(lines 1-1251)
```tsx
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { useCallback, useEffect, useMemo, useState } from "react";

import { ColumnCombobox } from "@/components/column-combobox";
import { DataTable } from "@/components/data-table";
import { LoadingSkeleton } from "@/components/loading-skeleton";
import { SectionHeader } from "@/components/section-header";
import { StatCard } from "@/components/stat-card";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import type { SchemaData } from "@/lib/api/contracts";
import { getSchema } from "@/lib/client/api";
import { DEFAULTS_BY_PAGE } from "@/lib/chart-presets";

import { ColumnNameTooltip } from "@/components/column-name-tooltip";
import { formatValueWithLabel, getColumnDisplayName } from "@/lib/format-labels";
import { useDuckDB } from "@/lib/duckdb/provider";
import { quoteIdentifier, quoteLiteral } from "@/lib/duckdb/sql-helpers";
import { asNumber, formatNumber, formatPercent } from "@/lib/format";
import { addNotebookEntry } from "@/lib/notebook-store";

export const Route = createFileRoute("/profile")({
  validateSearch: (
    search,
  ): {
    mode?: Mode;
    c0?: string;
    c1?: string;
    c2?: string;
    v0?: string;
    v1?: string;
    v2?: string;
    ac0?: string;
    ac1?: string;
    ac2?: string;
    av0?: string;
    av1?: string;
    av2?: string;
    bc0?: string;
    bc1?: string;
    bc2?: string;
    bv0?: string;
    bv1?: string;
    bv2?: string;
  } => ({
    mode: search.mode === "compare" ? "compare" : search.mode === "single" ? "single" : undefined,
    c0: typeof search.c0 === "string" ? search.c0 : undefined,
    c1: typeof search.c1 === "string" ? search.c1 : undefined,
    c2: typeof search.c2 === "string" ? search.c2 : undefined,
    v0: typeof search.v0 === "string" ? search.v0 : undefined,
    v1: typeof search.v1 === "string" ? search.v1 : undefined,
    v2: typeof search.v2 === "string" ? search.v2 : undefined,
    ac0: typeof search.ac0 === "string" ? search.ac0 : undefined,
    ac1: typeof search.ac1 === "string" ? search.ac1 : undefined,
    ac2: typeof search.ac2 === "string" ? search.ac2 : undefined,
    av0: typeof search.av0 === "string" ? search.av0 : undefined,
    av1: typeof search.av1 === "string" ? search.av1 : undefined,
    av2: typeof search.av2 === "string" ? search.av2 : undefined,
    bc0: typeof search.bc0 === "string" ? search.bc0 : undefined,
    bc1: typeof search.bc1 === "string" ? search.bc1 : undefined,
    bc2: typeof search.bc2 === "string" ? search.bc2 : undefined,
    bv0: typeof search.bv0 === "string" ? search.bv0 : undefined,
    bv1: typeof search.bv1 === "string" ? search.bv1 : undefined,
    bv2: typeof search.bv2 === "string" ? search.bv2 : undefined,
  }),
  component: ProfilePage,
});

interface ProfileSummary {
  totalSize: number;
  cohortSize: number;
  cohortSharePercent: number;
  cohortRarity: number;
  percentileCards: Array<{
    metric: string;
    cohortMedian: number | null;
    globalPercentile: number | null;
  }>;
  overIndexing: Array<{
    columnName: string;
    value: string;
    cohortCount: number;
    globalCount: number;
    cohortPct: number;
    globalPct: number;
    ratio: number;
  }>;
}

interface ComparisonResult {
  a: ProfileSummary;
  b: ProfileSummary;
}

interface ComparisonPercentileRow {
  metric: string;
  medianA: number | null;
  medianB: number | null;
  delta: number | null;
}

type Mode = "single" | "compare";

const NONE = "__none__";
const SUGGESTED_COHORTS = DEFAULTS_BY_PAGE.profile?.suggestedCohorts ?? [];

type FilterPair = { column: string; value: string };

function getWarning(cohortSize: number) {
  if (cohortSize < 30) {
    return {
      kind: "critical" as const,
      message: "Fewer than 30 people - too few for meaningful results.",
    };
  }
  if (cohortSize < 100) {
    return {
      kind: "warn" as const,
      message: "Fewer than 100 people - results may not be reliable.",
    };
  }
  return null;
}

function ProfilePage() {
  const search = Route.useSearch();
  const [initialSearch] = useState(search);
  const navigate = useNavigate({ from: "/profile" });
  const { db, phase } = useDuckDB();
  const [schema, setSchema] = useState<SchemaData | null>(null);
  const [schemaError, setSchemaError] = useState<string | null>(null);
  const [searchReady, setSearchReady] = useState(false);

  const [mode, setMode] = useState<Mode>("single");

  // Single-cohort state
  const [selectedColumns, setSelectedColumns] = useState<[string, string, string]>(["", "", ""]);
  const [selectedValues, setSelectedValues] = useState<Record<string, string>>({});
  const [valueOptionsByColumn, setValueOptionsByColumn] = useState<Record<string, string[]>>({});

  // Compare-cohort state
  const [columnsA, setColumnsA] = useState<[string, string, string]>(["", "", ""]);
  const [valuesA, setValuesA] = useState<Record<string, string>>({});
  const [valueOptionsA, setValueOptionsA] = useState<Record<string, string[]>>({});

  const [columnsB, setColumnsB] = useState<[string, string, string]>(["", "", ""]);
  const [valuesB, setValuesB] = useState<Record<string, string>>({});
  const [valueOptionsB, setValueOptionsB] = useState<Record<string, string[]>>({});

  const [summary, setSummary] = useState<ProfileSummary | null>(null);
  const [comparison, setComparison] = useState<ComparisonResult | null>(null);
  const [runError, setRunError] = useState<string | null>(null);
  const [running, setRunning] = useState(false);
  const [notebookSaved, setNotebookSaved] = useState(false);

  useEffect(() => {
    let cancelled = false;

    void getSchema()
      .then((response) => {
        if (cancelled) return;
        const nextSchema = response.data;
        setSchema(nextSchema);

        const demographicColumns = nextSchema.columns
          .filter((c) => c.tags.includes("demographic") && c.logicalType === "categorical")
          .slice(0, 3)
          .map((c) => c.name);
        const availableColumns = new Set(nextSchema.columns.map((column) => column.name));

        const resolveColumn = (candidate: string | undefined, fallback: string) => {
          if (candidate && availableColumns.has(candidate)) {
            return candidate;
          }
          return fallback;
        };

        const defaults: [string, string, string] = [
          demographicColumns[0] ?? "",
          demographicColumns[1] ?? "",
          demographicColumns[2] ?? "",
        ];

        const initialSingleColumns: [string, string, string] = [
          resolveColumn(initialSearch.c0, defaults[0]),
          resolveColumn(initialSearch.c1, defaults[1]),
          resolveColumn(initialSearch.c2, defaults[2]),
        ];
        const initialColumnsA: [string, string, string] = [
          resolveColumn(initialSearch.ac0, defaults[0]),
          resolveColumn(initialSearch.ac1, defaults[1]),
          resolveColumn(initialSearch.ac2, defaults[2]),
        ];
        const initialColumnsB: [string, string, string] = [
          resolveColumn(initialSearch.bc0, defaults[0]),
          resolveColumn(initialSearch.bc1, defaults[1]),
          resolveColumn(initialSearch.bc2, defaults[2]),
        ];

        setMode(initialSearch.mode === "compare" ? "compare" : "single");
        setSelectedColumns(initialSingleColumns);
        setColumnsA(initialColumnsA);
        setColumnsB(initialColumnsB);

        const initialSingleValues: Record<string, string> = {};
        const initialValuesA: Record<string, string> = {};
        const initialValuesB: Record<string, string> = {};

        if (initialSingleColumns[0] && initialSearch.v0) initialSingleValues[initialSingleColumns[0]] = initialSearch.v0;
        if (initialSingleColumns[1] && initialSearch.v1) initialSingleValues[initialSingleColumns[1]] = initialSearch.v1;
        if (initialSingleColumns[2] && initialSearch.v2) initialSingleValues[initialSingleColumns[2]] = initialSearch.v2;

        if (initialColumnsA[0] && initialSearch.av0) initialValuesA[initialColumnsA[0]] = initialSearch.av0;
        if (initialColumnsA[1] && initialSearch.av1) initialValuesA[initialColumnsA[1]] = initialSearch.av1;
        if (initialColumnsA[2] && initialSearch.av2) initialValuesA[initialColumnsA[2]] = initialSearch.av2;

        if (initialColumnsB[0] && initialSearch.bv0) initialValuesB[initialColumnsB[0]] = initialSearch.bv0;
        if (initialColumnsB[1] && initialSearch.bv1) initialValuesB[initialColumnsB[1]] = initialSearch.bv1;
        if (initialColumnsB[2] && initialSearch.bv2) initialValuesB[initialColumnsB[2]] = initialSearch.bv2;

        setSelectedValues(initialSingleValues);
        setValuesA(initialValuesA);
        setValuesB(initialValuesB);
        setSearchReady(true);
      })
      .catch((error: Error) => {
        if (!cancelled) {
          setSchemaError(error.message);
          setSearchReady(true);
        }
      });

    return () => {
      cancelled = true;
    };
  }, [initialSearch]);

  useEffect(() => {
    if (!searchReady) return;

    const singleValue0 = selectedColumns[0] ? selectedValues[selectedColumns[0]] : undefined;
    const singleValue1 = selectedColumns[1] ? selectedValues[selectedColumns[1]] : undefined;
    const singleValue2 = selectedColumns[2] ? selectedValues[selectedColumns[2]] : undefined;

    const valueA0 = columnsA[0] ? valuesA[columnsA[0]] : undefined;
    const valueA1 = columnsA[1] ? valuesA[columnsA[1]] : undefined;
    const valueA2 = columnsA[2] ? valuesA[columnsA[2]] : undefined;

    const valueB0 = columnsB[0] ? valuesB[columnsB[0]] : undefined;
    const valueB1 = columnsB[1] ? valuesB[columnsB[1]] : undefined;
    const valueB2 = columnsB[2] ? valuesB[columnsB[2]] : undefined;

    void navigate({
      search: {
        mode: mode === "compare" ? "compare" : undefined,
        c0: mode === "single" ? selectedColumns[0] || undefined : undefined,
        c1: mode === "single" ? selectedColumns[1] || undefined : undefined,
        c2: mode === "single" ? selectedColumns[2] || undefined : undefined,
        v0: mode === "single" ? singleValue0 || undefined : undefined,
        v1: mode === "single" ? singleValue1 || undefined : undefined,
        v2: mode === "single" ? singleValue2 || undefined : undefined,
        ac0: mode === "compare" ? columnsA[0] || undefined : undefined,
        ac1: mode === "compare" ? columnsA[1] || undefined : undefined,
        ac2: mode === "compare" ? columnsA[2] || undefined : undefined,
        av0: mode === "compare" ? valueA0 || undefined : undefined,
        av1: mode === "compare" ? valueA1 || undefined : undefined,
        av2: mode === "compare" ? valueA2 || undefined : undefined,
        bc0: mode === "compare" ? columnsB[0] || undefined : undefined,
        bc1: mode === "compare" ? columnsB[1] || undefined : undefined,
        bc2: mode === "compare" ? columnsB[2] || undefined : undefined,
        bv0: mode === "compare" ? valueB0 || undefined : undefined,
        bv1: mode === "compare" ? valueB1 || undefined : undefined,
        bv2: mode === "compare" ? valueB2 || undefined : undefined,
      },
      replace: true,
    });
  }, [
    mode,
    selectedColumns,
    selectedValues,
    columnsA,
    valuesA,
    columnsB,
    valuesB,
    navigate,
    searchReady,
  ]);

  // Load value options for single-cohort columns
  useEffect(() => {
    if (!db) return;

    const activeColumns = selectedColumns.filter((column) => Boolean(column));
    if (activeColumns.length === 0) return;

    let cancelled = false;

    void loadValueOptions(activeColumns)
      .then((next) => {
        if (!cancelled) setValueOptionsByColumn(next);
      })
      .catch(() => {
        if (!cancelled) setValueOptionsByColumn({});
      });

    return () => {
      cancelled = true;
    };
  }, [selectedColumns, db]);

  // Load value options for cohort A columns
  useEffect(() => {
    if (!db) return;

    const activeColumns = columnsA.filter((column) => Boolean(column));
    if (activeColumns.length === 0) return;

    let cancelled = false;

    void loadValueOptions(activeColumns)
      .then((next) => {
        if (!cancelled) setValueOptionsA(next);
      })
      .catch(() => {
        if (!cancelled) setValueOptionsA({});
      });

    return () => {
      cancelled = true;
    };
  }, [columnsA, db]);

  // Load value options for cohort B columns
  useEffect(() => {
    if (!db) return;

    const activeColumns = columnsB.filter((column) => Boolean(column));
    if (activeColumns.length === 0) return;

    let cancelled = false;

    void loadValueOptions(activeColumns)
      .then((next) => {
        if (!cancelled) setValueOptionsB(next);
      })
      .catch(() => {
        if (!cancelled) setValueOptionsB({});
      });

    return () => {
      cancelled = true;
    };
  }, [columnsB, db]);

  const loadValueOptions = useCallback(
    async (activeColumns: string[]): Promise<Record<string, string[]>> => {
      if (!db) return {};

      const entries = await Promise.all(
        activeColumns.map(async (column) => {
          const quoted = quoteIdentifier(column);
          const sql = `
            SELECT cast(${quoted} AS VARCHAR) AS value, count(*)::BIGINT AS cnt
            FROM data
            WHERE ${quoted} IS NOT NULL
            GROUP BY 1
            ORDER BY cnt DESC
            LIMIT 20
          `;

          const conn = await db.connect();
          try {
            const result = await conn.query(sql);
            const values: string[] = [];
            for (let i = 0; i < result.numRows; i++) {
              values.push(String(result.getChildAt(0)?.get(i) ?? "NULL"));
            }
            return [column, values] as const;
          } finally {
            await conn.close();
          }
        }),
      );

      const next: Record<string, string[]> = {};
      for (const [column, options] of entries) {
        next[column] = options;
      }
      return next;
    },
    [db],
  );

  const availableDemographicColumns = useMemo(() => {
    if (!schema) return [];
    return schema.columns.filter(
      (c) => c.tags.includes("demographic") && c.logicalType === "categorical",
    );
  }, [schema]);

  const columnByName = useMemo(() => {
    if (!schema) return new Map<string, SchemaData["columns"][number]>();
    return new Map(schema.columns.map((column) => [column.name, column]));
  }, [schema]);

  const filterPairs = useMemo(() => {
    return selectedColumns
      .map((column) => ({ column, value: selectedValues[column] }))
      .filter((item): item is FilterPair => Boolean(item.column && item.value));
  }, [selectedColumns, selectedValues]);

  const filterPairsA = useMemo(() => {
    return columnsA
      .map((column) => ({ column, value: valuesA[column] }))
      .filter((item): item is FilterPair => Boolean(item.column && item.value));
  }, [columnsA, valuesA]);

  const filterPairsB = useMemo(() => {
    return columnsB
      .map((column) => ({ column, value: valuesB[column] }))
      .filter((item): item is FilterPair => Boolean(item.column && item.value));
  }, [columnsB, valuesB]);

  const canRun = mode === "single"
    ? filterPairs.length > 0 && !running && !!db
    : filterPairsA.length > 0 && filterPairsB.length > 0 && !running && !!db;

  const buildCondition = useCallback((pairs: FilterPair[]) => {
    return pairs
      .map((pair) => `${quoteIdentifier(pair.column)} = ${quoteLiteral(pair.value)}`)
      .join(" AND ");
  }, []);

  const runSingleCohort = useCallback(
    async (condition: string): Promise<ProfileSummary> => {
      if (!db) throw new Error("DuckDB not available");

      const conn = await db.connect();
      try {
        const runSql = async (sql: string) => {
          const result = await conn.query(sql);
          const rows: unknown[][] = [];
          for (let i = 0; i < result.numRows; i++) {
            const row: unknown[] = [];
            for (let c = 0; c < result.schema.fields.length; c++) {
              let val = result.getChildAt(c)?.get(i);
              if (typeof val === "bigint") val = Number(val);
              row.push(val ?? null);
            }
            rows.push(row);
          }
          return rows;
        };

        const sizeRows = await runSql(`
          SELECT
            count(*)::BIGINT AS total_size,
            count(*) FILTER (WHERE ${condition})::BIGINT AS cohort_size
          FROM data
        `);

        const totalSize = asNumber(sizeRows[0]?.[0]);
        const cohortSize = asNumber(sizeRows[0]?.[1]);
        const cohortSharePercent = totalSize > 0 ? (cohortSize / totalSize) * 100 : 0;
        const cohortRarity = Math.max(0, Math.min(100, 100 - cohortSharePercent));

        const metricCandidates = [
          "totalfetishcategory",
          "powerlessnessvariable",
          "opennessvariable",
          "extroversionvariable",
          "neuroticismvariable",
        ].filter((metric) => schema?.columns.some((c) => c.name === metric));

        const percentileCards = await Promise.all(
          metricCandidates.map(async (metric) => {
            const rows = await runSql(`
              WITH cohort AS (
                SELECT quantile_cont(${quoteIdentifier(metric)}, 0.5)::DOUBLE AS cohort_median
                FROM data
                WHERE ${condition} AND ${quoteIdentifier(metric)} IS NOT NULL
              )
              SELECT
                (SELECT cohort_median FROM cohort) AS cohort_median,
                CASE
                  WHEN (SELECT cohort_median FROM cohort) IS NULL THEN NULL
                  ELSE (
                    SELECT
                      100.0 *
                      SUM(CASE WHEN ${quoteIdentifier(metric)} <= (SELECT cohort_median FROM cohort) THEN 1 ELSE 0 END)::DOUBLE /
                      COUNT(*)::DOUBLE
                    FROM data
                    WHERE ${quoteIdentifier(metric)} IS NOT NULL
                  )
                END AS percentile
            `);

            return {
              metric,
              cohortMedian: rows[0]?.[0] == null ? null : Number(rows[0][0]),
              globalPercentile: rows[0]?.[1] == null ? null : Number(rows[0][1]),
            };
          }),
        );

        const candidateCategoricalColumns =
          schema?.columns
            .filter(
              (column) =>
                column.logicalType === "categorical" &&
                (column.tags.includes("demographic") || column.tags.includes("ocean")),
            )
            .slice(0, 30)
            .map((column) => column.name) ?? [];

        const overIndexingRows =
          candidateCategoricalColumns.length === 0
            ? []
            : await runSql(`
                WITH counts AS (
                  ${candidateCategoricalColumns
                    .map((columnName) => {
                      const quoted = quoteIdentifier(columnName);
                      return `
                        SELECT
                          ${quoteLiteral(columnName)} AS column_name,
                          cast(${quoted} AS VARCHAR) AS value,
                          SUM(CASE WHEN ${condition} THEN 1 ELSE 0 END)::DOUBLE AS cohort_count,
                          COUNT(*)::DOUBLE AS global_count
                        FROM data
                        WHERE ${quoted} IS NOT NULL
                        GROUP BY 1, 2
                      `;
                    })
                    .join(" UNION ALL ")}
                ),
                sizes AS (
                  SELECT
                    count(*) FILTER (WHERE ${condition})::DOUBLE AS cohort_size,
                    count(*)::DOUBLE AS global_size
                  FROM data
                ),
                scored AS (
                  SELECT
                    counts.column_name,
                    counts.value,
                    counts.cohort_count,
                    counts.global_count,
                    CASE WHEN sizes.cohort_size = 0 THEN 0 ELSE counts.cohort_count / sizes.cohort_size END AS cohort_pct,
                    CASE WHEN sizes.global_size = 0 THEN 0 ELSE counts.global_count / sizes.global_size END AS global_pct
                  FROM counts
                  CROSS JOIN sizes
                ),
                ranked AS (
                  SELECT
                    column_name,
                    value,
                    cohort_count,
                    global_count,
                    cohort_pct,
                    global_pct,
                    CASE WHEN global_pct <= 0 THEN NULL ELSE cohort_pct / global_pct END AS ratio
                  FROM scored
                )
                SELECT
                  column_name,
                  value,
                  cohort_count,
                  global_count,
                  cohort_pct,
                  global_pct,
                  ratio
                FROM ranked
                WHERE cohort_count >= 30
                  AND global_count >= 30
                  AND ratio IS NOT NULL
                ORDER BY ratio DESC, cohort_count DESC
                LIMIT 8
              `);

        const overIndexing = overIndexingRows.map((row) => ({
          columnName: String(row[0] ?? ""),
          value: String(row[1] ?? ""),
          cohortCount: asNumber(row[2]),
          globalCount: asNumber(row[3]),
          cohortPct: asNumber(row[4]) * 100,
          globalPct: asNumber(row[5]) * 100,
          ratio: asNumber(row[6]),
        }));

        return {
          totalSize,
          cohortSize,
          cohortSharePercent,
          cohortRarity,
          percentileCards,
          overIndexing,
        };
      } finally {
        await conn.close();
      }
    },
    [db, schema],
  );

  const runProfile = useCallback(async () => {
    if (mode === "single") {
      if (filterPairs.length === 0 || !db) {
        setRunError("Select at least one demographic value before running profile analysis.");
        return;
      }

      setRunning(true);
      setRunError(null);
      setComparison(null);

      try {
        const condition = buildCondition(filterPairs);
        const result = await runSingleCohort(condition);
        setSummary(result);
      } catch (error) {
        setRunError(error instanceof Error ? error.message : "Failed to run profile analysis.");
      } finally {
        setRunning(false);
      }
    } else {
      if (filterPairsA.length === 0 || filterPairsB.length === 0 || !db) {
        setRunError("Select at least one value for each group.");
        return;
      }

      setRunning(true);
      setRunError(null);
      setSummary(null);

      try {
        const conditionA = buildCondition(filterPairsA);
        const conditionB = buildCondition(filterPairsB);
        const [a, b] = await Promise.all([
          runSingleCohort(conditionA),
          runSingleCohort(conditionB),
        ]);
        setComparison({ a, b });
      } catch (error) {
        setRunError(error instanceof Error ? error.message : "Failed to run comparison analysis.");
      } finally {
        setRunning(false);
      }
    }
  }, [mode, db, filterPairs, filterPairsA, filterPairsB, buildCondition, runSingleCohort]);

  const warning = useMemo(() => {
    if (!summary) return null;
    return getWarning(summary.cohortSize);
  }, [summary]);

  const comparisonPercentileRows = useMemo((): ComparisonPercentileRow[] => {
    if (!comparison) return [];
    const { a, b } = comparison;

    const metricsSet = new Set([
      ...a.percentileCards.map((c) => c.metric),
      ...b.percentileCards.map((c) => c.metric),
    ]);

    return Array.from(metricsSet).map((metric) => {
      const cardA = a.percentileCards.find((c) => c.metric === metric);
      const cardB = b.percentileCards.find((c) => c.metric === metric);
      const medianA = cardA?.cohortMedian ?? null;
      const medianB = cardB?.cohortMedian ?? null;
      const delta = medianA != null && medianB != null ? medianB - medianA : null;
      return { metric, medianA, medianB, delta };
    });
  }, [comparison]);

  const renderFilterSlots = (
    columns: [string, string, string],
    setColumns: React.Dispatch<React.SetStateAction<[string, string, string]>>,
    values: Record<string, string>,
    setValues: React.Dispatch<React.SetStateAction<Record<string, string>>>,
    valueOptions: Record<string, string[]>,
    layout: "grid" | "stack" = "grid",
  ) => (
    <div className={layout === "stack" ? "flex flex-col gap-3" : "grid gap-4 md:grid-cols-3"}>
      {[0, 1, 2].map((slot) => {
        const column = columns[slot] ?? "";
        const options = valueOptions[column] ?? [];
        const columnMeta = availableDemographicColumns.find((item) => item.name === column);

        return (
          <div key={`slot-${slot}`} className="space-y-2 border border-[var(--rule)] bg-[var(--paper)] p-3">
            <label className="editorial-label">
              Field {slot + 1}
              <ColumnCombobox
                columns={availableDemographicColumns}
                value={column}
                includeNoneOption
                noneOptionLabel="None"
                onValueChange={(value) => {
                  const next = [...columns] as [string, string, string];
                  next[slot] = value;
                  setColumns(next);
                }}
              />
            </label>

            <label className="editorial-label">
              Value
              <Select
                value={values[column] || NONE}
                onValueChange={(value) => {
                  const resolved = value === NONE ? "" : value;
                  setValues((current) => ({
                    ...current,
                    [column]: resolved,
                  }));
                }}
                disabled={!column || options.length === 0}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select value" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={NONE}>None</SelectItem>
                  {options.map((option) => (
                    <SelectItem key={option} value={option}>
                      {formatValueWithLabel(option, columnMeta?.valueLabels)}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </label>
          </div>
        );
      })}
    </div>
  );

  const renderWarningBanner = (cohortSize: number) => {
    const w = getWarning(cohortSize);
    if (!w) return null;
    return (
      <p className={`alert ${w.kind === "critical" ? "alert--critical" : "alert--warn"}`}>
        {w.message}
      </p>
    );
  };

  const saveToNotebook = useCallback(() => {
    const activeSummary = mode === "single" ? summary : null;
    const activeComparison = mode === "compare" ? comparison : null;

    if (!activeSummary && !activeComparison) return;

    const filters = mode === "single" ? filterPairs : [...filterPairsA, ...filterPairsB];
    const filterDesc = filters.map((f) => `${f.column}=${f.value}`).join(", ");

    addNotebookEntry({
      title: `Profile: ${filterDesc}`,
      sourceUrl: window.location.href,
      queryDefinition: {
        type: "profile",
        params: {
          mode,
          ...(mode === "single" ? { filters: filterPairs } : { filtersA: filterPairsA, filtersB: filterPairsB }),
        },
      },
      resultsSnapshot: {
        summary: activeSummary
          ? {
              cohortSize: activeSummary.cohortSize,
              cohortShare: activeSummary.cohortSharePercent,
              topOverIndexing: activeSummary.overIndexing.slice(0, 5).map((o) => `${o.columnName}=${o.value} (${o.ratio.toFixed(1)}x)`),
            }
          : activeComparison
            ? {
                cohortA: activeComparison.a.cohortSize,
                cohortB: activeComparison.b.cohortSize,
              }
            : {},
      },
      notes: "",
    });

    setNotebookSaved(true);
    setTimeout(() => setNotebookSaved(false), 2000);
  }, [mode, summary, comparison, filterPairs, filterPairsA, filterPairsB]);

  const applySuggestedCohort = useCallback((filters: Array<{ column: string; value: string }>) => {
    if (!schema) return;

    const available = new Set(schema.columns.map((column) => column.name));
    const validFilters = filters.filter((filter) => available.has(filter.column)).slice(0, 3);

    const columns: [string, string, string] = ["", "", ""];
    const values: Record<string, string> = {};

    validFilters.forEach((filter, index) => {
      columns[index] = filter.column;
      values[filter.column] = filter.value;
    });

    setMode("single");
    setSummary(null);
    setComparison(null);
    setRunError(null);
    setSelectedColumns(columns);
    setSelectedValues(values);
  }, [schema]);

  const deltaDirection = (delta: number): string => {
    if (delta > 0) return "higher";
    if (delta < 0) return "lower";
    return "equal";
  };

  return (
    <div className="page">
      <header className="page-header">
        <h1 className="page-title">Build a Profile</h1>
        <p className="page-subtitle">Pick a group and see what is unusually common compared with everyone else.</p>
      </header>

      {schemaError ? <section className="alert alert--error">Failed to load schema: {schemaError}</section> : null}

      {schema ? (
        <section className="raised-panel space-y-4">
          <SectionHeader number="01" title="Choose your group" />

          {SUGGESTED_COHORTS.length > 0 ? (
            <div className="space-y-2">
              <p className="mono-label">Suggested starters</p>
              <div className="flex flex-wrap gap-2">
                {SUGGESTED_COHORTS.map((cohort) => (
                  <button
                    key={cohort.label}
                    type="button"
                    className="editorial-button"
                    onClick={() => applySuggestedCohort(cohort.filters)}
                  >
                    {cohort.label}
                  </button>
                ))}
              </div>
            </div>
          ) : null}

          <div className="flex gap-0 border border-[var(--rule)]" style={{ width: "fit-content" }}>
            <button
              type="button"
              className={`px-4 py-2 text-[0.75rem] tracking-[0.08em] uppercase font-['JetBrains_Mono',ui-monospace,monospace] border-r border-[var(--rule)] transition-colors ${
                mode === "single"
                  ? "bg-[var(--ink)] text-[var(--paper)]"
                  : "bg-[var(--paper)] text-[var(--ink)] hover:text-[var(--accent-hover)]"
              }`}
              onClick={() => {
                setMode("single");
                setComparison(null);
                setRunError(null);
              }}
            >
              One Group
            </button>
            <button
              type="button"
              className={`px-4 py-2 text-[0.75rem] tracking-[0.08em] uppercase font-['JetBrains_Mono',ui-monospace,monospace] transition-colors ${
                mode === "compare"
                  ? "bg-[var(--ink)] text-[var(--paper)]"
                  : "bg-[var(--paper)] text-[var(--ink)] hover:text-[var(--accent-hover)]"
              }`}
              onClick={() => {
                setMode("compare");
                setSummary(null);
                setRunError(null);
              }}
            >
              Compare Two Groups
            </button>
          </div>

          {mode === "single" ? (
            renderFilterSlots(
              selectedColumns,
              setSelectedColumns,
              selectedValues,
              setSelectedValues,
              valueOptionsByColumn,
            )
          ) : (
            <div className="grid gap-6 md:grid-cols-2">
              <div className="space-y-3 border border-[var(--rule)] p-4">
                <p className="mono-label" style={{ fontSize: "0.75rem", letterSpacing: "0.08em", textTransform: "uppercase" }}>
                  Group A
                </p>
                {renderFilterSlots(columnsA, setColumnsA, valuesA, setValuesA, valueOptionsA, "stack")}
              </div>
              <div className="space-y-3 border border-[var(--rule)] p-4">
                <p className="mono-label" style={{ fontSize: "0.75rem", letterSpacing: "0.08em", textTransform: "uppercase" }}>
                  Group B
                </p>
                {renderFilterSlots(columnsB, setColumnsB, valuesB, setValuesB, valueOptionsB, "stack")}
              </div>
            </div>
          )}

          <Button
            type="button"
            onClick={() => {
              void runProfile();
            }}
            disabled={!canRun}
            variant="default"
          >
            {running
              ? "Running..."
              : mode === "single"
                ? "Run Group Analysis"
                : "Compare"}
          </Button>

          {runError ? <p className="alert alert--error">{runError}</p> : null}
        </section>
      ) : (
        <section className="editorial-panel">
          <LoadingSkeleton variant="panel" phase={phase} title="Loading schema metadata..." />
        </section>
      )}

      {/* --- Single cohort results --- */}
      {summary ? (
        <section className="space-y-4">
          <div className="flex items-center justify-between">
            <SectionHeader number="02" title="Your Group Summary" />
            <button type="button" className="editorial-button" onClick={saveToNotebook}>
              {notebookSaved ? "Saved!" : "Add to Notebook"}
            </button>
          </div>

          <div className="stat-grid grid-cols-1 md:grid-cols-4">
            <StatCard label="Dataset Size" value={formatNumber(summary.totalSize)} />
            <StatCard label="Group Size" value={formatNumber(summary.cohortSize)} />
            <StatCard
              label="Group Share"
              value={formatPercent(summary.cohortSharePercent, 2)}
              note={`N = ${formatNumber(summary.cohortSize)}`}
            />
            <StatCard
              label="How Uncommon"
              value={formatPercent(summary.cohortRarity, 2)}
              note="of people are not in this group"
            />
          </div>

          {warning ? (
            <p className={`alert ${warning.kind === "critical" ? "alert--critical" : "alert--warn"}`}>
              {warning.message}
            </p>
          ) : null}

          <div className="raised-panel space-y-3">
            <SectionHeader number="03" title="How This Group Compares" />
            <DataTable
              rows={summary.percentileCards}
              rowKey={(row) => row.metric}
              columns={[
                {
                  id: "metric",
                  header: "Metric",
                  cell: (row) => {
                    const columnMeta = columnByName.get(row.metric);
                    const name = columnMeta ? getColumnDisplayName(columnMeta) : row.metric;
                    if (columnMeta) return <ColumnNameTooltip column={columnMeta}><span>{name}</span></ColumnNameTooltip>;
                    return name;
                  },
                },
                {
                  id: "cohort",
                  header: "Group Median",
                  align: "right",
                  cell: (row) => row.cohortMedian == null ? "n/a" : row.cohortMedian.toFixed(3),
                },
                {
                  id: "global",
                  header: "Ranking vs. Everyone",
                  align: "right",
                  cell: (row) => row.globalPercentile == null ? "n/a" : formatPercent(row.globalPercentile, 2),
                },
                {
                  id: "n",
                  header: "N",
                  align: "right",
                  cell: () => formatNumber(summary.cohortSize),
                },
              ]}
            />
          </div>

          <div className="raised-panel space-y-3">
            <SectionHeader number="04" title="What Makes This Group Different" />
            <DataTable
              rows={summary.overIndexing}
              rowKey={(row, index) => `${row.columnName}-${row.value}-${index}`}
              columns={[
                {
                  id: "column",
                  header: "Column",
                  cell: (row) => {
                    const columnMeta = columnByName.get(row.columnName);
                    const name = columnMeta ? getColumnDisplayName(columnMeta) : row.columnName;
                    if (columnMeta) return <ColumnNameTooltip column={columnMeta}><span>{name}</span></ColumnNameTooltip>;
                    return name;
                  },
                },
                {
                  id: "value",
                  header: "Value",
                  cell: (row) => {
                    const columnMeta = columnByName.get(row.columnName);
                    return formatValueWithLabel(row.value, columnMeta?.valueLabels);
                  },
                },
                {
                  id: "ratio",
                  header: "Times more likely",
                  align: "right",
                  cell: (row) => `${row.ratio.toFixed(2)}x`,
                },
                {
                  id: "cohort",
                  header: "Group % (N)",
                  align: "right",
                  cell: (row) =>
                    `${formatPercent(row.cohortPct, 2)} (N=${formatNumber(row.cohortCount)})`,
                },
                {
                  id: "global",
                  header: "Global % (N)",
                  align: "right",
                  cell: (row) =>
                    `${formatPercent(row.globalPct, 2)} (N=${formatNumber(row.globalCount)})`,
                },
              ]}
              emptyMessage="No distinctive traits found - need at least 30 people in a category to show results"
            />
          </div>
        </section>
      ) : null}

      {/* --- Comparison results --- */}
      {comparison ? (
        <section className="space-y-4">
          <div className="flex items-center justify-between">
            <SectionHeader number="02" title="Group Comparison" />
            <button type="button" className="editorial-button" onClick={saveToNotebook}>
              {notebookSaved ? "Saved!" : "Add to Notebook"}
            </button>
          </div>

          {/* Side-by-side cohort Ns */}
          <div className="grid gap-4 md:grid-cols-2">
            <div className="space-y-2">
              <p className="mono-label" style={{ fontSize: "0.75rem", letterSpacing: "0.08em", textTransform: "uppercase" }}>
                Group A
              </p>
              <div className="stat-grid grid-cols-1 md:grid-cols-3">
                <StatCard label="Dataset Size" value={formatNumber(comparison.a.totalSize)} />
                <StatCard label="Group Size" value={formatNumber(comparison.a.cohortSize)} />
                <StatCard
                  label="Group Share"
                  value={formatPercent(comparison.a.cohortSharePercent, 2)}
                  note={`N = ${formatNumber(comparison.a.cohortSize)}`}
                />
              </div>
              {renderWarningBanner(comparison.a.cohortSize)}
            </div>
            <div className="space-y-2">
              <p className="mono-label" style={{ fontSize: "0.75rem", letterSpacing: "0.08em", textTransform: "uppercase" }}>
                Group B
              </p>
              <div className="stat-grid grid-cols-1 md:grid-cols-3">
                <StatCard label="Dataset Size" value={formatNumber(comparison.b.totalSize)} />
                <StatCard label="Group Size" value={formatNumber(comparison.b.cohortSize)} />
                <StatCard
                  label="Group Share"
                  value={formatPercent(comparison.b.cohortSharePercent, 2)}
                  note={`N = ${formatNumber(comparison.b.cohortSize)}`}
                />
              </div>
              {renderWarningBanner(comparison.b.cohortSize)}
            </div>
          </div>

          {/* Percentile comparison with deltas */}
          <div className="raised-panel space-y-3">
            <SectionHeader number="03" title="Median Comparison" />
            {comparison.a.cohortSize < 30 || comparison.b.cohortSize < 30 ? (
              <p className="alert alert--critical">
                One or both groups have fewer than 30 people.
              </p>
            ) : null}
            <DataTable
              rows={comparisonPercentileRows}
              rowKey={(row) => row.metric}
              columns={[
                {
                  id: "metric",
                  header: "Metric",
                  cell: (row) => {
                    const columnMeta = columnByName.get(row.metric);
                    const name = columnMeta ? getColumnDisplayName(columnMeta) : row.metric;
                    if (columnMeta) return <ColumnNameTooltip column={columnMeta}><span>{name}</span></ColumnNameTooltip>;
                    return name;
                  },
                },
                {
                  id: "medianA",
                  header: "Group A Median",
                  align: "right",
                  cell: (row) => row.medianA == null ? "n/a" : row.medianA.toFixed(3),
                },
                {
                  id: "medianB",
                  header: "Group B Median",
                  align: "right",
                  cell: (row) => row.medianB == null ? "n/a" : row.medianB.toFixed(3),
                },
                {
                  id: "delta",
                  header: "Difference",
                  align: "right",
                  cell: (row) => {
                    if (comparison.a.cohortSize < 30 || comparison.b.cohortSize < 30) {
                      return "n/a (fewer than 30 people)";
                    }
                    if (row.delta == null) return "n/a";
                    const sign = row.delta > 0 ? "+" : "";
                    return `${sign}${row.delta.toFixed(3)} (${deltaDirection(row.delta)})`;
                  },
                },
                {
                  id: "nA",
                  header: "N (A)",
                  align: "right",
                  cell: () => formatNumber(comparison.a.cohortSize),
                },
                {
                  id: "nB",
                  header: "N (B)",
                  align: "right",
                  cell: () => formatNumber(comparison.b.cohortSize),
                },
              ]}
            />
          </div>

          {/* Over-indexing side by side */}
          <div className="grid gap-4 md:grid-cols-2">
            <div className="raised-panel space-y-3">
              <SectionHeader number="04a" title="What Makes Group A Different" />
              <DataTable
                rows={comparison.a.overIndexing}
                rowKey={(row, index) => `a-${row.columnName}-${row.value}-${index}`}
                columns={[
                  {
                    id: "column",
                    header: "Column",
                    cell: (row) => {
                      const columnMeta = columnByName.get(row.columnName);
                      const name = columnMeta ? getColumnDisplayName(columnMeta) : row.columnName;
                      if (columnMeta) return <ColumnNameTooltip column={columnMeta}><span>{name}</span></ColumnNameTooltip>;
                    return name;
                    },
                  },
                  {
                    id: "value",
                    header: "Value",
                    cell: (row) => {
                      const columnMeta = columnByName.get(row.columnName);
                      return formatValueWithLabel(row.value, columnMeta?.valueLabels);
                    },
                  },
                  {
                    id: "ratio",
                    header: "Times more likely",
                    align: "right",
                    cell: (row) => `${row.ratio.toFixed(2)}x`,
                  },
                  {
                    id: "cohort",
                    header: "Group % (N)",
                    align: "right",
                    cell: (row) =>
                      `${formatPercent(row.cohortPct, 2)} (N=${formatNumber(row.cohortCount)})`,
                  },
                ]}
                emptyMessage="No distinctive traits found - need at least 30 people in a category to show results"
              />
            </div>
            <div className="raised-panel space-y-3">
              <SectionHeader number="04b" title="What Makes Group B Different" />
              <DataTable
                rows={comparison.b.overIndexing}
                rowKey={(row, index) => `b-${row.columnName}-${row.value}-${index}`}
                columns={[
                  {
                    id: "column",
                    header: "Column",
                    cell: (row) => {
                      const columnMeta = columnByName.get(row.columnName);
                      const name = columnMeta ? getColumnDisplayName(columnMeta) : row.columnName;
                      if (columnMeta) return <ColumnNameTooltip column={columnMeta}><span>{name}</span></ColumnNameTooltip>;
                    return name;
                    },
                  },
                  {
                    id: "value",
                    header: "Value",
                    cell: (row) => {
                      const columnMeta = columnByName.get(row.columnName);
                      return formatValueWithLabel(row.value, columnMeta?.valueLabels);
                    },
                  },
                  {
                    id: "ratio",
                    header: "Times more likely",
                    align: "right",
                    cell: (row) => `${row.ratio.toFixed(2)}x`,
                  },
                  {
                    id: "cohort",
                    header: "Group % (N)",
                    align: "right",
                    cell: (row) =>
                      `${formatPercent(row.cohortPct, 2)} (N=${formatNumber(row.cohortCount)})`,
                  },
                ]}
                emptyMessage="No distinctive traits found - need at least 30 people in a category to show results"
              />
            </div>
          </div>
        </section>
      ) : null}
    </div>
  );
}

```

File: /Users/austin/dev/kink/src/routes/relationships.tsx
(lines 1-238)
```tsx
import { createFileRoute, Link, useNavigate } from "@tanstack/react-router";
import { useEffect, useMemo, useState } from "react";

import { ColumnCombobox } from "@/components/column-combobox";
import { SectionHeader } from "@/components/section-header";
import { DEFAULTS_BY_PAGE } from "@/lib/chart-presets";
import { ColumnNameTooltip } from "@/components/column-name-tooltip";
import { getColumnDisplayName } from "@/lib/format-labels";
import { formatNumber } from "@/lib/format";
import schemaMetadata from "@/lib/schema/columns.generated.json";
import relationshipData from "@/lib/schema/relationships.generated.json";

export const Route = createFileRoute("/relationships")({
  validateSearch: (search): { column?: string } => ({
    column: typeof search.column === "string" ? search.column : undefined,
  }),
  component: RelationshipsPage,
});

type Relationship = {
  column: string;
  metric: string;
  value: number;
  n: number;
};

type RelationshipData = {
  generatedAt: string;
  columnCount: number;
  pairCount: number;
  relationships: Record<string, Relationship[]>;
};

const data = relationshipData as RelationshipData;
const schemaColumns = (schemaMetadata as { columns: Array<{ name: string; displayName?: string }> }).columns;
const schemaByName = new Map(schemaColumns.map((column) => [column.name, column]));

const columnNames = Object.keys(data.relationships).sort((a, b) =>
  a.localeCompare(b)
);

function strengthLabel(value: number): string {
  if (value < 0.1) return "very weak";
  if (value < 0.3) return "weak";
  if (value < 0.5) return "moderate";
  return "strong";
}

function metricLabel(metric: string): string {
  if (metric === "cramers_v") return "Connection score";
  if (metric === "correlation") return "Correlation score";
  return metric;
}

function RelationshipsPage() {
  const search = Route.useSearch();
  const navigate = useNavigate({ from: "/relationships" });
  const defaultColumn = DEFAULTS_BY_PAGE.relationships?.column;
  const [selectedColumn, setSelectedColumn] = useState(
    search.column && columnNames.includes(search.column) ? search.column : columnNames[0] ?? "",
  );

  useEffect(() => {
    if (search.column) return;
    if (!defaultColumn || !columnNames.includes(defaultColumn)) return;
    setSelectedColumn(defaultColumn);
  }, [search.column, defaultColumn]);

  useEffect(() => {
    void navigate({
      search: { column: selectedColumn || undefined },
      replace: true,
    });
  }, [selectedColumn, navigate]);

  const columnOptions = useMemo(
    () =>
      columnNames.map((name) => {
        const column = schemaByName.get(name);
        return {
          name,
          displayName: column ? getColumnDisplayName(column) : name,
        };
      }),
    [],
  );

  const relationships = useMemo(() => {
    if (!selectedColumn) return [];
    return data.relationships[selectedColumn] ?? [];
  }, [selectedColumn]);

  const maxValue = useMemo(() => {
    if (relationships.length === 0) return 1;
    return Math.max(...relationships.map((r) => r.value));
  }, [relationships]);

  const selectedColumnDisplayName = useMemo(() => {
    const column = schemaByName.get(selectedColumn);
    return column ? getColumnDisplayName(column) : selectedColumn;
  }, [selectedColumn]);

  return (
    <div className="page">
      <header className="page-header">
        <h1 className="page-title">What's Connected?</h1>
        <p className="page-subtitle">
          See which questions tend to move together. Higher scores mean stronger relationships in this dataset.
        </p>
        <p className="dateline">
          {formatNumber(data.columnCount)} questions &middot;{" "}
          {formatNumber(data.pairCount)} connections
        </p>
      </header>

      <section className="raised-panel space-y-4">
        <SectionHeader number="01" title="Question to start from" />

        <label className="editorial-label">
          Select a question to see its strongest connections
          <ColumnCombobox
            columns={columnOptions}
            value={selectedColumn}
            onValueChange={setSelectedColumn}
            placeholder="Choose a question"
          />
        </label>
      </section>

      <section className="editorial-panel space-y-4">
        <SectionHeader
          number="02"
          title="Top related questions"
          subtitle={
            relationships.length > 0
              ? `${relationships.length} connections for "${selectedColumnDisplayName}"`
              : "No connections found for this question"
          }
        />
        <p className="section-subtitle">
          Scores range from 0 (no connection) to 1 (perfect connection).
        </p>

        {relationships.length > 0 ? (
          <div className="editorial-table-wrap">
            <table className="editorial-table">
              <thead>
                <tr>
                  <th>Related Question</th>
                  <th>Metric</th>
                  <th className="numeric">Score</th>
                  <th>Label</th>
                  <th className="numeric">People</th>
                  <th style={{ width: "120px" }}>Strength</th>
                </tr>
              </thead>
              <tbody>
                {relationships.map((rel) => {
                  const label = strengthLabel(rel.value);
                  const barWidth =
                    maxValue > 0 ? (rel.value / maxValue) * 100 : 0;

                  return (
                    <tr key={rel.column}>
                      <td>
                        <ColumnNameTooltip column={schemaByName.get(rel.column) ?? { name: rel.column }}>
                          <Link
                            to="/explore/crosstab"
                            search={{ x: selectedColumn, y: rel.column }}
                            className="mono-value"
                            style={{
                              color: "var(--accent)",
                              borderBottom: "1px solid var(--rule-light)",
                            }}
                          >
                            {getColumnDisplayName(schemaByName.get(rel.column) ?? { name: rel.column })}
                          </Link>
                        </ColumnNameTooltip>
                      </td>
                      <td>
                        <span className="null-badge">
                          {metricLabel(rel.metric)}
                        </span>
                      </td>
                      <td className="numeric">
                        <span className="mono-value">
                          {rel.value.toFixed(2)}
                        </span>
                      </td>
                      <td>
                        <span
                          className="null-badge"
                          style={
                            label === "strong"
                              ? {
                                  borderColor: "var(--accent)",
                                  color: "var(--accent)",
                                }
                              : label === "moderate"
                                ? {
                                    borderColor: "#8f5a2b",
                                    color: "#8f5a2b",
                                  }
                                : undefined
                          }
                        >
                          {label}
                        </span>
                      </td>
                      <td className="numeric">
                        <span className="mono-value">
                          {formatNumber(rel.n)}
                        </span>
                      </td>
                      <td>
                        <div className="inline-ratio">
                          <span
                            style={{
                              width: `${barWidth}%`,
                            }}
                          />
                        </div>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        ) : (
          <p className="section-subtitle">
            Select a question above to view its connections.
          </p>
        )}
      </section>
    </div>
  );
}

```

File: /Users/austin/dev/kink/src/styles.css
(lines 1-788)
```css
@import url("https://fonts.googleapis.com/css2?family=Fraunces:ital,opsz,wght@0,9..144,300;0,9..144,400;0,9..144,600;0,9..144,700;1,9..144,400&family=Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;1,8..60,400&family=JetBrains+Mono:wght@400;500&display=swap");
@import "tailwindcss";

:root {
  --paper: #f5f0e8;
  --paper-warm: #ede6d8;
  --ink: #1a1612;
  --ink-light: #4a4238;
  --ink-faded: #8a7e70;
  --rule: #c8bfb0;
  --rule-light: #ddd5c8;
  --accent: #b8432f;
  --accent-hover: #9a3625;
  --highlight: #e8d5a0;
  --sidebar-bg: #eae3d5;
}

* {
  box-sizing: border-box;
}

html,
body {
  min-height: 100%;
}

body {
  margin: 0;
  background: var(--paper);
  color: var(--ink);
  font-family: "Source Serif 4", Georgia, serif;
  font-size: 16px;
  line-height: 1.6;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 999;
  opacity: 0.03;
  background: url("data:image/svg+xml,%3Csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.75' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
}

@layer base {
  a {
    color: inherit;
    text-decoration: none;
  }
}

.app-shell {
  min-height: 100vh;
  background: var(--paper);
  color: var(--ink);
}

.app-nav {
  border-bottom: 2px solid var(--ink);
  padding: 0 2rem;
}

.nav-inner {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  align-items: baseline;
  gap: 2rem;
  padding: 1rem 0 0.75rem;
}

.brand-link {
  display: inline-flex;
  align-items: baseline;
  gap: 0.5rem;
}

.brand-title {
  font-family: "Fraunces", Georgia, serif;
  font-size: 1.5rem;
  font-weight: 700;
  letter-spacing: -0.02em;
  line-height: 1.1;
}

.brand-subtitle {
  font-family: "Source Serif 4", Georgia, serif;
  font-size: 0.9rem;
  font-style: italic;
  color: var(--ink-faded);
}

.nav-links {
  margin-left: auto;
  display: flex;
  align-items: center;
}

.nav-toggle {
  display: none;
  margin-left: auto;
  border: 1px solid var(--ink);
  background: var(--paper);
  color: var(--ink);
  padding: 0.35rem 0.7rem;
  font-family: "JetBrains Mono", ui-monospace, monospace;
  font-size: 0.72rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
}

.nav-toggle:hover {
  color: var(--accent-hover);
  border-color: var(--accent-hover);
}

.nav-links-mobile {
  display: none;
}

.nav-link {
  margin-bottom: -2px;
  border-bottom: 2px solid transparent;
  padding: 0.45rem 1.25rem 0.65rem;
  font-family: "Source Serif 4", Georgia, serif;
  font-size: 0.85rem;
  font-weight: 400;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--ink-faded);
  transition: color 0.2s ease;
}

.nav-link:focus-visible,
.nav-toggle:focus-visible,
.nav-dropdown-item:focus-visible,
.nav-link--mobile-group:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

.nav-link:hover {
  color: var(--ink);
}

.nav-link-active {
  border-bottom-color: var(--accent);
  color: var(--accent);
  font-weight: 600;
}

.nav-link--featured {
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  color: var(--accent);
  font-weight: 600;
}

.nav-feature-glyph {
  font-size: 0.72rem;
  line-height: 1;
}

.nav-feature-caret {
  font-size: 0.62rem;
  line-height: 1;
  transform: translateY(-1px);
}

.nav-dropdown {
  position: relative;
  display: flex;
  align-items: stretch;
}

.nav-dropdown-menu {
  position: absolute;
  top: calc(100% + 2px);
  left: 0;
  z-index: 40;
  display: none;
  min-width: 22rem;
  border: 1px solid var(--rule);
  border-top: 3px solid var(--accent);
  background: var(--paper);
}

.nav-dropdown:hover .nav-dropdown-menu,
.nav-dropdown:focus-within .nav-dropdown-menu {
  display: block;
}

.nav-dropdown-item {
  display: block;
  border-bottom: 1px solid var(--rule-light);
  padding: 0.72rem 0.95rem 0.78rem;
}

.nav-dropdown-item:last-child {
  border-bottom: 0;
}

.nav-dropdown-item:hover {
  background: var(--paper-warm);
}

.nav-dropdown-item-label {
  display: block;
  font-family: "JetBrains Mono", ui-monospace, monospace;
  font-size: 0.7rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--ink);
}

.nav-dropdown-item-description {
  display: block;
  margin-top: 0.2rem;
  color: var(--ink-light);
  font-size: 0.83rem;
  letter-spacing: 0;
  line-height: 1.45;
  text-transform: none;
}

.app-main {
  max-width: 1200px;
  margin: 0 auto;
  padding: 3rem 2rem 4rem;
}

.page {
  display: flex;
  flex-direction: column;
  gap: 3rem;
  animation: fade-up 0.6s ease-out;
}

.page-header {
  border-bottom: 1px solid var(--rule);
  padding-bottom: 1.5rem;
}

.page-title {
  margin: 0;
  font-family: "Fraunces", Georgia, serif;
  font-size: 2.75rem;
  line-height: 1.1;
  letter-spacing: -0.03em;
  font-weight: 700;
}

.page-subtitle {
  margin: 0.6rem 0 0;
  font-style: italic;
  font-size: 1.05rem;
  color: var(--ink-faded);
}

.dateline {
  margin-top: 0.75rem;
  font-family: "JetBrains Mono", ui-monospace, monospace;
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--ink-faded);
}

.section-header {
  margin: 0;
  display: flex;
  align-items: baseline;
  gap: 0.75rem;
  border-bottom: 1px solid var(--rule);
  padding-bottom: 0.45rem;
  font-family: "Fraunces", Georgia, serif;
  font-size: 1.2rem;
  font-weight: 600;
  line-height: 1.25;
}

.section-number {
  font-family: "JetBrains Mono", ui-monospace, monospace;
  font-size: 0.65rem;
  font-weight: 500;
  color: var(--accent);
  letter-spacing: 0.06em;
  text-transform: uppercase;
}

.section-subtitle {
  margin-top: 0.35rem;
  color: var(--ink-light);
  font-size: 0.92rem;
}

.editorial-panel {
  border: 1px solid var(--rule);
  background: var(--paper);
  padding: 1.4rem 1.5rem;
}

.raised-panel {
  border: 1px solid var(--rule);
  background: var(--sidebar-bg);
  padding: 1.4rem 1.5rem;
  position: relative;
}

.raised-panel::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  border-top: 3px solid var(--accent);
}

.stat-grid {
  display: grid;
  gap: 0;
  border: 1px solid var(--ink);
}

.stat-cell {
  border-right: 1px solid var(--rule);
  border-bottom: 1px solid var(--rule);
  padding: 1.2rem 1.5rem;
}

.stat-cell:last-child {
  border-right: 0;
}

.stat-cell-label {
  display: block;
  font-family: "JetBrains Mono", ui-monospace, monospace;
  font-size: 0.65rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--ink-faded);
}

.stat-cell-value {
  display: block;
  margin-top: 0.35rem;
  font-family: "Fraunces", Georgia, serif;
  font-size: 2.5rem;
  line-height: 1;
  letter-spacing: -0.03em;
  font-weight: 700;
}

.stat-cell-note {
  margin-top: 0.3rem;
  font-size: 0.8rem;
  color: var(--ink-faded);
  font-style: italic;
}

.mono-label {
  font-family: "JetBrains Mono", ui-monospace, monospace;
  font-size: 0.68rem;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--ink-faded);
}

.mono-value {
  font-family: "JetBrains Mono", ui-monospace, monospace;
  font-size: 0.82rem;
  line-height: 1.4;
}

.editorial-control {
  width: 100%;
  border: 1px solid var(--rule);
  background: var(--paper);
  padding: 0.5rem 0.65rem;
  font-family: "JetBrains Mono", ui-monospace, monospace;
  font-size: 0.8rem;
  line-height: 1.4;
  color: var(--ink);
}

.editorial-control:focus {
  outline: none;
  border-color: var(--ink);
}

.editorial-label {
  display: grid;
  gap: 0.35rem;
  font-family: "JetBrains Mono", ui-monospace, monospace;
  font-size: 0.65rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--ink-faded);
}

.editorial-button {
  border: 1px solid var(--ink);
  background: var(--paper);
  color: var(--ink);
  padding: 0.5rem 0.95rem;
  font-family: "JetBrains Mono", ui-monospace, monospace;
  font-size: 0.75rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  cursor: pointer;
}

.editorial-button:hover:not(:disabled) {
  color: var(--accent-hover);
  border-color: var(--accent-hover);
}

.editorial-button:disabled {
  cursor: not-allowed;
  opacity: 0.55;
}

.editorial-button--accent {
  border-color: var(--accent);
  color: var(--accent);
}

.editorial-button--filled {
  background: var(--ink);
  color: var(--paper);
}

.editorial-button--filled:hover:not(:disabled) {
  color: var(--paper);
  background: var(--accent-hover);
  border-color: var(--accent-hover);
}

.editorial-table-wrap {
  overflow-x: auto;
}

.editorial-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
}

.editorial-table thead th {
  text-align: left;
  padding: 0.5rem 0.25rem;
  border-bottom: 2px solid var(--ink);
  font-family: "JetBrains Mono", ui-monospace, monospace;
  font-size: 0.65rem;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--ink-faded);
  font-weight: 500;
}

.editorial-table tbody td {
  padding: 0.56rem 0.25rem;
  border-bottom: 1px solid var(--rule-light);
  vertical-align: top;
}

.editorial-table tbody tr:last-child td {
  border-bottom: 0;
}

.editorial-table tbody td:first-child {
  font-family: "JetBrains Mono", ui-monospace, monospace;
  color: var(--ink);
}

.editorial-table .numeric,
.editorial-table thead .numeric {
  text-align: right;
  font-family: "JetBrains Mono", ui-monospace, monospace;
}

.caveat-item {
  border-bottom: 1px solid var(--rule-light);
  padding: 0.85rem 0;
}

.caveat-item:last-child {
  border-bottom: 0;
}

.caveat-title {
  font-weight: 600;
  font-size: 0.95rem;
}

.caveat-description {
  margin-top: 0.2rem;
  color: var(--ink-light);
  font-size: 0.85rem;
}

.caveat-guidance {
  margin-top: 0.3rem;
  color: var(--ink-faded);
  font-size: 0.76rem;
  font-style: italic;
}

.sample-size {
  display: flex;
  flex-wrap: wrap;
  gap: 0.6rem 1.2rem;
  margin-top: 0.6rem;
  color: var(--ink-faded);
}

.sample-size-item {
  font-family: "JetBrains Mono", ui-monospace, monospace;
  font-size: 0.7rem;
  letter-spacing: 0.05em;
  text-transform: uppercase;
}

.null-badge {
  display: inline-block;
  border: 1px solid var(--rule);
  padding: 0.12rem 0.4rem;
  font-family: "JetBrains Mono", ui-monospace, monospace;
  font-size: 0.62rem;
  letter-spacing: 0.07em;
  text-transform: uppercase;
  color: var(--ink-faded);
  background: var(--paper);
}

.null-badge--gated {
  border-color: var(--accent);
  color: var(--accent);
}

.null-badge--late_added {
  border-color: #8f5a2b;
  color: #8f5a2b;
}

.null-badge--not_applicable {
  border-color: #6b6259;
  color: #6b6259;
}

.inline-ratio {
  position: relative;
  height: 4px;
  background: var(--rule-light);
  margin-top: 0.3rem;
}

.inline-ratio > span {
  display: block;
  height: 100%;
  background: color-mix(in srgb, var(--accent) 70%, transparent);
}

.alert {
  border: 1px solid var(--ink);
  padding: 0.75rem 0.9rem;
  font-size: 0.85rem;
}

.alert--error {
  border-color: #8b1a1a;
  color: #8b1a1a;
  background: #f0ded8;
}

.alert--warn {
  border-color: #8a5b10;
  color: #6d490f;
  background: #efe0be;
}

.alert--critical {
  border-color: #7e1f1f;
  color: #7e1f1f;
  background: #ecd3d3;
}

/* Feedback dialog */
.feedback-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  background: rgba(26, 22, 18, 0.4);
}

.feedback-content {
  position: fixed;
  top: 50%;
  left: 50%;
  z-index: 51;
  transform: translate(-50%, -50%);
  width: 90vw;
  max-width: 480px;
  max-height: 85vh;
  overflow-y: auto;
  border: 2px solid var(--ink);
  background: var(--paper);
  padding: 2rem;
}

.feedback-title {
  margin: 0;
  font-family: "Fraunces", Georgia, serif;
  font-size: 1.5rem;
  font-weight: 700;
  letter-spacing: -0.02em;
  line-height: 1.1;
}

.feedback-description {
  margin: 0.5rem 0 1.5rem;
  color: var(--ink-faded);
  font-size: 0.9rem;
  font-style: italic;
}

.feedback-form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.feedback-textarea {
  resize: vertical;
  min-height: 100px;
}

.feedback-actions {
  display: flex;
  justify-content: flex-end;
  gap: 0.75rem;
  margin-top: 0.5rem;
}

.feedback-error {
  margin: 0;
  color: #8b1a1a;
  font-size: 0.82rem;
}

.feedback-sent {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  padding: 1.5rem 0;
}

.feedback-sent-message {
  margin: 0;
  font-family: "Source Serif 4", Georgia, serif;
  font-size: 1.05rem;
  font-style: italic;
  color: var(--ink-light);
}

@keyframes fade-up {
  from {
    opacity: 0;
    transform: translateY(12px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@media (max-width: 900px) {
  .app-nav {
    padding: 0 1rem;
  }

  .nav-inner {
    flex-wrap: nowrap;
    gap: 0.85rem;
    padding-bottom: 0.55rem;
    align-items: center;
  }

  .brand-link {
    min-width: 0;
  }

  .brand-title {
    font-size: 1.2rem;
  }

  .brand-subtitle {
    display: none;
  }

  .nav-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  .nav-links--desktop {
    display: none;
  }

  .nav-links-mobile {
    display: none;
    border-top: 1px solid var(--rule);
    padding: 0.5rem 0 0.75rem;
  }

  .nav-links-mobile--open {
    display: flex;
    flex-direction: column;
    gap: 0;
  }

  .nav-link--mobile {
    display: flex;
    align-items: center;
    margin-bottom: 0;
    border-bottom: 1px solid var(--rule-light);
    padding: 0.6rem 0.2rem;
    font-size: 0.72rem;
    min-height: 44px;
    white-space: normal;
  }

  .nav-link--mobile-group {
    width: 100%;
    justify-content: space-between;
    background: var(--paper);
    cursor: pointer;
    text-align: left;
  }

  .nav-mobile-group-label {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
  }

  .nav-mobile-group-icon {
    font-family: "JetBrains Mono", ui-monospace, monospace;
    font-size: 0.86rem;
    color: var(--ink-light);
  }

  .nav-mobile-subitems {
    display: none;
    margin: 0 0 0.25rem 0.7rem;
    border-left: 1px solid var(--rule);
    padding-left: 0.7rem;
  }

  .nav-mobile-subitems--open {
    display: flex;
    flex-direction: column;
  }

  .nav-link--mobile-sub {
    font-size: 0.69rem;
    padding-left: 0.4rem;
  }

  .app-main {
    padding: 2rem 1rem 3rem;
  }

  .page-title {
    font-size: 2.1rem;
  }

  .stat-cell-value {
    font-size: 1.75rem;
  }
}

```

File: /Users/austin/dev/kink/src/components/charts/bar-chart.tsx
(lines 1-74)
```tsx
import {
  Bar,
  BarChart as RechartsBarChart,
  CartesianGrid,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
} from "recharts";

import { AXIS_STYLE, CHART_COLORS, GRID_STYLE, TOOLTIP_STYLE } from "./chart-config";

interface BarChartProps {
  /** Data with `name` (x-axis label) and `value` (bar height) */
  data: Array<{ name: string; value: number }>;
  xLabel?: string;
  yLabel?: string;
  color?: string;
  height?: number;
}

export function SimpleBarChart({
  data,
  xLabel,
  yLabel,
  color = CHART_COLORS.accent,
  height = 360,
}: BarChartProps) {
  return (
    <ResponsiveContainer width="100%" height={height}>
      <RechartsBarChart
        data={data}
        margin={{ top: 8, right: 12, bottom: xLabel ? 32 : 8, left: yLabel ? 48 : 8 }}
      >
        <CartesianGrid vertical={false} {...GRID_STYLE} />
        <XAxis
          dataKey="name"
          {...AXIS_STYLE}
          label={
            xLabel
              ? {
                  value: xLabel,
                  position: "insideBottom",
                  offset: -20,
                  style: { ...AXIS_STYLE.tick, fontSize: 10 },
                }
              : undefined
          }
        />
        <YAxis
          {...AXIS_STYLE}
          label={
            yLabel
              ? {
                  value: yLabel,
                  angle: -90,
                  position: "insideLeft",
                  offset: -32,
                  style: { ...AXIS_STYLE.tick, fontSize: 10, textAnchor: "middle" },
                }
              : undefined
          }
        />
        <Tooltip
          contentStyle={TOOLTIP_STYLE.contentStyle}
          labelStyle={TOOLTIP_STYLE.labelStyle}
          itemStyle={TOOLTIP_STYLE.itemStyle}
          cursor={{ fill: CHART_COLORS.ruleLight }}
        />
        <Bar dataKey="value" name={yLabel ?? "Value"} fill={color} radius={0} maxBarSize={64} />
      </RechartsBarChart>
    </ResponsiveContainer>
  );
}

```

File: /Users/austin/dev/kink/src/components/charts/grouped-bar-chart.tsx
(lines 1-98)
```tsx
import {
  Bar,
  BarChart as RechartsBarChart,
  CartesianGrid,
  Legend,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
} from "recharts";

import { AXIS_STYLE, CHART_COLORS, CHART_FONT, GRID_STYLE, SERIES_COLORS, TOOLTIP_STYLE } from "./chart-config";

interface SeriesConfig {
  key: string;
  label: string;
  color: string;
}

interface GroupedBarChartProps {
  /** Data rows. Each row must have a `group_key` field plus numeric fields for each series. */
  data: Array<Record<string, unknown>>;
  /** Series definitions: which keys to render as bars, their labels and colors. */
  series: SeriesConfig[];
  xLabel?: string;
  yLabel?: string;
  height?: number;
}

export function GroupedBarChart({
  data,
  series,
  xLabel,
  yLabel,
  height = 360,
}: GroupedBarChartProps) {
  const resolvedSeries = series.map((s, i) => ({
    ...s,
    color: s.color || SERIES_COLORS[i % SERIES_COLORS.length],
  }));

  return (
    <ResponsiveContainer width="100%" height={height}>
      <RechartsBarChart
        data={data}
        margin={{ top: 8, right: 12, bottom: xLabel ? 52 : 24, left: yLabel ? 48 : 8 }}
      >
        <CartesianGrid vertical={false} {...GRID_STYLE} />
        <XAxis
          dataKey="group_key"
          {...AXIS_STYLE}
          label={
            xLabel
              ? {
                  value: xLabel,
                  position: "insideBottom",
                  offset: -4,
                  style: { ...AXIS_STYLE.tick, fontSize: 10 },
                }
              : undefined
          }
        />
        <YAxis
          {...AXIS_STYLE}
          label={
            yLabel
              ? {
                  value: yLabel,
                  angle: -90,
                  position: "insideLeft",
                  offset: -32,
                  style: { ...AXIS_STYLE.tick, fontSize: 10, textAnchor: "middle" },
                }
              : undefined
          }
        />
        <Tooltip
          contentStyle={TOOLTIP_STYLE.contentStyle}
          labelStyle={TOOLTIP_STYLE.labelStyle}
          itemStyle={TOOLTIP_STYLE.itemStyle}
          cursor={{ fill: CHART_COLORS.ruleLight }}
        />
        <Legend
          iconType="square"
          wrapperStyle={{
            fontFamily: CHART_FONT.body,
            fontSize: 12,
            paddingTop: 8,
            lineHeight: "1.2",
          }}
        />
        {resolvedSeries.map((s) => (
          <Bar key={s.key} dataKey={s.key} name={s.label} fill={s.color} radius={0} maxBarSize={48} />
        ))}
      </RechartsBarChart>
    </ResponsiveContainer>
  );
}

```

File: /Users/austin/dev/kink/src/components/charts/chart-config.ts
(lines 1-73)
```ts
/** Ink & Paper chart styling tokens */
export const CHART_COLORS = {
  ink: "#1a1612",
  inkLight: "#4a4238",
  inkFaded: "#8a7e70",
  paper: "#f5f0e8",
  paperWarm: "#ede6d8",
  accent: "#b8432f",
  accentHover: "#9a3625",
  rule: "#c8bfb0",
  ruleLight: "#ddd5c8",
  highlight: "#e8d5a0",
} as const;

export const CHART_FONT = {
  display: "'Fraunces', Georgia, serif",
  body: "'Source Serif 4', Georgia, serif",
  mono: "'JetBrains Mono', ui-monospace, monospace",
} as const;

/** Common Recharts style props */
export const AXIS_STYLE = {
  tick: {
    fontFamily: CHART_FONT.mono,
    fontSize: 11,
    fill: CHART_COLORS.inkLight,
  },
  axisLine: {
    stroke: CHART_COLORS.ink,
    strokeWidth: 1,
  },
  tickLine: {
    stroke: CHART_COLORS.rule,
  },
} as const;

export const GRID_STYLE = {
  stroke: CHART_COLORS.ruleLight,
  strokeDasharray: "3 3",
} as const;

export const TOOLTIP_STYLE = {
  contentStyle: {
    background: CHART_COLORS.paper,
    border: `1px solid ${CHART_COLORS.ink}`,
    borderRadius: 0,
    fontFamily: CHART_FONT.mono,
    fontSize: 12,
    padding: "8px 12px",
  },
  labelStyle: {
    fontFamily: CHART_FONT.mono,
    fontSize: 11,
    fontWeight: 600,
    color: CHART_COLORS.ink,
    marginBottom: 4,
  },
  itemStyle: {
    fontFamily: CHART_FONT.mono,
    fontSize: 11,
    color: CHART_COLORS.inkLight,
    padding: 0,
  },
} as const;

/** Color palette for series in multi-series charts */
export const SERIES_COLORS = [
  CHART_COLORS.accent,
  CHART_COLORS.ink,
  CHART_COLORS.inkLight,
  CHART_COLORS.highlight,
  CHART_COLORS.rule,
] as const;

```

File: /Users/austin/dev/kink/src/components/data-table.tsx
(lines 1-75)
```tsx
import type { ReactNode } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

interface DataTableColumn<Row> {
  id: string;
  header: ReactNode;
  align?: "left" | "right";
  headerClassName?: string;
  cellClassName?: string;
  cell: (row: Row, index: number) => ReactNode;
}

interface DataTableProps<Row> {
  columns: Array<DataTableColumn<Row>>;
  rows: Row[];
  rowKey: (row: Row, index: number) => string;
  emptyMessage?: string;
  className?: string;
}

function getAlignClass(align: "left" | "right" | undefined): string {
  return align === "right" ? "numeric" : "";
}

export function DataTable<Row>({
  columns,
  rows,
  rowKey,
  emptyMessage = "No rows",
  className,
}: DataTableProps<Row>) {
  return (
    <Table className={className}>
      <TableHeader>
        <TableRow>
          {columns.map((column) => (
            <TableHead
              key={column.id}
              className={`${getAlignClass(column.align)} ${column.headerClassName ?? ""}`.trim()}
            >
              {column.header}
            </TableHead>
          ))}
        </TableRow>
      </TableHeader>
      <TableBody>
        {rows.length === 0 ? (
          <TableRow>
            <TableCell colSpan={columns.length}>{emptyMessage}</TableCell>
          </TableRow>
        ) : (
          rows.map((row, rowIndex) => (
            <TableRow key={rowKey(row, rowIndex)}>
              {columns.map((column) => (
                <TableCell
                  key={column.id}
                  className={`${getAlignClass(column.align)} ${column.cellClassName ?? ""}`.trim()}
                >
                  {column.cell(row, rowIndex)}
                </TableCell>
              ))}
            </TableRow>
          ))
        )}
      </TableBody>
    </Table>
  );
}

```

File: /Users/austin/dev/kink/src/components/section-header.tsx
(lines 1-20)
```tsx
import type { ReactNode } from "react";

interface SectionHeaderProps {
  number: string;
  title: string;
  subtitle?: ReactNode;
  className?: string;
}

export function SectionHeader({ number, title, subtitle, className }: SectionHeaderProps) {
  return (
    <header className={className}>
      <h2 className="section-header">
        <span className="section-number">{number}</span>
        <span>{title}</span>
      </h2>
      {subtitle ? <p className="section-subtitle">{subtitle}</p> : null}
    </header>
  );
}

```

File: /Users/austin/dev/kink/src/components/stat-card.tsx
(lines 1-18)
```tsx
import type { ReactNode } from "react";

interface StatCardProps {
  label: string;
  value: ReactNode;
  note?: ReactNode;
  className?: string;
}

export function StatCard({ label, value, note, className }: StatCardProps) {
  return (
    <div className={`stat-cell ${className ?? ""}`.trim()}>
      <p className="stat-cell-label">{label}</p>
      <p className="stat-cell-value">{value}</p>
      {note ? <p className="stat-cell-note">{note}</p> : null}
    </div>
  );
}

```

File: /Users/austin/dev/kink/src/lib/format-labels.ts
(lines 1-65)
```ts
interface ColumnWithDisplayName {
  name: string;
  displayName?: string;
}

const HASH_SUFFIX_PATTERN = /\s\(([a-z0-9]{5,8})\)$/i;

export function stripHashSuffix(value: string): string {
  return value.replace(HASH_SUFFIX_PATTERN, "");
}

export function candidateValueKeys(value: string): string[] {
  const trimmed = value.trim();
  if (trimmed.length === 0) {
    return [trimmed];
  }

  const candidates = new Set<string>([trimmed]);
  const numeric = Number(trimmed);

  if (Number.isFinite(numeric)) {
    candidates.add(String(numeric));
    if (Number.isInteger(numeric)) {
      candidates.add(String(Math.trunc(numeric)));
    }
  }

  if (/^-?\d+\.0+$/.test(trimmed)) {
    candidates.add(trimmed.replace(/\.0+$/, ""));
  }

  return [...candidates];
}

export function formatValueWithLabel(
  value: string,
  valueLabels?: Record<string, string>,
  includeRawValue = false,
): string {
  if (value === "NULL") {
    return "No answer";
  }
  if (!valueLabels) {
    return value;
  }

  for (const key of candidateValueKeys(value)) {
    const label = valueLabels[key];
    if (label) {
      return includeRawValue ? `${value} - ${label}` : label;
    }
  }

  return value;
}

export function getColumnDisplayName(column: ColumnWithDisplayName): string {
  return stripHashSuffix(column.displayName ?? column.name);
}

export function getColumnTooltip(column: ColumnWithDisplayName): string {
  const display = getColumnDisplayName(column);
  const full = stripHashSuffix(column.name);
  return full.length > display.length ? full : display;
}

```

File: /Users/austin/dev/kink/src/components/column-name-tooltip.tsx
(lines 1-20)
```tsx
import type { ReactElement } from "react";

import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { getColumnTooltip } from "@/lib/format-labels";

interface ColumnNameTooltipProps {
  column: { name: string; displayName?: string };
  children: ReactElement;
}

export function ColumnNameTooltip({ column, children }: ColumnNameTooltipProps) {
  return (
    <TooltipProvider delayDuration={200}>
      <Tooltip>
        <TooltipTrigger asChild>{children}</TooltipTrigger>
        <TooltipContent>{getColumnTooltip(column)}</TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}

```

File: /Users/austin/dev/kink/src/routes/__root.tsx
(lines 1-288)
```tsx
import {
  HeadContent,
  Link,
  Outlet,
  Scripts,
  createRootRoute,
  useRouterState,
} from "@tanstack/react-router";
import { useEffect, useState } from "react";

import { FeedbackDialog } from "@/components/feedback-dialog";
import { DuckDBProvider } from "@/lib/duckdb/provider";
import appCss from "../styles.css?url";

export const Route = createRootRoute({
  head: () => ({
    meta: [
      { charSet: "utf-8" },
      { name: "viewport", content: "width=device-width, initial-scale=1" },
      { title: "Big Kink Survey Explorer" },
    ],
    links: [{ rel: "stylesheet", href: appCss }],
  }),
  component: RootComponent,
  shellComponent: RootDocument,
});

function RootDocument({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <head>
        <HeadContent />
      </head>
      <body>
        {children}
        <Scripts />
      </body>
    </html>
  );
}

type ExploreChildLink = {
  to: "/explore/crosstab" | "/columns" | "/profile" | "/relationships" | "/data-quality";
  label: string;
  description: string;
};

const desktopNavLinks = [
  { to: "/", label: "Home" },
  { to: "/sql", label: "SQL Console" },
  { to: "/notebook", label: "Notebook" },
  { to: "/about", label: "About" },
] as const;

const exploreChildLinks: ExploreChildLink[] = [
  {
    to: "/explore/crosstab",
    label: "Compare Questions",
    description: "Cross-tab two questions and inspect specific cells.",
  },
  {
    to: "/columns",
    label: "Browse Topics",
    description: "Search and filter all survey questions.",
  },
  {
    to: "/profile",
    label: "Build a Profile",
    description: "Define one or two groups and see what over-indexes.",
  },
  {
    to: "/relationships",
    label: "What's Connected?",
    description: "Find the strongest question-to-question associations.",
  },
  {
    to: "/data-quality",
    label: "Data Quality",
    description: "Check missingness and caveats before interpreting.",
  },
];

const mobileExploreLinks = [
  { to: "/explore", label: "Explore Home" },
  ...exploreChildLinks.map((link) => ({ to: link.to, label: link.label })),
] as const;

const exploreGroupPaths = new Set([
  "/explore",
  "/explore/crosstab",
  "/columns",
  "/profile",
  "/relationships",
  "/data-quality",
]);

function RootComponent() {
  const pathname = useRouterState({ select: (state) => state.location.pathname });
  const isExploreGroupActive = exploreGroupPaths.has(pathname);

  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [mobileExploreOpen, setMobileExploreOpen] = useState(false);
  const [feedbackOpen, setFeedbackOpen] = useState(false);

  useEffect(() => {
    if (!mobileMenuOpen) return;

    const onKeyDown = (event: KeyboardEvent) => {
      if (event.key === "Escape") {
        setMobileMenuOpen(false);
        setMobileExploreOpen(false);
      }
    };

    window.addEventListener("keydown", onKeyDown);
    return () => window.removeEventListener("keydown", onKeyDown);
  }, [mobileMenuOpen]);

  useEffect(() => {
    const onResize = () => {
      if (window.innerWidth > 900) {
        setMobileMenuOpen(false);
        setMobileExploreOpen(false);
      }
    };

    window.addEventListener("resize", onResize);
    return () => window.removeEventListener("resize", onResize);
  }, []);

  useEffect(() => {
    if (mobileMenuOpen) return;
    setMobileExploreOpen(false);
  }, [mobileMenuOpen]);

  const closeMobileMenus = () => {
    setMobileMenuOpen(false);
    setMobileExploreOpen(false);
  };

  return (
    <DuckDBProvider>
      <div className="app-shell">
        <nav className="app-nav">
          <div className="nav-inner">
            <Link to="/" className="brand-link">
              <span className="brand-title">Big Kink Survey Explorer</span>
              <span className="brand-subtitle">Question-First Research Explorer</span>
            </Link>
            <button
              type="button"
              className="nav-toggle"
              aria-expanded={mobileMenuOpen}
              aria-controls="mobile-nav-links"
              aria-label={mobileMenuOpen ? "Close navigation menu" : "Open navigation menu"}
              onClick={() => setMobileMenuOpen((open) => !open)}
            >
              {mobileMenuOpen ? "Close" : "Menu"}
            </button>
            <div className="nav-links nav-links--desktop">
              <Link
                to={desktopNavLinks[0].to}
                className="nav-link"
                activeProps={{ className: "nav-link nav-link-active" }}
              >
                {desktopNavLinks[0].label}
              </Link>

              <div className="nav-dropdown">
                <Link
                  to="/explore"
                  className={`nav-link nav-link--featured ${isExploreGroupActive ? "nav-link-active" : ""}`}
                >
                  <span className="nav-feature-glyph" aria-hidden="true">
                    ✦
                  </span>
                  <span>Explore</span>
                  <span className="nav-feature-caret" aria-hidden="true">
                    ▾
                  </span>
                </Link>

                <div className="nav-dropdown-menu" aria-label="Explore pages">
                  {exploreChildLinks.map((link) => (
                    <Link key={link.to} to={link.to} className="nav-dropdown-item" aria-label={link.label}>
                      <span className="nav-dropdown-item-label">{link.label}</span>
                      <span className="nav-dropdown-item-description">{link.description}</span>
                    </Link>
                  ))}
                </div>
              </div>

              {desktopNavLinks.slice(1).map((link) => (
                <Link
                  key={link.to}
                  to={link.to}
                  className="nav-link"
                  activeProps={{ className: "nav-link nav-link-active" }}
                >
                  {link.label}
                </Link>
              ))}
              <button
                type="button"
                className="nav-link"
                onClick={() => setFeedbackOpen(true)}
              >
                Feedback
              </button>
            </div>
          </div>

          <div id="mobile-nav-links" className={`nav-links-mobile ${mobileMenuOpen ? "nav-links-mobile--open" : ""}`}>
            <Link
              to="/"
              className="nav-link nav-link--mobile"
              activeProps={{ className: "nav-link nav-link--mobile nav-link-active" }}
              onClick={closeMobileMenus}
            >
              Home
            </Link>

            <button
              type="button"
              className={`nav-link nav-link--mobile nav-link--mobile-group ${isExploreGroupActive ? "nav-link-active" : ""}`}
              aria-expanded={mobileExploreOpen}
              aria-controls="mobile-explore-links"
              onClick={() => setMobileExploreOpen((open) => !open)}
            >
              <span className="nav-mobile-group-label">
                <span className="nav-feature-glyph" aria-hidden="true">
                  ✦
                </span>{" "}
                Explore
              </span>
              <span className="nav-mobile-group-icon" aria-hidden="true">
                {mobileExploreOpen ? "−" : "+"}
              </span>
            </button>

            <div
              id="mobile-explore-links"
              className={`nav-mobile-subitems ${mobileExploreOpen ? "nav-mobile-subitems--open" : ""}`}
            >
              {mobileExploreLinks.map((link) => (
                <Link
                  key={`mobile-${link.to}`}
                  to={link.to}
                  className="nav-link nav-link--mobile nav-link--mobile-sub"
                  activeProps={{ className: "nav-link nav-link--mobile nav-link--mobile-sub nav-link-active" }}
                  onClick={closeMobileMenus}
                >
                  {link.label}
                </Link>
              ))}
            </div>

            {desktopNavLinks.slice(1).map((link) => (
              <Link
                key={`mobile-${link.to}`}
                to={link.to}
                className="nav-link nav-link--mobile"
                activeProps={{ className: "nav-link nav-link--mobile nav-link-active" }}
                onClick={closeMobileMenus}
              >
                {link.label}
              </Link>
            ))}
            <button
              type="button"
              className="nav-link nav-link--mobile"
              onClick={() => {
                closeMobileMenus();
                setFeedbackOpen(true);
              }}
            >
              Feedback
            </button>
          </div>
        </nav>
        <main className="app-main">
          <Outlet />
        </main>
      </div>
      <FeedbackDialog open={feedbackOpen} onOpenChange={setFeedbackOpen} />
    </DuckDBProvider>
  );
}

```

File: /Users/austin/dev/kink/src/components/column-combobox.tsx
(lines 1-206)
```tsx
import { ChevronDown } from "lucide-react";
import { useEffect, useMemo, useRef, useState } from "react";

import { getColumnDisplayName, stripHashSuffix } from "@/lib/format-labels";
import { cn } from "@/lib/utils";
import { Input } from "./ui/input";

interface ColumnOption {
  name: string;
  displayName?: string;
}

interface ColumnComboboxProps {
  columns: ColumnOption[];
  value: string;
  onValueChange: (value: string) => void;
  placeholder?: string;
  disabled?: boolean;
  includeNoneOption?: boolean;
  noneOptionLabel?: string;
  className?: string;
}

interface ResolvedOption {
  value: string;
  displayName: string;
  secondary: string | null;
}

export function ColumnCombobox({
  columns,
  value,
  onValueChange,
  placeholder = "Select a column",
  disabled = false,
  includeNoneOption = false,
  noneOptionLabel = "None",
  className,
}: ColumnComboboxProps) {
  const [open, setOpen] = useState(false);
  const [query, setQuery] = useState("");
  const [highlightedIndex, setHighlightedIndex] = useState(0);

  const containerRef = useRef<HTMLDivElement | null>(null);
  const inputRef = useRef<HTMLInputElement | null>(null);

  const options = useMemo<ResolvedOption[]>(() => {
    const mapped = columns.map((column) => ({
      value: column.name,
      displayName: getColumnDisplayName(column),
      secondary: stripHashSuffix(column.name),
    }));

    if (!includeNoneOption) {
      return mapped;
    }

    return [{ value: "", displayName: noneOptionLabel, secondary: null }, ...mapped];
  }, [columns, includeNoneOption, noneOptionLabel]);

  const filteredOptions = useMemo(() => {
    const term = query.trim().toLowerCase();
    if (!term) return options;

    return options.filter((option) => {
      const secondary = option.secondary?.toLowerCase() ?? "";
      return option.displayName.toLowerCase().includes(term) || secondary.includes(term);
    });
  }, [options, query]);

  const selectedOption = useMemo(
    () => options.find((option) => option.value === value) ?? null,
    [options, value],
  );

  useEffect(() => {
    function onPointerDown(event: PointerEvent) {
      if (!containerRef.current?.contains(event.target as Node)) {
        setOpen(false);
      }
    }

    window.addEventListener("pointerdown", onPointerDown);
    return () => window.removeEventListener("pointerdown", onPointerDown);
  }, []);

  useEffect(() => {
    if (!open) return;
    inputRef.current?.focus();
  }, [open]);

  useEffect(() => {
    setHighlightedIndex((current) =>
      filteredOptions.length === 0 ? 0 : Math.max(0, Math.min(current, filteredOptions.length - 1)),
    );
  }, [filteredOptions]);

  const openMenu = () => {
    if (disabled) return;
    setOpen(true);
    setQuery("");
    const selectedIndex = options.findIndex((option) => option.value === value);
    setHighlightedIndex(selectedIndex >= 0 ? selectedIndex : 0);
  };

  const closeMenu = () => {
    setOpen(false);
    setQuery("");
  };

  const pick = (nextValue: string) => {
    onValueChange(nextValue);
    closeMenu();
  };

  return (
    <div ref={containerRef} className={cn("relative", className)}>
      <button
        type="button"
        disabled={disabled}
        className="flex h-9 w-full items-center justify-between border border-[var(--rule)] bg-[var(--paper)] px-2.5 py-2 text-[0.8rem] font-['JetBrains_Mono',ui-monospace,monospace] leading-[1.4] text-[var(--ink)] focus:outline-none focus:border-[var(--ink)] disabled:cursor-not-allowed disabled:opacity-50"
        onClick={() => (open ? closeMenu() : openMenu())}
        onKeyDown={(event) => {
          if (event.key === "ArrowDown" || event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            openMenu();
          }
        }}
      >
        <span className={selectedOption ? "text-[var(--ink)]" : "text-[var(--ink-faded)]"}>
          {selectedOption ? selectedOption.displayName : placeholder}
        </span>
        <ChevronDown className="h-4 w-4 opacity-70" />
      </button>

      {open ? (
        <div className="absolute z-50 mt-1 w-full border border-[var(--rule)] bg-[var(--paper)] p-2">
          <Input
            ref={inputRef}
            value={query}
            onChange={(event) => setQuery(event.target.value)}
            placeholder="Search columns..."
            onKeyDown={(event) => {
              if (event.key === "ArrowDown") {
                event.preventDefault();
                setHighlightedIndex((current) =>
                  filteredOptions.length === 0 ? 0 : Math.min(current + 1, filteredOptions.length - 1),
                );
              } else if (event.key === "ArrowUp") {
                event.preventDefault();
                setHighlightedIndex((current) =>
                  filteredOptions.length === 0 ? 0 : Math.max(current - 1, 0),
                );
              } else if (event.key === "Enter") {
                event.preventDefault();
                const option = filteredOptions[highlightedIndex];
                if (option) {
                  pick(option.value);
                }
              } else if (event.key === "Escape") {
                event.preventDefault();
                closeMenu();
              }
            }}
          />

          <div className="mt-2 max-h-72 overflow-y-auto border border-[var(--rule-light)] bg-[var(--paper)]">
            {filteredOptions.length === 0 ? (
              <p className="px-2 py-2 text-[0.72rem] text-[var(--ink-faded)]">No matching columns</p>
            ) : (
              <div>
                {filteredOptions.map((option, index) => {
                  const active = index === highlightedIndex;
                  const selected = option.value === value;

                  return (
                    <button
                      key={`${option.value || "__none__"}-${index}`}
                      type="button"
                      className={cn(
                        "w-full border-b border-[var(--rule-light)] px-2 py-1.5 text-left last:border-b-0",
                        active ? "bg-[var(--paper-warm)]" : "bg-transparent",
                      )}
                      onMouseEnter={() => setHighlightedIndex(index)}
                      onClick={() => pick(option.value)}
                    >
                      <p className="truncate text-[0.8rem] font-['Source_Serif_4',Georgia,serif] text-[var(--ink)]">
                        {option.displayName}
                        {selected ? "  *" : ""}
                      </p>
                      {option.secondary ? (
                        <p className="truncate font-['JetBrains_Mono',ui-monospace,monospace] text-[0.68rem] text-[var(--ink-faded)]">
                          {option.secondary}
                        </p>
                      ) : null}
                    </button>
                  );
                })}
              </div>
            )}
          </div>
        </div>
      ) : null}
    </div>
  );
}

```

File: /Users/austin/dev/kink/package.json
(lines 1-77)
```json
{
  "name": "kink-survey-explorer",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite dev --port 3000",
    "build": "vite build",
    "preview": "vite preview",
    "start": "node .output/server/index.mjs",
    "sync-public-data": "node scripts/sync-public-data.mjs",
    "profile-schema": "node scripts/profile-schema.mjs",
    "validate-chart-presets": "node scripts/validate-chart-presets.mjs",
    "check-types": "tsc --noEmit",
    "test": "vitest",
    "test:e2e": "playwright test",
    "lint": "oxlint",
    "prepare": "husky"
  },
  "dependencies": {
    "@aws-sdk/client-ses": "^3.990.0",
    "@duckdb/duckdb-wasm": "1.33.1-dev18.0",
    "@duckdb/node-api": "1.4.4-r.1",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@tailwindcss/vite": "^4.1.18",
    "@tanstack/react-devtools": "^0.7.0",
    "@tanstack/react-router": "^1.132.0",
    "@tanstack/react-router-devtools": "^1.132.0",
    "@tanstack/react-router-ssr-query": "^1.131.7",
    "@tanstack/react-start": "^1.132.0",
    "@tanstack/router-plugin": "^1.132.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.545.0",
    "nitro": "npm:nitro-nightly@3.0.1-20260212-205859-0f4c665f",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "recharts": "^3.7.0",
    "tailwind-merge": "^3.4.0",
    "tailwindcss": "^4.1.18",
    "vite-tsconfig-paths": "^6.0.2",
    "zod": "^4.3.6"
  },
  "devDependencies": {
    "@playwright/test": "^1.58.2",
    "@tanstack/devtools-vite": "^0.3.11",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/react": "^16.2.0",
    "@types/node": "^22.10.2",
    "@types/react": "^19.2.0",
    "@types/react-dom": "^19.2.0",
    "@vitejs/plugin-react": "^5.0.4",
    "husky": "^9.1.7",
    "jsdom": "^27.0.0",
    "lint-staged": "^16.2.7",
    "oxlint": "^1.47.0",
    "playwright": "^1.58.2",
    "typescript": "^5.7.2",
    "vite": "^7.1.7",
    "vitest": "^3.0.5"
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "oxlint"
    ]
  },
  "packageManager": "pnpm@10.6.3",
  "pnpm": {
    "onlyBuiltDependencies": [
      "esbuild"
    ]
  }
}

```

File: /Users/austin/dev/kink/vite.config.ts
(lines 1-25)
```ts
import { defineConfig } from 'vite'
import { tanstackStart } from '@tanstack/react-start/plugin/vite'
import { nitro } from 'nitro/vite'
import viteReact from '@vitejs/plugin-react'
import viteTsConfigPaths from 'vite-tsconfig-paths'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
  base: process.env.VITE_BASE_PATH || '/',
  test: {
    include: ['src/**/*.test.{ts,tsx}'],
    exclude: ['e2e/**', 'test-results/**', 'dist/**', '.output/**', 'node_modules/**'],
  },
  plugins: [
    viteTsConfigPaths({
      projects: ['./tsconfig.json'],
    }),
    tailwindcss(),
    tanstackStart(),
    nitro({
      baseURL: process.env.VITE_BASE_PATH || '/',
    }),
    viteReact(),
  ],
})

```

File: /Users/austin/dev/kink/tsconfig.json
(lines 1-30)
```json
{
  "include": ["**/*.ts", "**/*.tsx"],
  "exclude": ["e2e/**"],
  "compilerOptions": {
    "target": "ES2022",
    "jsx": "react-jsx",
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "verbatimModuleSyntax": false,
    "noEmit": true,

    /* Linting */
    "skipLibCheck": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

```

File: /Users/austin/dev/kink/scripts/profile-schema.mjs
(lines 1-354: buildDisplayName and payload generation)
```mjs
#!/usr/bin/env node

import { mkdir, readFile, stat, writeFile } from "node:fs/promises";
import { dirname, resolve } from "node:path";
import { fileURLToPath } from "node:url";

import { DuckDBInstance } from "@duckdb/node-api";

const __dirname = dirname(fileURLToPath(import.meta.url));
const projectRoot = resolve(__dirname, "..");

const sourcePath = process.env.BKS_PARQUET_PATH ?? resolve(projectRoot, "data", "BKSPublic.parquet");
const outputPath = process.env.BKS_COLUMNS_OUTPUT ?? resolve(projectRoot, "src", "lib", "schema", "columns.generated.json");
const humanLabelsPath = resolve(projectRoot, "src", "lib", "schema", "human-labels.json");

/** @type {Record<string, string>} */
let humanLabels = {};
try {
  const raw = await readFile(humanLabelsPath, "utf8");
  const parsed = JSON.parse(raw);
  // Filter out the _comment key
  humanLabels = Object.fromEntries(
    Object.entries(parsed).filter(([key]) => !key.startsWith("_")),
  );
  console.log(`Loaded ${Object.keys(humanLabels).length} human label overrides`);
} catch {
  console.log("No human-labels.json found, using auto-generated display names only");
}

const derivedColumns = new Set([
  "straightness",
  "childhood_adversity",
  "childhood_gender_tolerance",
  "TotalMentalIllness",
  "opennessvariable",
  "consciensiousnessvariable",
  "extroversionvariable",
  "neuroticismvariable",
  "agreeablenessvariable",
  "powerlessnessvariable",
  "totalfetishcategory",
  "bondageaverage",
]);

const demographicHints = [
  "age",
  "gender",
  "male",
  "female",
  "cis",
  "trans",
  "politics",
  "bmi",
  "relationship",
  "education",
  "income",
  "childhood",
  "straightness",
  "orientation",
  "liberated",
];

const demographicExclusions = new Set([
  "marriage100blood",
]);

const fetishHints = [
  "fetish",
  "bondage",
  "nonconsent",
  "sadism",
  "masoch",
  "submission",
  "dominant",
  "kink",
  "erotic",
  "sexual",
  "voyeur",
  "exhibition",
  "humiliation",
  "transformation",
];

const fetishColumnOverrides = new Set([
  '"I find scenarios where I eagerly beg others to be:" (jvrbyep)',
  '"I find scenarios where others eagerly beg me to be:" (stmm5eg)',
  "appearance",
  "bestiality",
  "brutality",
  "cgl",
  "clothing",
  "creepy",
  "dirty",
  "eagerness",
  "frustration",
  "futa",
  "gentleness",
  "incest",
  "multiplepartners",
  "mythical",
  "objects",
  "pregnancy",
  "roles",
  "secretions",
  "sensory",
  "spanking",
  "teasing",
  "toys",
  "vore",
  "worshipped",
  "worshipping",
]);

function quoteIdentifier(identifier) {
  return `"${identifier.replaceAll('"', '""')}"`;
}

function isNumericDuckType(type) {
  return /(TINYINT|SMALLINT|INTEGER|BIGINT|HUGEINT|UTINYINT|USMALLINT|UINTEGER|UBIGINT|FLOAT|DOUBLE|DECIMAL|REAL)/i.test(type);
}

function inferLogicalType(name, duckdbType, approxCardinality) {
  const lowerName = name.toLowerCase();

  if (/^boolean$/i.test(duckdbType)) {
    return "boolean";
  }

  if (/varchar|char|string|text|uuid/i.test(duckdbType)) {
    return approxCardinality <= 120 ? "categorical" : "text";
  }

  if (isNumericDuckType(duckdbType)) {
    if (
      approxCardinality <= 20 &&
      !/(average|variable|count|score|years?|total|height|weight|ratio|percent)/i.test(lowerName)
    ) {
      return "categorical";
    }

    return "numeric";
  }

  if (/date|time|timestamp/i.test(duckdbType)) {
    return "text";
  }

  return "unknown";
}

function inferTags(name) {
  const tags = new Set();
  const lowerName = name.toLowerCase();

  if (
    !demographicExclusions.has(name) &&
    demographicHints.some((hint) => lowerName.includes(hint))
  ) {
    tags.add("demographic");
  }

  if (/(openness|consciensiousness|extroversion|neuroticism|agreeableness)/i.test(name)) {
    tags.add("ocean");
  }

  if (
    fetishColumnOverrides.has(name) ||
    fetishHints.some((hint) => lowerName.includes(hint))
  ) {
    tags.add("fetish");
  }

  if (
    derivedColumns.has(name) ||
    /^total/i.test(name) ||
    /(average|variable)/i.test(name)
  ) {
    tags.add("derived");
  }

  if (tags.size === 0) {
    tags.add("other");
  }

  return [...tags];
}

function inferNullMeaning(name, nullRatio) {
  const lowerName = name.toLowerCase();

  if (
    /(late|newly added|added later|followup|follow_up|second wave|third wave|v2|v3)/i.test(lowerName)
  ) {
    return "LATE_ADDED";
  }

  if (
    nullRatio > 0.15 &&
    /(pregnan|menstru|period|erection|penis|vagina|prostate|breastfeed|bio ?male|bio ?female|cis ?male|cis ?female)/i.test(
      lowerName,
    )
  ) {
    return "NOT_APPLICABLE";
  }

  if (nullRatio > 0.3) {
    return "GATED";
  }

  return "UNKNOWN";
}

function normalizeInteger(value, fallback = 0) {
  if (typeof value === "bigint") {
    return Number(value);
  }

  if (typeof value === "number" && Number.isFinite(value)) {
    return value;
  }

  return fallback;
}

function roundRatio(value) {
  if (!Number.isFinite(value)) {
    return 0;
  }

  return Math.round(value * 10000) / 10000;
}

function truncateDisplayName(value, maxLength = 60) {
  if (value.length <= maxLength) {
    return value;
  }

  return `${value.slice(0, maxLength - 3).trimEnd()}...`;
}

function toTitleCaseIdentifier(value) {
  const spaced = value
    .replace(/[_-]+/g, " ")
    .replace(/([a-z])([A-Z])/g, "$1 $2")
    .replace(/\s+/g, " ")
    .trim();

  if (!spaced) {
    return value;
  }

  return spaced
    .split(" ")
    .map((token) => {
      if (token.length <= 4 && /^[A-Z0-9]+$/.test(token)) {
        return token;
      }
      return `${token.slice(0, 1).toUpperCase()}${token.slice(1)}`;
    })
    .join(" ");
}

function buildDisplayName(name) {
  // Human-curated override takes priority
  if (humanLabels[name]) {
    return humanLabels[name];
  }

  const quotedMatch = name.match(/^"(.+)"\s+\([^)]+\)$/);
  if (quotedMatch) {
    return truncateDisplayName(quotedMatch[1].trim());
  }

  if (/^[A-Za-z0-9_-]+$/.test(name)) {
    return truncateDisplayName(toTitleCaseIdentifier(name));
  }

  return truncateDisplayName(name.replaceAll('"', "").trim());
}

async function main() {
  await stat(sourcePath);

  const instance = await DuckDBInstance.create(":memory:");
  const connection = await instance.connect();

  const sourceLiteral = sourcePath.replaceAll("'", "''");
  await connection.run(`CREATE OR REPLACE VIEW data AS SELECT * FROM read_parquet('${sourceLiteral}')`);

  const rowCountReader = await connection.runAndReadAll("SELECT count(*)::BIGINT AS row_count FROM data");
  const rowCount = normalizeInteger(rowCountReader.getRowsJS()[0]?.[0]);

  const describeReader = await connection.runAndReadAll("DESCRIBE data");
  const describeRows = describeReader.getRowObjectsJS();

  const columns = [];

  for (const row of describeRows) {
    const name = String(row.column_name);
    const duckdbType = String(row.column_type);
    const quotedColumn = quoteIdentifier(name);

    const metricsReader = await connection.runAndReadAll(
      `SELECT
         count(*)::BIGINT AS total_count,
         count(${quotedColumn})::BIGINT AS non_null_count,
         approx_count_distinct(${quotedColumn})::BIGINT AS approx_cardinality
       FROM data`,
    );

    const metrics = metricsReader.getRowObjectsJS()[0] ?? {};
    const totalCount = normalizeInteger(metrics.total_count, rowCount);
    const nonNullCount = normalizeInteger(metrics.non_null_count, 0);
    const approxCardinality = normalizeInteger(metrics.approx_cardinality, 0);

    const nullRatio = totalCount > 0 ? (totalCount - nonNullCount) / totalCount : 0;

    columns.push({
      name,
      displayName: buildDisplayName(name),
      duckdbType,
      logicalType: inferLogicalType(name, duckdbType, approxCardinality),
      nullRatio: roundRatio(nullRatio),
      approxCardinality,
      tags: inferTags(name),
      nullMeaning: inferNullMeaning(name, nullRatio),
    });
  }

  columns.sort((left, right) => left.name.localeCompare(right.name));

  const payload = {
    dataset: {
      name: "Big Kink Survey (Public Sample)",
      sourcePath,
      generatedAt: new Date().toISOString(),
      rowCount,
      columnCount: columns.length,
    },
    columns,
  };

  await mkdir(dirname(outputPath), { recursive: true });
  await writeFile(outputPath, `${JSON.stringify(payload, null, 2)}\n`, "utf8");

  console.log(`Generated ${columns.length} column metadata entries at ${outputPath}`);

  connection.closeSync();
}

main().catch((error) => {
  console.error("Failed to generate column metadata", error);
  process.exit(1);
});

```

File: /Users/austin/dev/kink/src/lib/schema/types.ts
(lines 1-30)
```ts
export type LogicalType = "categorical" | "numeric" | "boolean" | "text" | "unknown";

export type CategoryTag = "demographic" | "ocean" | "fetish" | "derived" | "other";

export type NullMeaning = "GATED" | "LATE_ADDED" | "NOT_APPLICABLE" | "UNKNOWN";

export interface ColumnMetadata {
  name: string;
  displayName?: string;
  duckdbType: string;
  logicalType: LogicalType;
  nullRatio: number;
  approxCardinality: number;
  tags: CategoryTag[];
  nullMeaning?: NullMeaning;
  valueLabels?: Record<string, string>;
}

export interface DatasetMetadata {
  name: string;
  sourcePath: string;
  generatedAt: string;
  rowCount: number;
  columnCount: number;
}

export interface SchemaMetadata {
  dataset: DatasetMetadata;
  columns: ColumnMetadata[];
}

```

File: /Users/austin/dev/kink/src/lib/api/contracts.ts
(lines 1-168)
```ts
import { z } from "zod";

export const LogicalTypeSchema = z.enum([
  "categorical",
  "numeric",
  "boolean",
  "text",
  "unknown",
]);

export const CategoryTagSchema = z.enum([
  "demographic",
  "ocean",
  "fetish",
  "derived",
  "other",
]);

export const CaveatKeySchema = z.enum([
  "binned_or_collapsed",
  "combined_or_merged",
  "computed_column",
  "negated_scale",
  "opaque_composite",
  "gated_missingness",
  "late_added_questions",
]);

export const NullMeaningSchema = z.enum([
  "GATED",
  "LATE_ADDED",
  "NOT_APPLICABLE",
  "UNKNOWN",
]);

export const CaveatSchema = z.object({
  key: CaveatKeySchema,
  title: z.string(),
  description: z.string(),
  guidance: z.string(),
});

export const ColumnMetadataSchema = z.object({
  name: z.string(),
  displayName: z.string().optional(),
  duckdbType: z.string(),
  logicalType: LogicalTypeSchema,
  nullRatio: z.number().min(0).max(1),
  approxCardinality: z.number().int().nonnegative(),
  tags: z.array(CategoryTagSchema),
  valueLabels: z.record(z.string(), z.string()).optional(),
  nullMeaning: NullMeaningSchema.default("UNKNOWN"),
  caveatKeys: z.array(CaveatKeySchema).default([]),
});

export const DatasetMetadataSchema = z.object({
  name: z.string(),
  sourcePath: z.string(),
  generatedAt: z.string(),
  rowCount: z.number().int().nonnegative(),
  columnCount: z.number().int().nonnegative(),
});

export const SchemaDataSchema = z.object({
  dataset: DatasetMetadataSchema,
  columns: z.array(ColumnMetadataSchema),
  caveats: z.object({
    global: z.array(CaveatKeySchema),
    definitions: z.array(CaveatSchema),
  }),
});

export const QueryRequestSchema = z.object({
  sql: z.string().trim().min(1),
  limit: z.number().int().positive().max(10_000).optional(),
});

export const QueryDataSchema = z.object({
  columns: z.array(z.string()),
  rows: z.array(z.array(z.unknown())),
});

export const FilterValueSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);

export const FiltersSchema = z.record(
  z.string(),
  z.union([FilterValueSchema, z.array(FilterValueSchema)]),
);

export const CrosstabRequestSchema = z.object({
  x: z.string().min(1),
  y: z.string().min(1),
  limit: z.number().int().positive().max(1_000).optional(),
  filters: FiltersSchema.optional(),
});

export const CrosstabRowSchema = z.object({
  x: z.union([z.string(), z.number(), z.boolean(), z.null()]),
  y: z.union([z.string(), z.number(), z.boolean(), z.null()]),
  count: z.number().int().nonnegative(),
});

export const CrosstabDataSchema = z.object({
  x: z.string(),
  y: z.string(),
  rows: z.array(CrosstabRowSchema),
});

export const NumericStatsSchema = z.object({
  kind: z.literal("numeric"),
  totalCount: z.number().int().nonnegative(),
  nonNullCount: z.number().int().nonnegative(),
  nullCount: z.number().int().nonnegative(),
  mean: z.number().nullable(),
  stddev: z.number().nullable(),
  min: z.number().nullable(),
  p25: z.number().nullable(),
  median: z.number().nullable(),
  p75: z.number().nullable(),
  max: z.number().nullable(),
});

export const CategoryCountSchema = z.object({
  value: z.union([z.string(), z.number(), z.boolean(), z.null()]),
  count: z.number().int().nonnegative(),
  percentage: z.number().min(0).max(100),
});

export const CategoricalStatsSchema = z.object({
  kind: z.literal("categorical"),
  totalCount: z.number().int().nonnegative(),
  nonNullCount: z.number().int().nonnegative(),
  nullCount: z.number().int().nonnegative(),
  topValues: z.array(CategoryCountSchema),
});

export const StatsDataSchema = z.object({
  column: z.string(),
  logicalType: LogicalTypeSchema,
  caveatKeys: z.array(CaveatKeySchema),
  stats: z.union([NumericStatsSchema, CategoricalStatsSchema]),
});

export const ApiErrorSchema = z.object({
  code: z.string(),
  message: z.string(),
  details: z.unknown().optional(),
});

export const ApiSuccessEnvelopeSchema = <T extends z.ZodTypeAny>(dataSchema: T) =>
  z.object({
    ok: z.literal(true),
    data: dataSchema,
    meta: z.record(z.string(), z.unknown()).optional(),
  });

export const ApiErrorEnvelopeSchema = z.object({
  ok: z.literal(false),
  error: ApiErrorSchema,
});

export type QueryRequest = z.infer<typeof QueryRequestSchema>;
export type CrosstabRequest = z.infer<typeof CrosstabRequestSchema>;
export type SchemaData = z.infer<typeof SchemaDataSchema>;
export type QueryData = z.infer<typeof QueryDataSchema>;
export type CrosstabData = z.infer<typeof CrosstabDataSchema>;
export type StatsData = z.infer<typeof StatsDataSchema>;
export type ApiError = z.infer<typeof ApiErrorSchema>;

```

File: /Users/austin/dev/kink/src/lib/duckdb/sql-helpers.ts
(lines 1-45)
```ts
export function quoteIdentifier(identifier: string): string {
  return `"${identifier.replaceAll('"', '""')}"`;
}

export function quoteLiteral(value: string | number | boolean | null): string {
  if (value === null) return "NULL";
  if (typeof value === "number") return String(value);
  if (typeof value === "boolean") return value ? "TRUE" : "FALSE";
  return `'${value.replaceAll("'", "''")}'`;
}

export type FilterValue = string | number | boolean | null;
export type FilterInput = FilterValue | FilterValue[];

export function buildWhereClause(filters: Record<string, FilterInput> | undefined): string {
  if (!filters || Object.keys(filters).length === 0) return "";

  const predicates: string[] = [];

  for (const [columnName, rawValue] of Object.entries(filters)) {
    const col = quoteIdentifier(columnName);

    if (Array.isArray(rawValue)) {
      const nonNull = rawValue.filter((v) => v !== null);
      const hasNull = rawValue.length !== nonNull.length;
      const inPred = nonNull.length > 0
        ? `${col} IN (${nonNull.map((v) => quoteLiteral(v)).join(", ")})`
        : "";

      if (hasNull && inPred) predicates.push(`(${inPred} OR ${col} IS NULL)`);
      else if (hasNull) predicates.push(`${col} IS NULL`);
      else if (inPred) predicates.push(inPred);
      continue;
    }

    if (rawValue === null) {
      predicates.push(`${col} IS NULL`);
      continue;
    }

    predicates.push(`${col} = ${quoteLiteral(rawValue)}`);
  }

  return predicates.length === 0 ? "" : `WHERE ${predicates.join(" AND ")}`;
}

```

File: /Users/austin/dev/kink/src/lib/chart-presets.ts
(lines 1-97)
```ts
import findingsRaw from "../../analysis/findings.json";

export type ChartType = "bar" | "grouped-bar" | "line";

export interface ChartPreset {
  id: string;
  title: string;
  shortTitle: string;
  question: string;
  chartType: ChartType;
  sql: string;
  xLabel: string;
  yLabel: string;
  caption: string;
  /** Column names for linking to /explore */
  exploreX: string;
  exploreY: string;
  /** For grouped-bar: the grouping key */
  seriesKey?: string;
  /** For grouped-bar: series labels and colors */
  series?: Array<{ key: string; label: string; color: string }>;
  wave2?: {
    evidenceTier: "robust" | "supported" | "tiny" | "exploratory";
    effectSizeNote: string;
    riskFlags: string[];
    riskNotes: string[];
    recommendedForHome: boolean;
    curationNotes: string;
  };
}

export interface FindingsQuestionCard {
  prompt: string;
  presetId?: string;
  deepLink?: string;
}

interface FindingsPayload {
  featuredPresets: Array<{
    id: string;
    title: string;
    shortTitle: string;
    question: string;
    chartType: string;
    sql: string;
    xLabel: string;
    yLabel: string;
    caption: string;
    exploreX: string;
    exploreY: string;
    series?: Array<{ key: string; label: string; color: string }>;
    wave2?: ChartPreset["wave2"];
  }>;
  questionCards: FindingsQuestionCard[];
  defaultsByPage: {
    home?: { presetId?: string; fallbackPresetIds?: string[] };
    explore?: { x?: string; y?: string; normalization?: string; topN?: number };
    relationships?: { column?: string };
    profile?: {
      suggestedCohorts?: Array<{
        label: string;
        filters: Array<{ column: string; value: string }>;
      }>;
    };
    columns?: { sort?: string; interestingColumns?: string[] };
  };
  termMappings: Array<{ technical: string; plainLanguage: string }>;
}

function isChartType(value: string): value is ChartType {
  return value === "bar" || value === "grouped-bar" || value === "line";
}

export const FINDINGS_PAYLOAD = findingsRaw as FindingsPayload;

export const CHART_PRESETS: ChartPreset[] = FINDINGS_PAYLOAD.featuredPresets
  .filter((preset) => isChartType(preset.chartType))
  .map((preset) => ({
    id: preset.id,
    title: preset.title,
    shortTitle: preset.shortTitle,
    question: preset.question,
    chartType: preset.chartType as ChartType,
    sql: preset.sql,
    xLabel: preset.xLabel,
    yLabel: preset.yLabel,
    caption: preset.caption,
    exploreX: preset.exploreX,
    exploreY: preset.exploreY,
    seriesKey: preset.chartType === "grouped-bar" ? "group_key" : undefined,
    series: preset.chartType === "grouped-bar" ? preset.series : undefined,
    wave2: preset.wave2,
  }));

export const QUESTION_CARDS = FINDINGS_PAYLOAD.questionCards;
export const DEFAULTS_BY_PAGE = FINDINGS_PAYLOAD.defaultsByPage;
export const TERM_MAPPINGS = FINDINGS_PAYLOAD.termMappings;

```

File: /Users/austin/dev/kink/src/routes/index.tsx
(lines 1-430)
```tsx
import { createFileRoute, Link, useNavigate } from "@tanstack/react-router";
import { useEffect, useMemo, useState } from "react";

import { ColumnCombobox } from "@/components/column-combobox";
import { GroupedBarChart } from "@/components/charts/grouped-bar-chart";
import { SimpleBarChart } from "@/components/charts/bar-chart";
import { SimpleLineChart } from "@/components/charts/line-chart";
import { LoadingSkeleton } from "@/components/loading-skeleton";
import { SectionHeader } from "@/components/section-header";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import type { SchemaData } from "@/lib/api/contracts";
import { getSchema } from "@/lib/client/api";
import { useDuckDB } from "@/lib/duckdb/provider";
import { quoteIdentifier } from "@/lib/duckdb/sql-helpers";
import { useDuckDBQuery } from "@/lib/duckdb/use-query";
import {
  CHART_PRESETS,
  DEFAULTS_BY_PAGE,
  QUESTION_CARDS,
  type ChartPreset,
} from "@/lib/chart-presets";
import { formatNumber } from "@/lib/format";

export const Route = createFileRoute("/")({
  validateSearch: (search): { chart?: string } => ({
    chart: typeof search.chart === "string" ? search.chart : undefined,
  }),
  component: HomePage,
});

type DataRow = Record<string, unknown>;

type BuilderType = "bar" | "line";

const BUILDER_TYPES: Array<{ value: BuilderType; label: string }> = [
  { value: "bar", label: "Bar" },
  { value: "line", label: "Line" },
];

function toNumber(value: unknown): number {
  if (typeof value === "number" && Number.isFinite(value)) return value;
  if (typeof value === "string") {
    const parsed = Number(value);
    if (Number.isFinite(parsed)) return parsed;
  }
  return 0;
}

function toCount(value: unknown): number {
  if (typeof value === "bigint") return Number(value);
  return toNumber(value);
}

function rowsToObjects(data: { columns: string[]; rows: unknown[][] } | null): DataRow[] {
  if (!data) return [];

  return data.rows.map((row) => {
    const record: DataRow = {};
    data.columns.forEach((column, index) => {
      record[column] = row[index] ?? null;
    });
    return record;
  });
}

function HomePage() {
  const search = Route.useSearch();
  const navigate = useNavigate({ from: "/" });
  const { phase } = useDuckDB();

  const [schema, setSchema] = useState<SchemaData | null>(null);
  const [schemaError, setSchemaError] = useState<string | null>(null);

  const [buildX, setBuildX] = useState("");
  const [buildY, setBuildY] = useState("");
  const [buildType, setBuildType] = useState<BuilderType>("bar");

  useEffect(() => {
    let cancelled = false;

    void getSchema()
      .then((response) => {
        if (cancelled) return;

        const nextSchema = response.data;
        setSchema(nextSchema);

        const defaults = DEFAULTS_BY_PAGE.explore;
        const fallbackX = nextSchema.columns.find((column) => column.name === "politics")?.name
          ?? nextSchema.columns.find((column) => column.name === defaults?.x)?.name
          ?? nextSchema.columns.find((column) => column.name === "straightness")?.name
          ?? nextSchema.columns[0]?.name
          ?? "";
        const fallbackY = nextSchema.columns.find((column) => column.name === "opennessvariable")?.name
          ?? nextSchema.columns.find((column) => column.name === defaults?.y)?.name
          ?? nextSchema.columns.find((column) => column.name === "politics")?.name
          ?? nextSchema.columns[1]?.name
          ?? "";

        setBuildX((current) => current || fallbackX);
        setBuildY((current) => current || fallbackY);
      })
      .catch((error: Error) => {
        if (!cancelled) setSchemaError(error.message);
      });

    return () => {
      cancelled = true;
    };
  }, []);

  const selectedPreset = useMemo(() => {
    const byId = CHART_PRESETS.find((preset) => preset.id === search.chart);
    return byId ?? CHART_PRESETS[0] ?? null;
  }, [search.chart]);

  useEffect(() => {
    if (!selectedPreset) return;
    if (search.chart === selectedPreset.id) return;

    void navigate({
      search: { chart: selectedPreset.id },
      replace: true,
    });
  }, [search.chart, selectedPreset, navigate]);

  const featuredQuery = useDuckDBQuery(selectedPreset?.sql ?? null);
  const featuredRows = useMemo(() => rowsToObjects(featuredQuery.data), [featuredQuery.data]);
  const [lastFeaturedRows, setLastFeaturedRows] = useState<DataRow[]>([]);

  useEffect(() => {
    if (featuredQuery.loading || featuredQuery.error) return;
    setLastFeaturedRows(featuredRows);
  }, [featuredQuery.loading, featuredQuery.error, featuredRows]);

  const featuredSampleSql = useMemo(() => {
    if (!selectedPreset) return null;

    const xQuoted = quoteIdentifier(selectedPreset.exploreX);
    const yQuoted = quoteIdentifier(selectedPreset.exploreY);

    return `
      SELECT count(*)::BIGINT AS n
      FROM data
      WHERE ${xQuoted} IS NOT NULL
        AND ${yQuoted} IS NOT NULL
    `;
  }, [selectedPreset]);
  const featuredSampleQuery = useDuckDBQuery(featuredSampleSql);
  const featuredSampleSize = useMemo(
    () => toCount(featuredSampleQuery.data?.rows[0]?.[0]),
    [featuredSampleQuery.data],
  );

  const buildXMeta = useMemo(
    () => schema?.columns.find((column) => column.name === buildX) ?? null,
    [schema, buildX],
  );
  const buildYMeta = useMemo(
    () => schema?.columns.find((column) => column.name === buildY) ?? null,
    [schema, buildY],
  );

  const buildSql = useMemo(() => {
    if (!buildX || !buildY || !buildXMeta || !buildYMeta) return null;

    const xQuoted = quoteIdentifier(buildX);
    const yQuoted = quoteIdentifier(buildY);

    if (buildYMeta.logicalType === "numeric") {
      return `
        SELECT
          cast(${xQuoted} AS VARCHAR) AS name,
          round(avg(cast(${yQuoted} AS DOUBLE))::DOUBLE, 3) AS value,
          count(*)::BIGINT AS answered_count
        FROM data
        WHERE ${xQuoted} IS NOT NULL
          AND ${yQuoted} IS NOT NULL
        GROUP BY 1
        ORDER BY value DESC
        LIMIT 20
      `;
    }

    return `
      SELECT
        cast(${xQuoted} AS VARCHAR) AS name,
        count(*)::BIGINT AS value
      FROM data
      WHERE ${xQuoted} IS NOT NULL
        AND ${yQuoted} IS NOT NULL
      GROUP BY 1
      ORDER BY value DESC
      LIMIT 20
    `;
  }, [buildX, buildY, buildXMeta, buildYMeta]);

  const buildQuery = useDuckDBQuery(buildSql);
  const buildRows = useMemo(() => {
    const objects = rowsToObjects(buildQuery.data)
      .map((row) => ({
        name: String(row.name ?? "Unknown"),
        value: toNumber(row.value),
      }))
      .filter((row) => Number.isFinite(row.value));

    if (buildType === "line") {
      const allNumeric = objects.every((row) => Number.isFinite(Number(row.name)));
      if (allNumeric) {
        return [...objects].sort((left, right) => Number(left.name) - Number(right.name));
      }
      return [...objects].sort((left, right) => left.name.localeCompare(right.name));
    }

    return objects;
  }, [buildQuery.data, buildType]);

  const renderFeaturedChart = (preset: ChartPreset, rows: DataRow[]) => {
    if (preset.chartType === "grouped-bar") {
      return (
        <GroupedBarChart
          data={rows}
          series={preset.series ?? []}
          xLabel={preset.xLabel}
          yLabel={preset.yLabel}
        />
      );
    }

    const points = rows.map((row) => ({
      name: String(row.name ?? "Unknown"),
      value: toNumber(row.value),
    }));

    if (preset.chartType === "line") {
      const sorted = [...points].sort((left, right) => Number(left.name) - Number(right.name));
      return <SimpleLineChart data={sorted} xLabel={preset.xLabel} yLabel={preset.yLabel} />;
    }

    return <SimpleBarChart data={points} xLabel={preset.xLabel} yLabel={preset.yLabel} />;
  };

  return (
    <div className="page">
      <header className="page-header">
        <h1 className="page-title">The Big Kink Survey</h1>
        <p className="page-subtitle">
          What ~970,000 people were asked — and what 15,000 answers revealed about desire, personality, and identity.
        </p>
        <p className="dateline">
          Based on 15,503 anonymized responses from a{" "}
          <a
            href="https://aella.substack.com/p/heres-my-big-kink-survey-dataset"
            target="_blank"
            rel="noopener noreferrer"
            className="text-[var(--accent)] underline decoration-[var(--rule)] underline-offset-2 hover:decoration-[var(--accent)]"
          >
            ~970,000-respondent survey
          </a>.
        </p>
        <div className="mt-4">
          <Link to="/explore" className="editorial-button editorial-button--filled inline-flex">
            Start Exploring
          </Link>
        </div>
      </header>

      {schemaError ? <section className="alert alert--error">Failed to load schema: {schemaError}</section> : null}

      {selectedPreset ? (
        <section className="raised-panel space-y-4" aria-labelledby="featured-chart-heading">
          <SectionHeader number="01" title="What the data shows" />

          <p className="mono-label">Pick a finding</p>

          <div role="tablist" aria-label="Featured findings" className="flex flex-wrap gap-2">
            {CHART_PRESETS.map((preset) => {
              const selected = preset.id === selectedPreset.id;
              return (
                <button
                  key={preset.id}
                  type="button"
                  role="tab"
                  aria-selected={selected}
                  aria-controls="featured-chart-panel"
                  className={`editorial-button ${selected ? "editorial-button--filled" : ""}`}
                  onClick={() => {
                    void navigate({ search: { chart: preset.id }, replace: true });
                  }}
                >
                  {preset.shortTitle}
                </button>
              );
            })}
          </div>

          <article id="featured-chart-panel" className="editorial-panel space-y-4">
            <div>
              <p className="mono-label">Question</p>
              <h2 id="featured-chart-heading" className="mt-1 text-[1.35rem] leading-tight font-['Fraunces',Georgia,serif]">
                {selectedPreset.question}
              </h2>
            </div>

            {featuredQuery.loading && lastFeaturedRows.length === 0 ? (
              <LoadingSkeleton variant="panel" phase={phase} title="Loading featured chart..." />
            ) : null}

            {featuredQuery.error ? <p className="alert alert--error">{featuredQuery.error}</p> : null}

            {!featuredQuery.error ? (
              <>
                <div className={`h-[360px] w-full transition-opacity ${featuredQuery.loading ? "opacity-70" : "opacity-100"}`}>
                  {renderFeaturedChart(
                    selectedPreset,
                    featuredQuery.loading && lastFeaturedRows.length > 0 ? lastFeaturedRows : featuredRows,
                  )}
                </div>
                {featuredQuery.loading && lastFeaturedRows.length > 0 ? (
                  <p className="mono-value text-[var(--ink-faded)]">Updating chart...</p>
                ) : null}
              </>
            ) : null}

            <div className="space-y-2">
              <p>{selectedPreset.caption}</p>
              {!featuredSampleQuery.loading && featuredSampleSize > 0 ? (
                <p className="mono-value text-[var(--ink-faded)]">Sample size: N = {formatNumber(featuredSampleSize)}</p>
              ) : null}
              {selectedPreset.wave2 ? (
                <p className="mono-value text-[var(--ink-faded)]">
                  Confidence: {selectedPreset.wave2.evidenceTier === "robust" ? "high" : selectedPreset.wave2.evidenceTier === "supported" ? "moderate" : selectedPreset.wave2.evidenceTier === "tiny" ? "low" : "preliminary"}.
                </p>
              ) : null}
            </div>

            <Link
              to="/explore/crosstab"
              search={{ x: selectedPreset.exploreX, y: selectedPreset.exploreY }}
              className="editorial-button"
            >
              Explore this further
            </Link>
          </article>
        </section>
      ) : null}

      <section className="editorial-panel space-y-4">
        <SectionHeader number="02" title="Build your own chart" />
        <p>Choose two questions and see a quick comparison.</p>

        {schema ? (
          <>
            <div className="grid gap-4 lg:grid-cols-3">
              <label className="editorial-label">
                X question
                <ColumnCombobox
                  columns={schema.columns}
                  value={buildX}
                  onValueChange={setBuildX}
                  placeholder="Choose X"
                />
              </label>

              <label className="editorial-label">
                Y question
                <ColumnCombobox
                  columns={schema.columns}
                  value={buildY}
                  onValueChange={setBuildY}
                  placeholder="Choose Y"
                />
              </label>

              <label className="editorial-label">
                Chart type
                <Select value={buildType} onValueChange={(value) => setBuildType(value as BuilderType)}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {BUILDER_TYPES.map((option) => (
                      <SelectItem key={option.value} value={option.value}>
                        {option.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </label>
            </div>

            {buildQuery.loading ? (
              <LoadingSkeleton variant="panel" phase={phase} title="Running chart query..." />
            ) : null}
            {buildQuery.error ? <p className="alert alert--error">{buildQuery.error}</p> : null}

            {!buildQuery.loading && !buildQuery.error ? (
              <div className="h-[320px] w-full border border-[var(--rule)] bg-[var(--paper)] p-2">
                {buildType === "line" ? (
                  <SimpleLineChart
                    data={buildRows}
                    xLabel={buildXMeta?.displayName ?? buildX}
                    yLabel={buildYMeta?.displayName ?? buildY}
                    height={300}
                  />
                ) : (
                  <SimpleBarChart
                    data={buildRows}
                    xLabel={buildXMeta?.displayName ?? buildX}
                    yLabel={buildYMeta?.displayName ?? buildY}
                    height={300}
                  />
                )}
              </div>
            ) : null}

            <Link to="/explore/crosstab" search={{ x: buildX || undefined, y: buildY || undefined }} className="editorial-button">
              Open this in Explore
            </Link>
          </>
        ) : (
          <LoadingSkeleton variant="panel" phase={phase} title="Loading columns for chart builder..." />
        )}
      </section>

```

File: /Users/austin/dev/kink/src/components/loading-skeleton.tsx
(lines 1-68)
```tsx
import type { DuckDBInitPhase } from "@/lib/duckdb/init";

type LoadingSkeletonVariant = "stat-grid" | "table" | "panel";

interface LoadingSkeletonProps {
  variant?: LoadingSkeletonVariant;
  phase: DuckDBInitPhase;
  title?: string;
}

const phaseLabel: Record<DuckDBInitPhase, string> = {
  idle: "Waiting to initialize DuckDB",
  "downloading-wasm": "Downloading DuckDB WASM",
  initializing: "Initializing DuckDB runtime",
  "loading-parquet": "Loading parquet dataset",
  ready: "Ready",
};

export function LoadingSkeleton({
  variant = "panel",
  phase,
  title = "Loading...",
}: LoadingSkeletonProps) {
  if (variant === "stat-grid") {
    return (
      <div className="space-y-3">
        <p className="mono-label">{title}</p>
        <div className="stat-grid grid-cols-1 md:grid-cols-3 animate-pulse">
          {[0, 1, 2].map((index) => (
            <div key={index} className="stat-cell">
              <div className="h-3 w-24 bg-[var(--rule-light)]" />
              <div className="mt-3 h-8 w-20 bg-[var(--rule)]" />
              <div className="mt-2 h-3 w-28 bg-[var(--rule-light)]" />
            </div>
          ))}
        </div>
        <p className="section-subtitle">{phaseLabel[phase]}</p>
      </div>
    );
  }

  if (variant === "table") {
    return (
      <div className="space-y-3">
        <p className="mono-label">{title}</p>
        <div className="border border-[var(--rule)] bg-[var(--paper)] p-3 animate-pulse">
          {[0, 1, 2, 3, 4].map((index) => (
            <div key={index} className="mb-2 h-4 w-full bg-[var(--rule-light)] last:mb-0" />
          ))}
        </div>
        <p className="section-subtitle">{phaseLabel[phase]}</p>
      </div>
    );
  }

  return (
    <div className="space-y-3">
      <p className="mono-label">{title}</p>
      <div className="border border-[var(--rule)] bg-[var(--paper)] p-4 animate-pulse">
        <div className="h-4 w-1/3 bg-[var(--rule-light)]" />
        <div className="mt-3 h-3 w-full bg-[var(--rule-light)]" />
        <div className="mt-2 h-3 w-5/6 bg-[var(--rule-light)]" />
        <div className="mt-2 h-3 w-2/3 bg-[var(--rule-light)]" />
      </div>
      <p className="section-subtitle">{phaseLabel[phase]}</p>
    </div>
  );
}

```

File: /Users/austin/dev/kink/design-mockups/01-ink-and-paper.html
(lines 1-590)
```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Direction 1: Ink & Paper — Editorial Research</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fraunces:ital,opsz,wght@0,9..144,300;0,9..144,400;0,9..144,600;0,9..144,700;1,9..144,400&family=Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;1,8..60,400&family=JetBrains+Mono:wght@400;500&display=swap');

  :root {
    --paper: #f5f0e8;
    --paper-warm: #ede6d8;
    --ink: #1a1612;
    --ink-light: #4a4238;
    --ink-faded: #8a7e70;
    --rule: #c8bfb0;
    --rule-light: #ddd5c8;
    --accent: #b8432f;
    --accent-hover: #9a3625;
    --highlight: #e8d5a0;
    --sidebar-bg: #eae3d5;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--paper);
    color: var(--ink);
    font-family: 'Source Serif 4', Georgia, serif;
    font-size: 16px;
    line-height: 1.6;
    -webkit-font-smoothing: antialiased;
  }

  /* Subtle paper texture */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: url("data:image/svg+xml,%3Csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.75' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.03'/%3E%3C/svg%3E");
    pointer-events: none;
    z-index: 1000;
  }

  /* ---- NAVIGATION ---- */
  nav {
    border-bottom: 2px solid var(--ink);
    padding: 0 2rem;
  }

  .nav-inner {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    align-items: baseline;
    gap: 2.5rem;
    padding: 1rem 0 0.75rem;
  }

  .nav-title {
    font-family: 'Fraunces', serif;
    font-weight: 700;
    font-size: 1.5rem;
    letter-spacing: -0.02em;
    color: var(--ink);
    text-decoration: none;
  }

  .nav-title span {
    font-weight: 300;
    font-style: italic;
    font-size: 0.9rem;
    color: var(--ink-faded);
    margin-left: 0.5rem;
  }

  .nav-links {
    display: flex;
    gap: 0;
    margin-left: auto;
  }

  .nav-links a {
    font-family: 'Source Serif 4', serif;
    font-size: 0.85rem;
    font-weight: 400;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    color: var(--ink-faded);
    text-decoration: none;
    padding: 0.5rem 1.25rem 0.6rem;
    border-bottom: 2px solid transparent;
    margin-bottom: -2px;
    transition: all 0.2s;
  }

  .nav-links a:hover { color: var(--ink); }
  .nav-links a.active {
    color: var(--accent);
    border-bottom-color: var(--accent);
    font-weight: 600;
  }

  /* ---- MAIN LAYOUT ---- */
  main {
    max-width: 1200px;
    margin: 0 auto;
    padding: 3rem 2rem 4rem;
  }

  /* ---- HEADER ---- */
  .page-header {
    margin-bottom: 3rem;
    border-bottom: 1px solid var(--rule);
    padding-bottom: 1.5rem;
  }

  .page-header h1 {
    font-family: 'Fraunces', serif;
    font-weight: 700;
    font-size: 2.75rem;
    letter-spacing: -0.03em;
    line-height: 1.1;
    color: var(--ink);
  }

  .page-header .subtitle {
    font-family: 'Source Serif 4', serif;
    font-style: italic;
    font-size: 1.1rem;
    color: var(--ink-faded);
    margin-top: 0.5rem;
  }

  .page-header .dateline {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--ink-faded);
    margin-top: 0.75rem;
  }

  /* ---- STAT CARDS (top row) ---- */
  .stats-row {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 0;
    border: 1px solid var(--ink);
    margin-bottom: 3rem;
  }

  .stat-card {
    padding: 1.5rem 2rem;
    border-right: 1px solid var(--rule);
    position: relative;
  }

  .stat-card:last-child { border-right: none; }

  .stat-card .label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--ink-faded);
    margin-bottom: 0.5rem;
  }

  .stat-card .value {
    font-family: 'Fraunces', serif;
    font-weight: 700;
    font-size: 2.5rem;
    letter-spacing: -0.03em;
    color: var(--ink);
    line-height: 1;
  }

  .stat-card .note {
    font-size: 0.8rem;
    color: var(--ink-faded);
    margin-top: 0.3rem;
    font-style: italic;
  }

  /* ---- TWO-COLUMN BODY ---- */
  .two-col {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 3rem;
    margin-bottom: 3rem;
  }

  .section-header {
    font-family: 'Fraunces', serif;
    font-weight: 600;
    font-size: 1.2rem;
    color: var(--ink);
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--rule);
    display: flex;
    align-items: baseline;
    gap: 0.75rem;
  }

  .section-header .number {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.65rem;
    color: var(--accent);
    letter-spacing: 0.05em;
  }

  /* ---- CAVEATS ---- */
  .caveat-item {
    padding: 1rem 0;
    border-bottom: 1px solid var(--rule-light);
  }

  .caveat-item:last-child { border-bottom: none; }

  .caveat-title {
    font-family: 'Source Serif 4', serif;
    font-weight: 600;
    font-size: 0.95rem;
    color: var(--ink);
    margin-bottom: 0.25rem;
  }

  .caveat-desc {
    font-size: 0.85rem;
    color: var(--ink-light);
    line-height: 1.5;
  }

  .caveat-guidance {
    font-size: 0.75rem;
    font-style: italic;
    color: var(--ink-faded);
    margin-top: 0.35rem;
  }

  /* ---- TABLE ---- */
  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.85rem;
  }

  thead th {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--ink-faded);
    text-align: left;
    padding: 0.5rem 0;
    border-bottom: 2px solid var(--ink);
  }

  tbody td {
    padding: 0.6rem 0;
    border-bottom: 1px solid var(--rule-light);
    color: var(--ink-light);
  }

  tbody td:first-child {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.8rem;
    color: var(--ink);
  }

  tbody td:last-child {
    font-family: 'JetBrains Mono', monospace;
    text-align: right;
  }

  .bar-cell {
    position: relative;
  }

  .bar-fill {
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    height: 4px;
    background: var(--accent);
    opacity: 0.3;
    border-radius: 2px;
  }

  /* ---- COLUMN STATS SECTION ---- */
  .stats-section {
    border: 1px solid var(--rule);
    padding: 2rem;
    background: var(--sidebar-bg);
    position: relative;
  }

  .stats-section::before {
    content: '';
    position: absolute;
    top: -1px;
    left: 2rem;
    right: 2rem;
    height: 3px;
    background: var(--accent);
  }

  .select-wrapper {
    position: relative;
    display: inline-block;
  }

  .select-wrapper select {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.8rem;
    padding: 0.5rem 2rem 0.5rem 0.75rem;
    border: 1px solid var(--rule);
    background: var(--paper);
    color: var(--ink);
    appearance: none;
    cursor: pointer;
    border-radius: 0;
  }

  .select-wrapper::after {
    content: '\25BE';
    position: absolute;
    right: 0.75rem;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
    color: var(--ink-faded);
    font-size: 0.7rem;
  }

  .mini-stats {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 1px;
    background: var(--rule);
    margin-top: 1.5rem;
  }

  .mini-stat {
    background: var(--paper);
    padding: 1rem;
  }

  .mini-stat .label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.6rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--ink-faded);
  }

  .mini-stat .val {
    font-family: 'Fraunces', serif;
    font-weight: 600;
    font-size: 1.4rem;
    color: var(--ink);
    margin-top: 0.25rem;
  }

  /* Categorical table inside stats */
  .cat-table {
    margin-top: 1.5rem;
  }

  .cat-row {
    display: grid;
    grid-template-columns: 1fr 80px 60px;
    gap: 1rem;
    padding: 0.5rem 0;
    border-bottom: 1px solid var(--rule-light);
    align-items: center;
    font-size: 0.85rem;
  }

  .cat-row:first-child {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.6rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--ink-faded);
    border-bottom: 2px solid var(--ink);
  }

  .cat-label { color: var(--ink); }
  .cat-count { text-align: right; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; color: var(--ink-light); }
  .cat-pct { text-align: right; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; color: var(--accent); font-weight: 500; }

  /* ---- FOOTER ---- */
  footer {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
    border-top: 2px solid var(--ink);
    font-size: 0.75rem;
    color: var(--ink-faded);
    display: flex;
    justify-content: space-between;
  }

  /* ---- ANNOTATION ---- */
  .design-note {
    position: fixed;
    top: 0.75rem;
    right: 0.75rem;
    background: var(--accent);
    color: white;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.6rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    padding: 0.4rem 0.75rem;
    z-index: 9999;
  }

  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(12px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .fade-up { animation: fadeUp 0.6s ease-out both; }
  .fade-up-1 { animation-delay: 0.1s; }
  .fade-up-2 { animation-delay: 0.2s; }
  .fade-up-3 { animation-delay: 0.3s; }
  .fade-up-4 { animation-delay: 0.4s; }
</style>
</head>
<body>
  <div class="design-note">Direction 1 — Ink & Paper</div>

  <nav>
    <div class="nav-inner">
      <a class="nav-title" href="#">Big Kink Survey <span>Explorer</span></a>
      <div class="nav-links">
        <a href="#" class="active">Dashboard</a>
        <a href="#">Explore</a>
        <a href="#">Profile</a>
        <a href="#">SQL</a>
      </div>
    </div>
  </nav>

  <main>
    <div class="page-header fade-up">
      <h1>Dataset Dashboard</h1>
      <p class="subtitle">A stratified 1.6% subsample of 980,000 survey responses on human sexuality, personality, and identity.</p>
      <p class="dateline">Schema profiled Feb 12, 2026 &middot; DuckDB + Parquet</p>
    </div>

    <div class="stats-row fade-up fade-up-1">
      <div class="stat-card">
        <div class="label">Respondents</div>
        <div class="value">15,503</div>
        <div class="note">stratified subsample</div>
      </div>
      <div class="stat-card">
        <div class="label">Variables</div>
        <div class="value">365</div>
        <div class="note">251 categorical &middot; 52 numeric &middot; 62 text</div>
      </div>
      <div class="stat-card">
        <div class="label">Coverage</div>
        <div class="value">5</div>
        <div class="note">domains: demographic, fetish, OCEAN, derived, other</div>
      </div>
    </div>

    <div class="two-col fade-up fade-up-2">
      <div>
        <div class="section-header">
          <span class="number">01</span> Global Caveats
        </div>
        <div class="caveat-item">
          <div class="caveat-title">Gated Missingness</div>
          <div class="caveat-desc">Some questions were only shown after prerequisite answers. Missing values may reflect skip-logic, not non-response.</div>
          <div class="caveat-guidance">Filter or impute with care when analyzing columns with structural NAs.</div>
        </div>
        <div class="caveat-item">
          <div class="caveat-title">Late-Added Questions</div>
          <div class="caveat-desc">Certain variables were added partway through the survey's collection period, creating cohort-dependent missingness.</div>
          <div class="caveat-guidance">Consider temporal bias when interpreting null rates above 30%.</div>
        </div>
      </div>

      <div>
        <div class="section-header">
          <span class="number">02</span> Highest Missingness
        </div>
        <table>
          <thead>
            <tr>
              <th>Column</th>
              <th style="text-align:right">Null Ratio</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>HRT_estrogen_regularity</td><td class="bar-cell" style="text-align:right">96.2%<div class="bar-fill" style="width:96%"></div></td></tr>
            <tr><td>HRT_estrogen_duration</td><td style="text-align:right">96.0%</td></tr>
            <tr><td>HRT_testosterone_regularity</td><td style="text-align:right">95.8%</td></tr>
            <tr><td>HRT_testosterone_duration</td><td style="text-align:right">95.7%</td></tr>
            <tr><td>PMS_symptoms</td><td style="text-align:right">52.1%</td></tr>
            <tr><td>menstrual_cycle_phase</td><td style="text-align:right">51.8%</td></tr>
            <tr><td>hormonal_birth_control</td><td style="text-align:right">51.3%</td></tr>
            <tr><td>childhood_adversity</td><td style="text-align:right">12.4%</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="stats-section fade-up fade-up-3">
      <div style="display:flex; justify-content:space-between; align-items:baseline;">
        <div class="section-header" style="border:none; margin:0; padding:0;">
          <span class="number">03</span> Column Inspector
        </div>
        <div class="select-wrapper">
          <select>
            <option>straightness</option>
            <option>politics</option>
            <option>gender_identity</option>
            <option>opennessvariable</option>
          </select>
        </div>
      </div>

      <div class="mini-stats">
        <div class="mini-stat">
          <div class="label">Type</div>
          <div class="val" style="font-size:1rem">Categorical</div>
        </div>
        <div class="mini-stat">
          <div class="label">Total</div>
          <div class="val">15,503</div>
        </div>
        <div class="mini-stat">
          <div class="label">Non-null</div>
          <div class="val">15,466</div>
        </div>
        <div class="mini-stat">
          <div class="label">Null</div>
          <div class="val">37</div>
        </div>
      </div>

      <div class="cat-table">
        <div class="cat-row">
          <span>Value</span>
          <span style="text-align:right">Count</span>
          <span style="text-align:right">Share</span>
        </div>
        <div class="cat-row">
          <span class="cat-label">Straight</span>
          <span class="cat-count">5,412</span>
          <span class="cat-pct">34.9%</span>
        </div>
        <div class="cat-row">
          <span class="cat-label">Mostly Straight</span>
          <span class="cat-count">3,821</span>
          <span class="cat-pct">24.7%</span>
        </div>
        <div class="cat-row">
          <span class="cat-label">Bisexual</span>
          <span class="cat-count">3,104</span>
          <span class="cat-pct">20.0%</span>
        </div>
        <div class="cat-row">
          <span class="cat-label">Mostly Gay</span>
          <span class="cat-count">1,890</span>
          <span class="cat-pct">12.2%</span>
        </div>
        <div class="cat-row">
          <span class="cat-label">Gay</span>
          <span class="cat-count">1,239</span>
          <span class="cat-pct">8.0%</span>
        </div>
      </div>
    </div>
  </main>

  <footer>
    <span>Big Kink Survey &middot; Public Sample &middot; 2026</span>
    <span>DuckDB + TanStack Start</span>
  </footer>
</body>
</html>

```

File: /Users/austin/dev/kink/docs/plans/active/ux-excellence.md
(lines 1-173)
```md
# UX Excellence Plan — BKS Explorer

**Status:** Implemented in code on 2026-02-13.

## Implementation Status

- [x] Phase 1: "Other" pivot cell SQL fix
- [x] Phase 2A: Value labels surfaced across Explore/Profile/Dashboard/Pivot Matrix
- [x] Phase 2B: `displayName` added to schema metadata, API contracts, and UI selectors
- [x] Phase 3: Searchable column combobox implemented and integrated
- [x] Phase 4A: URL state completed for Explore, Profile, and Relationships
- [x] Phase 4B: Notebook entries now store and render source URLs
- [x] Phase 5A: "Uniqueness Percentile" renamed to "Cohort Rarity" with explanatory note
- [x] Phase 5B: Dashboard "Updated" date now uses dataset metadata timestamp
- [x] Phase 5C: Cross-page navigation links added (Dashboard, Column Inspector, About examples)
- [x] Phase 5D: DuckDB init phases + loading skeleton component integrated

## Context

A UX review of the production site identified 10 improvement areas. Two were excluded by the user (privacy mode and SQL safe mode — anyone exploring this data knows what they're doing). Small-cell suppression was already removed in a prior change. This plan covers the remaining 8 improvements, grouped into 5 phases ordered by impact: correctness, readability, shareability, polish.

---

## Phase 1: Fix "Other" Pivot Cell Broken SQL

**Problem:** Clicking an "Other" cell in the pivot matrix generates `WHERE col = 'Other'` — which matches nothing because "Other" is a synthetic UI bucket, not a real data value. Users click, get zero results, lose trust.

**Files:**
- `src/components/pivot-matrix.tsx` — extend `PivotCellDetail` to carry bucket metadata
- `src/routes/explore.tsx` — fix SQL generation in `sqlForCell` useMemo (lines 286-311)

**Changes:**
1. Add `xIsOther`, `yIsOther`, `topXValues`, `topYValues` fields to `PivotCellDetail` interface
2. Populate them in the cell click handler (pivot-matrix.tsx lines 168-178) — the `topX`/`topY` arrays already exist at line 84-85
3. In explore.tsx `sqlForCell`, when `xIsOther` is true, generate `NOT IN (topValues...)` + `IS NOT NULL` instead of `= 'Other'`; same for y axis

**Verify:** Select a cross-tab with more categories than topN, click an "Other" cell, confirm SQL produces valid results.

---

## Phase 2: Value Labels + Column Display Names

### 2A: Value Labels Everywhere

**Problem:** 60+ columns have human-readable value labels (e.g., `5 → "Extremely arousing"`) defined in `src/lib/schema/value-labels.ts`, but they only render in Column Inspector. Everywhere else shows raw numeric codes.

**Files:**
- New: `src/lib/format-labels.ts` — extract `formatValueWithLabel()` + `candidateValueKeys()` from column-inspector.tsx:52-65
- `src/components/column-inspector.tsx` — import from shared utility instead of inline
- `src/components/pivot-matrix.tsx` — accept optional `xValueLabels`/`yValueLabels` props, format headers and row labels
- `src/routes/explore.tsx` — format filter checkboxes (line 472), DataTable fallback (line 544), selected cell display
- `src/routes/profile.tsx` — format value selector options (line 580), over-indexing "Value" column (line 808)
- `src/routes/index.tsx` — format dashboard categorical top values (lines 447-465)

### 2B: Column Display Names

**Problem:** Dropdowns show raw column names like `"I am aroused by being dominant in sexual interactions" (6w3xquw)` — long, ugly, unscannable.

**Files:**
- `src/lib/schema/types.ts` — add `displayName?: string` to `ColumnMetadata`
- `src/lib/api/contracts.ts` — add `displayName: z.string().optional()` to schema
- `scripts/profile-schema.mjs` — generate display names:
  - Quoted strings `"<text>" (<id>)` → extract just the text, truncate ~60 chars
  - Simple identifiers (`straightness`) → title-case (`Straightness`)
- `src/lib/format-labels.ts` — add `getColumnDisplayName(column)` returning `displayName ?? name`
- All dropdown sites: explore.tsx (lines 365, 382, 400), profile.tsx (line 553), relationships.tsx (line 90), index.tsx (line 396)

**Verify:** Run `pnpm profile-schema`, confirm `columns.generated.json` has `displayName` fields. Check dropdowns show short names.

---

## Phase 3: Searchable Column Combobox

**Problem:** Plain `<Select>` dropdowns with 365 items and no search. Painful to find a specific column.

**Files:**
- New: `src/components/column-combobox.tsx`
- Replace `<Select>` in: explore.tsx (X/Y/filter selectors), profile.tsx (field selectors), relationships.tsx (target column), index.tsx (column inspector selector)

**Design:**
- Trigger button styled like existing `<SelectTrigger>` (Ink & Paper: no border-radius, bordered)
- Opens a dropdown with `<Input>` search + `<ScrollArea>` button list (same pattern as sql.tsx:268-289)
- Each item shows `displayName` primary, `column.name` secondary in faded mono text
- Click selects and closes; keyboard nav with arrow keys + Enter
- Depends on Phase 2B for display names (can use `column.name` as fallback if 2B not done)

**Verify:** Open Explore, search for "straight" in X column combobox, confirm it filters and selects correctly.

---

## Phase 4: URL State + Notebook URL

### 4A: Complete URL State

**Current coverage:**
- Explore: has `x`, `y` only — **missing** `normalization`, `topN`, `filterColumn`, `filterValues`
- Columns: complete
- SQL: complete
- Profile: **no URL state**
- Relationships: **no URL state**

**Pattern:** TanStack Router `validateSearch` + `useNavigate({ replace: true })` — same as columns.tsx:21-28, 59-68.

**Files & URL params:**
- `src/routes/explore.tsx` — extend `validateSearch` to include `normalization`, `topN`, `filterColumn`, `filterValues` (comma-separated). Init state from params. Sync back on change.
- `src/routes/profile.tsx` — add `validateSearch` with `mode`, filter slot columns (`c0`/`c1`/`c2`) and values (`v0`/`v1`/`v2`), comparison slots (`ac0`-`ac2`/`av0`-`av2`, `bc0`-`bc2`/`bv0`-`bv2`). Init from params, sync back.
- `src/routes/relationships.tsx` — add `validateSearch` with `column`. Init `selectedColumn` from param.

### 4B: Notebook Stores URL

**Files:**
- `src/lib/notebook-store.ts` — add `sourceUrl?: string` to `NotebookEntry`
- `src/routes/explore.tsx`, `profile.tsx`, `sql.tsx` — pass current URL in `addNotebookEntry()` calls
- `src/routes/notebook.tsx` — render sourceUrl as a clickable link per entry

**Verify:** Set up an Explore cross-tab with filters, copy URL, open in new tab, confirm it restores. Save to notebook, confirm notebook entry has clickable link back.

---

## Phase 5: Polish

### 5A: Rename "Uniqueness Percentile" → "Cohort Rarity" (~5 lines)
- `src/routes/profile.tsx` line 759: change `label="Uniqueness Percentile"` → `label="Cohort Rarity"`
- Add explanatory note: `"100% minus cohort share"`
- Rename variable `uniquenessPercentile` → `cohortRarity` + update `ProfileSummary` interface

### 5B: Fix Dashboard Date (~3 lines)
- `src/routes/index.tsx` line 232: replace `new Date().toLocaleDateString()` with `schema.dataset.generatedAt` date
- Move inside the `{schema ? ...}` conditional

### 5C: Cross-Page Navigation (~40 lines)
- **Dashboard** (index.tsx): make "Most Analysis-Friendly Columns" names link to `/explore?x={name}`
- **Column Inspector** (column-inspector.tsx): add "Related Columns" section using `relationships.generated.json` — show top 3, link to `/relationships?column={name}`
- **About** (about.tsx): add 2-3 "Try this" example links (e.g., `/explore?x=straightness&y=politics`)

### 5D: Loading Skeletons (~100 lines)
- `src/lib/duckdb/init.ts` — add phase callback to `createDb()`: idle → downloading-wasm → initializing → loading-parquet → ready
- `src/lib/duckdb/provider.tsx` — expose `phase` in context value
- New: `src/components/loading-skeleton.tsx` — skeleton variants (stat-grid, table, panel) with `animate-pulse`, Ink & Paper styling
- Replace all "Loading schema metadata..." strings across route files with `<LoadingSkeleton>` + phase label

**Verify:** Hard-refresh the app, confirm skeletons appear with phase text instead of plain "Loading..." strings. Confirm phases transition correctly.

---

## Phase Dependencies

```
Phase 1 (Other cell fix) ──── independent, ship first
Phase 2A (value labels)  ──── independent
Phase 2B (display names) ──── independent, requires pnpm profile-schema
Phase 3 (combobox)       ──── benefits from 2B (uses displayName)
Phase 4A (URL state)     ──── independent
Phase 4B (notebook URL)  ──── depends on 4A
Phase 5A-5B              ──── independent, trivial
Phase 5C (cross-links)   ──── benefits from 4A (URL params in links)
Phase 5D (loading)       ──── independent
```

## Verification Plan

After each phase:
1. `pnpm check-types` — types pass
2. `pnpm test --run` — all tests pass
3. `pnpm dev` — manual smoke test of affected pages
4. After all phases: `pnpm build` + deploy to Railway, verify prod

## Verification Results (2026-02-13)

- `pnpm check-types` — pass
- `pnpm test --run` — pass (130 tests)
- `pnpm build` — pass
- Manual `pnpm dev` and Railway deploy verification remain as follow-up runtime checks

```
</file_contents>
<user_instructions>
You are designing a full UX revamp plan for the BKS Explorer surfaces scoped by `docs/plans/active/v5-user-feedback-ux.md`, using the existing Ink & Paper visual language and current tech stack.

Primary goal
- Devise a concrete, implementation-ready solution (architecture + file-by-file plan) for a full redesign of the target experience, with special focus on:
  1) `/relationships` disambiguation and relevance
  2) `/profile` sections 03/04 visual overhaul
  3) `/profile` compare mode clarity
  4) narrative layout improvements without breaking current behavior

Interpretation rule
- If “design page” is ambiguous, infer target from v5 feedback scope and current routes (`/profile`, `/relationships`) and call out that assumption explicitly.

Non-negotiable constraints
- Preserve existing data logic and correctness in `src/routes/profile.tsx` and `src/routes/relationships.tsx` unless changes are required for UX goals.
- Preserve query-param URL state behavior and compare/single mode behavior.
- Keep tables available as secondary detail views when charts become primary.
- Use current visual language from:
  - `docs/design/frontend.md`
  - `src/styles.css`
  - `design-mockups/01-ink-and-paper.html`
- Stay in current stack: TanStack Start + React + Tailwind v4 + Recharts + DuckDB-WASM.

What to produce
1) A proposed end-state UX for `/profile` and `/relationships`:
   - section structure
   - chart-first information hierarchy
   - single vs compare behavior
   - disambiguation strategy for duplicate question display names
2) Technical approach mapped to real files/components:
   - what to add, modify, or split
   - suggested new components/hooks/types
   - schema/data changes if needed (e.g., top answer values)
3) A phased implementation plan (small, shippable phases), ordered by risk and dependency.
4) A QA checklist and manual validation matrix for:
   - single cohort flows
   - compare flows
   - relationships link-through to `/explore/crosstab`
   - responsiveness and accessibility
5) Risks/tradeoffs and fallback paths.

Design-system fidelity requirements
- Follow Ink & Paper principles: square edges, serif+mono typography system, accent restraint, rule-based hierarchy, no gradient/neon/shadow styling drift.
- Reuse and extend existing primitives where possible (`SectionHeader`, `StatCard`, `DataTable`, chart components).

Important context to use
- Current profile/relationships implementations and style system are included.
- Existing chart usage patterns on home (`src/routes/index.tsx`) should inform profile visuals.
- Historical UX context in `docs/plans/active/ux-excellence.md` can be used to avoid regressions.

Output format
- Provide:
  A) Executive summary
  B) End-state UX blueprint (by section)
  C) File-by-file implementation plan
  D) Phase plan with acceptance criteria
  E) QA matrix
  F) Open questions that need product decisions
</user_instructions>
