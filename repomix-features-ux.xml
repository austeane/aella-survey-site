This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: CLAUDE.md, repomix-notes.md, package.json, vite.config.ts, tsconfig.json, src/router.tsx, src/routes/__root.tsx, src/routes/index.tsx, src/routes/explore.tsx, src/routes/profile.tsx, src/routes/columns.tsx, src/routes/relationships.tsx, src/routes/sql.tsx, src/routes/notebook.tsx, src/components/column-inspector.tsx, src/components/pivot-matrix.tsx, src/components/data-table.tsx, src/components/stat-card.tsx, src/components/section-header.tsx, src/components/sample-size-display.tsx, src/components/missingness-badge.tsx, src/lib/api/contracts.ts, src/lib/client/api.ts, src/lib/duckdb/init.ts, src/lib/duckdb/provider.tsx, src/lib/duckdb/use-query.ts, src/lib/duckdb/sql-helpers.ts, src/lib/schema/types.ts, src/lib/schema/metadata.ts, src/lib/schema/caveats.ts, src/lib/schema/value-labels.ts, src/lib/notebook-store.ts, src/lib/utils.ts, docs/design/frontend.md, docs/design/architecture.md, docs/plans/active/v2-next-steps.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
BKS Explorer — Features, UX & Big Picture

This repomix focuses on the user-facing application: routes (pages), components, schema/data libs, design system, and architectural context. Server internals, tests, generated files, and raw data are excluded — see repomix-notes.md for summaries of excluded content.
</user_provided_header>

<directory_structure>
docs/
  design/
    architecture.md
    frontend.md
  plans/
    active/
      v2-next-steps.md
src/
  components/
    column-inspector.tsx
    data-table.tsx
    missingness-badge.tsx
    pivot-matrix.tsx
    sample-size-display.tsx
    section-header.tsx
    stat-card.tsx
  lib/
    api/
      contracts.ts
    client/
      api.ts
    duckdb/
      init.ts
      provider.tsx
      sql-helpers.ts
      use-query.ts
    schema/
      caveats.ts
      metadata.ts
      types.ts
      value-labels.ts
    notebook-store.ts
    utils.ts
  routes/
    __root.tsx
    columns.tsx
    explore.tsx
    index.tsx
    notebook.tsx
    profile.tsx
    relationships.tsx
    sql.tsx
  router.tsx
CLAUDE.md
package.json
repomix-notes.md
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/lib/schema/value-labels.ts">
type ValueLabels = Record<string, string>;

const AROUSAL_SCALE_0_TO_5: ValueLabels = {
  "0": "Not arousing",
  "1": "Slightly arousing",
  "2": "Somewhat arousing",
  "3": "Moderately arousing",
  "4": "Very arousing",
  "5": "Extremely arousing",
};

const VANILLA_AROUSAL_NEGATED: ValueLabels = {
  "0": "Not arousing",
  "-1": "Slightly arousing",
  "-2": "Somewhat arousing",
  "-3": "Moderately arousing",
  "-5": "Very arousing",
  "-8": "Extremely arousing",
};

const AGREEMENT_SCALE: ValueLabels = {
  "3": "Totally agree",
  "2": "Agree",
  "1": "Somewhat agree",
  "0": "Neutral",
  "-1": "Somewhat disagree",
  "-2": "Disagree",
  "-3": "Totally disagree",
};

const VANILLA_COLUMNS = new Set<string>([
  "normalsex",
  "cunnilingus",
  '"I find blowjobs:" (yuc275j)',
  '"I find cunnilingus:" (jn2b355)',
  '"I find dirtytalking erotic" (947wne3)',
]);

const AGREEMENT_COLUMNS = new Set<string>(["supernatural"]);

const AROUSAL_COLUMNS = new Set<string>([
  "abnormalbody",
  "appearance",
  "bestiality",
  "brutality",
  "cgl",
  "clothing",
  "creepy",
  "dirty",
  "eagerness",
  "exhibitionother",
  "exhibitionself",
  "extremebondage",
  "frustration",
  "fulltimepower",
  "futa",
  "genderplay",
  "gentleness",
  "givepain",
  "gratification",
  "humiliation",
  "incest",
  "lightbondage",
  "masterslave",
  "mediumbondage",
  "mentalalteration",
  "mindbreak",
  "multiplepartners",
  "mythical",
  "nonconsent",
  "obedience",
  "objects",
  "oralsexanimal",
  "oralsexanimal2",
  "penetration",
  "penetration2",
  "powerdynamic",
  "pregnancy",
  "progression",
  "receivepain",
  "regression",
  "roles",
  "sadomasochism",
  "secretions",
  "sensory",
  "spanking",
  "teasing",
  "toys",
  "transform",
  "vore",
  "voyeurother",
  "voyeurself",
  "worshipped",
  "worshipping",
  '"I find scenarios where I eagerly beg others to be:" (jvrbyep)',
  '"I find scenarios where others eagerly beg me to be:" (stmm5eg)',
]);

const CUSTOM_VALUE_LABELS: Record<string, ValueLabels> = {
  animated: {
    "-2": "Entirely live action",
    "-1": "Mostly live action",
    "0": "Both equally",
    "1": "Mostly animated",
    "2": "Entirely animated",
  },
  written: {
    "-2": "Entirely visual",
    "-1": "Mostly visual",
    "0": "Both equally",
    "1": "Mostly written",
    "2": "Entirely written",
  },
  violentporn: {
    "0": "None",
    "1": "A little",
    "2": "Moderate",
    "3": "Most",
    "4": "All",
  },
  inducefetish: {
    "0": "No",
    "1": "Variations only",
    "2": "New but similar",
    "3": "New and different",
  },
  allrollidentity: {
    "-2": "Totally one role",
    "-1": "Somewhat one role",
    "1": "Somewhat all roles",
    "2": "Totally all roles",
  },
  highenergy: {
    "-3": "Totally gentle",
    "-2": "Mostly gentle",
    "-1": "Somewhat gentle",
    "0": "Equal",
    "1": "Somewhat intense",
    "2": "Mostly intense",
    "3": "Totally intense",
  },
};

export function getValueLabels(columnName: string): ValueLabels | null {
  if (VANILLA_COLUMNS.has(columnName)) {
    return VANILLA_AROUSAL_NEGATED;
  }

  if (AGREEMENT_COLUMNS.has(columnName)) {
    return AGREEMENT_SCALE;
  }

  if (AROUSAL_COLUMNS.has(columnName)) {
    return AROUSAL_SCALE_0_TO_5;
  }

  return CUSTOM_VALUE_LABELS[columnName] ?? null;
}
</file>

<file path="docs/design/frontend.md">
# Frontend Design System — "Ink & Paper"

Direction: editorial research journal. The UI should feel like a beautifully typeset academic publication — warm, authoritative, and clear. Think NYT data journalism meets a well-set research paper.

## Design Tokens

### Colors (CSS variables)

```css
--paper: #f5f0e8;          /* primary background */
--paper-warm: #ede6d8;      /* secondary/sidebar background */
--ink: #1a1612;             /* primary text */
--ink-light: #4a4238;       /* secondary text */
--ink-faded: #8a7e70;       /* tertiary/muted text */
--rule: #c8bfb0;            /* borders, horizontal rules */
--rule-light: #ddd5c8;      /* subtle dividers */
--accent: #b8432f;          /* emphasis, links, active states */
--accent-hover: #9a3625;    /* accent hover/pressed */
--highlight: #e8d5a0;       /* selection, highlight backgrounds */
--sidebar-bg: #eae3d5;      /* raised panel backgrounds */
```

**Principle**: Dominant warm cream with ink-dark text. Red accent used sparingly — section numbers, active nav, percentage highlights. No gradients. No neon. No purple.

### Typography

| Role | Font | Weight | Size | Tracking |
|---|---|---|---|---|
| Display / H1 | Fraunces | 700 | 2.75rem | -0.03em |
| Section headers | Fraunces | 600 | 1.2rem | normal |
| Body text | Source Serif 4 | 400 | 1rem (16px) | normal |
| Body emphasis | Source Serif 4 | 600 | 0.95rem | normal |
| Subtitle/italic | Source Serif 4 italic | 400 | 1.1rem | normal |
| Data / mono | JetBrains Mono | 400-500 | 0.8rem | normal |
| Labels / caps | JetBrains Mono | 400 | 0.65rem | 0.12em, uppercase |
| Large numbers | Fraunces | 700 | 2.5rem | -0.03em |

**Google Fonts import**:
```
Fraunces:ital,opsz,wght@0,9..144,300;0,9..144,400;0,9..144,600;0,9..144,700;1,9..144,400
Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;1,8..60,400
JetBrains+Mono:wght@400;500
```

**Rules**:
- Never use system fonts, Inter, Roboto, or Arial
- Fraunces for headlines and large numbers only — never body
- Source Serif 4 for all body/paragraph text
- JetBrains Mono for data values, column names, SQL, code, and all-caps labels
- Pair font sizes with appropriate line-height: display 1.1, body 1.6, data 1.4

### Spacing

Base unit: `1rem` (16px). Use multiples: 0.5, 0.75, 1, 1.5, 2, 3.

- Page padding: `3rem 2rem` (top/bottom, left/right)
- Section gaps: `3rem` between major sections
- Card padding: `1.5rem 2rem`
- Table cell padding: `0.6rem 0`
- Max content width: `1200px`, centered

### Borders & Rules

- Primary divider: `2px solid var(--ink)` (nav bottom, section separators)
- Section divider: `1px solid var(--rule)` (between content areas)
- Table header border: `2px solid var(--ink)` bottom
- Table row borders: `1px solid var(--rule-light)` bottom
- Card borders: `1px solid var(--rule)` or `1px solid var(--ink)` for emphasis
- **No border-radius anywhere** — square corners are part of the editorial identity

### Backgrounds & Texture

- Apply a subtle paper noise texture via SVG filter overlay on `body::before` at ~3% opacity
- No solid color cards — use `var(--paper)` base with `var(--sidebar-bg)` for raised panels
- The accent bar on stat sections: a `3px` solid red line above the panel
- No box shadows. Depth comes from borders and background contrast only.

## Component Patterns

### Navigation

- Horizontal bar with `2px solid var(--ink)` bottom border
- Logo: Fraunces 700, 1.5rem. Subtitle in Source Serif italic, faded
- Links: Source Serif 0.85rem, uppercase with 0.06em tracking
- Active state: `var(--accent)` color + `2px` bottom border in accent
- No pills, no background highlights — editorial underline style

### Stat Cards

- Grid row with no gaps, shared `1px solid var(--ink)` outer border
- Internal dividers: `1px solid var(--rule)` between cells
- Label: JetBrains Mono, 0.65rem, uppercase, faded
- Value: Fraunces 700, 2.5rem
- Optional note: Source Serif italic, 0.8rem, faded

### Data Tables

- Full-width, no outer border
- Header: JetBrains Mono, 0.65rem, uppercase, faded. Bottom border `2px solid var(--ink)`
- Rows: `1px solid var(--rule-light)` bottom. No zebra striping
- First column (names): JetBrains Mono, ink color
- Numeric columns: JetBrains Mono, right-aligned
- Optional inline bar: 4px height, accent color at 30% opacity, positioned absolutely

### Section Headers

- Fraunces 600, 1.2rem
- Bottom border: `1px solid var(--rule)`
- Numbered: JetBrains Mono section number in accent color (e.g., "01", "02")
- Use `display: flex; align-items: baseline; gap: 0.75rem;`

### Form Controls (selects, inputs)

- JetBrains Mono, 0.8rem
- `1px solid var(--rule)` border, `var(--paper)` background
- No border-radius
- Custom dropdown arrow via `::after` pseudo-element
- Focus: border-color to `var(--ink)`

### Raised Panels (Column Inspector, etc.)

- Background: `var(--sidebar-bg)`
- Border: `1px solid var(--rule)`
- Top accent bar: `3px solid var(--accent)` via `::before` pseudo-element
- Internal stat grids: `1px` gap with `var(--rule)` background showing through

### Caveats / Callouts

- No background color — just content with rule dividers
- Title: Source Serif 600, 0.95rem
- Body: Source Serif 400, 0.85rem, `var(--ink-light)`
- Guidance: Source Serif italic, 0.75rem, `var(--ink-faded)`

## Animation

- Entrance: `fadeUp` — opacity 0→1, translateY 12px→0, 0.6s ease-out
- Stagger delays: 0.1s increments for sequential sections
- No hover animations on cards (editorial, not SaaS)
- Transitions on nav links: color 0.2s

## Anti-Patterns — Never Do These

- **No dark mode** — this is a light, warm design. The paper IS the identity
- **No border-radius** — square corners everywhere
- **No gradients** — flat colors, borders, and typography create hierarchy
- **No box-shadows** — depth via background contrast and rules
- **No Inter/Roboto/system fonts** — always Fraunces + Source Serif + JetBrains
- **No purple, blue, or neon accents** — only red (`#b8432f`) as accent
- **No pill buttons or rounded chips** — square, bordered elements
- **No emoji or icons in headers** — numbered sections and typography only
- **No card hover lift effects** — this is a journal, not a dashboard

## Reference Mockup

The canonical mockup is at `design-mockups/01-ink-and-paper.html`. Open it in a browser to see the full dashboard rendered in this design system. All implementation should match this aesthetic.
</file>

<file path="docs/plans/active/v2-next-steps.md">
# V2 Next Steps: From Functional to Exceptional

Last updated: 2026-02-12

## 0. Implementation Status (2026-02-12 Execution Pass)

This execution pass implemented a substantial subset of the plan and validated it with code checks, Chrome MCP, and Railway MCP.

### Completed in this pass

- Phase 1 design system rollout across active routes (`/`, `/explore`, `/profile`, `/sql`) including Ink & Paper tokens, typography, paper texture, editorial nav, and square control styling.
- Shared UI/components/utilities:
  - `src/components/stat-card.tsx`
  - `src/components/data-table.tsx`
  - `src/components/section-header.tsx`
  - `src/lib/format.ts`
  - `src/lib/cell-hygiene.ts`
- Selective `shadcn/ui` adoption where generic primitives are the right fit:
  - `Button`, `Input`, `Textarea`, `Select`, `Checkbox`, `Badge`, `Table`
  - Utility: `src/lib/utils.ts`
- Phase 2 core UX:
  - Column Atlas page: `src/routes/columns.tsx`
  - Column Inspector: `src/components/column-inspector.tsx`
  - Missingness lens components and integration: `src/components/missingness-badge.tsx`, `src/components/sample-size-display.tsx`
  - Explore pivot matrix with normalization, marginals, cell drilldown, and Cramer's V: `src/components/pivot-matrix.tsx`, `src/routes/explore.tsx`
  - Dashboard trust panels (tag breakdown, missingness histogram, analysis-friendly and gated columns): `src/routes/index.tsx`
- Phase 3 targeted:
  - Profile cohort guardrails + N display + suppression behavior + over-indexing cards: `src/routes/profile.tsx`
  - SQL templates + click-to-insert quoted identifiers + query metadata bar: `src/routes/sql.tsx`
- Schema/contracts for null meaning:
  - `src/lib/api/contracts.ts`
  - `src/lib/schema/types.ts`
  - `src/lib/schema/null-meaning.ts`
  - `src/lib/schema/metadata.ts`
  - `scripts/profile-schema.mjs`

### Completed in Session 3 (2026-02-12)

- Profile side-by-side cohort comparison (Task 3.3) — single/compare mode toggle, dual cohort analysis, delta table
- Relationship Finder precompute/page (Task 3.4) — Cramer's V + Pearson correlation for 159 columns, `/relationships` page
- Exploration Notebook (Task 4.1) — localStorage CRUD, notebook page, "Add to Notebook" buttons on explore/profile/sql
- URL state sync for Columns page (Task 4.4 partial) — column, search, tags, sort persist in URL
- Nav links updated for /relationships and /notebook
- Deployed to Railway

### Not completed (deferred)

- MCP Service B deploy (Task 4.2)
- Full URL state sync for Profile page (Task 4.4 remaining)

### Verification Evidence

- Local quality gates:
  - `pnpm check-types` passed
  - `pnpm test --run` passed (121 tests)
  - `pnpm lint` passed (0 issues)
  - `pnpm build` passed
- Chrome MCP checks:
  - Verified `/`, `/explore`, `/columns`, `/profile`, `/sql` render with editorial structure and new controls.
  - Executed SQL from UI and verified result rendering + metadata bar (`Rows returned`, `Limit applied`).
  - Verified network font loading and paper texture request path.
- Railway MCP checks:
  - Railway CLI authenticated.
  - Linked project/services resolved (`bks-explorer`, `bks-mcp-server`).
  - Recent deployments listed; both services show successful latest deployment IDs.

> Note: Sections 1-2 below are the original baseline assessment and gap statement prior to this execution pass.

## 1. Current State Assessment

### What's Built (M0-M5 complete)

The BKS Explorer is deployed and functional at https://bks-explorer-production.up.railway.app with:

- **4 UI pages**: Dashboard (`/`), Cross-Tab Explorer (`/explore`), Profile Builder (`/profile`), SQL Console (`/sql`)
- **5 API routes**: `/api/health`, `/api/schema`, `/api/stats/:column`, `/api/crosstab`, `/api/query`
- **DuckDB dual-path**: browser-side DuckDB-WASM for interactive queries + server-side DuckDB CLI (with Node API fallback) for API routes
- **Schema metadata**: 365 columns profiled with logical types, null ratios, cardinality, tags, and caveat keys
- **Caveat model**: 5 caveat types (binned, combined, computed, gated missingness, late-added) mapped per-column
- **MCP server**: Python server with 5 tools (get_schema, get_stats, cross_tabulate, query_data, search_columns)
- **Infrastructure**: Zod contracts, SQL guardrails (read-only, row limits, timeout), typed API envelopes

### What's Misaligned

**UI vs. Design System**: The current UI uses a dark slate theme (`bg-slate-950`, `text-slate-100`, `border-slate-800`, rounded corners, system fonts). The design spec at `docs/design/frontend.md` and mockup at `design-mockups/01-ink-and-paper.html` define a warm, light editorial aesthetic with cream backgrounds, serif typography, square corners, and red accents. Zero design tokens have been applied.

**Feature Depth**: All four pages work but deliver minimal exploration value:
- Dashboard: stat cards + raw table, no visual hierarchy or trust-building context
- Explore: flat crosstab list (ORDER BY count DESC), no pivot matrix, no normalization modes, no association metrics
- Profile: percentile cards for 5 hardcoded numeric metrics, no categorical over-indexing, no cohort comparison, no small-N guardrails
- SQL Console: functional but no templates, no click-to-insert quoted identifiers, no query metadata display

**Missing Features**: Column Atlas, Column Inspector, Missingness Lens, Relationship Finder, Notebook, dashboard recipes — none exist yet.

**Schema Gaps**: No `nullMeaning` field (GATED / LATE_ADDED / NOT_APPLICABLE / UNKNOWN) in column metadata. Caveat keys exist but aren't surfaced in the UI anywhere except the Dashboard caveats panel.

---

## 2. Gap Analysis

### 2.1 Design System Gaps

| Current | Target | Files |
|---------|--------|-------|
| `bg-slate-950` dark background | `--paper: #f5f0e8` cream | `src/routes/__root.tsx`, `src/styles.css` |
| System fonts (apple-system, etc.) | Fraunces + Source Serif 4 + JetBrains Mono | `src/styles.css`, `src/routes/__root.tsx` |
| `rounded-lg`, `rounded-md` | Square corners (no border-radius) | All route files |
| `border-slate-800` dark borders | `--rule: #c8bfb0`, `--ink: #1a1612` borders | All route files |
| No section numbering | Numbered sections in JetBrains Mono accent | All route files |
| Generic nav links | Editorial nav with active underline + uppercase | `src/routes/__root.tsx` |
| No paper texture | SVG noise texture at 3% opacity | `src/styles.css` |

### 2.2 Feature Gaps (from GPT analysis + audit)

| Feature | GPT Rec | Status | Priority |
|---------|---------|--------|----------|
| Missingness Lens (null meaning badges, N displays) | #2 | Completed | High |
| Column Atlas (searchable, filterable column browser) | #3 | Completed | High |
| Column Inspector (per-variable detail panel) | #3 | Completed | High |
| Explore pivot matrix with normalization modes | #4 | Completed | High |
| Explore association strength (Cramer's V) | #4 | Completed | Medium |
| Profile cohort guardrails (small-N warnings) | #5 | Completed | High |
| Profile over-indexing cards | #5 | Completed | Medium |
| Profile side-by-side comparison | #5 | Deferred | Medium |
| Relationship Finder | #6 | Deferred | Medium |
| Exploration Notebook | #7 | Deferred | Low |
| SQL templates / cookbook | #8 | Completed | Medium |
| SQL click-to-insert quoted identifiers | #8 | Completed | Medium |
| Dashboard trust-building recipes | #9 | Completed | Medium |
| Small-cell hygiene (suppress count < 10) | #10 | Partial | High |

### 2.3 Schema Metadata Gaps

Current status after this pass:

- `nullMeaning` is now supported end-to-end in contracts/types/schema metadata derivation.
- `displayName` mapping is still not implemented.
- `description` enrichment is still not implemented.
- `group` sub-tag metadata is still not implemented.

### 2.4 Infrastructure Gaps

- DuckDB provider uses `<DuckDBContext value={...}>` — this works in React 19 (which TanStack Start uses), but should be verified
- No shared formatting utilities (the `asNumber`, `percent`, `formatNumber` helpers are duplicated across 3 route files)
- No reusable data table component
- No reusable stat card component (duplicated in `index.tsx` and `profile.tsx`)

---

## 3. Execution Plan

### Phase 1: Ink & Paper Design System

**Goal**: Transform the app from generic dark dashboard to editorial research journal. This is the foundation — all subsequent feature work builds on these tokens and patterns.

#### Task 1.1: CSS Design Tokens + Font Loading

**Files to modify**: `src/styles.css`, `src/routes/__root.tsx`

1. Replace the system font stack in `src/styles.css` with Google Fonts import for Fraunces, Source Serif 4, and JetBrains Mono
2. Define CSS custom properties matching `docs/design/frontend.md` tokens:
   - `--paper`, `--paper-warm`, `--ink`, `--ink-light`, `--ink-faded`
   - `--rule`, `--rule-light`, `--accent`, `--accent-hover`
   - `--highlight`, `--sidebar-bg`
3. Add paper texture SVG overlay on `body::before` at 3% opacity
4. Set base body styles: `background: var(--paper)`, `color: var(--ink)`, `font-family: 'Source Serif 4'`
5. Configure Tailwind v4 theme extension for the custom color tokens

**Acceptance**: Page background is cream, body text is ink, fonts load correctly, paper texture visible.

#### Task 1.2: Root Layout + Navigation Restyle

**Files to modify**: `src/routes/__root.tsx`

1. Replace `bg-slate-950 text-slate-100` with paper/ink tokens
2. Replace nav `border-b border-slate-800` with `2px solid var(--ink)` bottom border
3. Brand title: Fraunces 700, 1.5rem with italic Source Serif subtitle
4. Nav links: Source Serif 0.85rem, uppercase with `0.06em` tracking
5. Active state: accent color + 2px bottom border (not background highlight)
6. Remove all `rounded-*` classes from layout elements
7. Max content width: 1200px (keep current `max-w-7xl` or adjust)

**Acceptance**: Navigation matches mockup aesthetic. No rounded corners. Active link has red underline.

#### Task 1.3: Dashboard Restyle

**Files to modify**: `src/routes/index.tsx`

1. Page title: Fraunces 700, 2.75rem, -0.03em tracking
2. Stat cards: grid with shared outer border (`1px solid var(--ink)`), internal `1px solid var(--rule)` dividers. Labels in JetBrains Mono uppercase. Values in Fraunces 700, 2.5rem
3. Caveats panel: no background color, title in Source Serif 600, body in Source Serif 400 `--ink-light`, guidance in italic `--ink-faded`
4. Missingness table: header with `2px solid var(--ink)` bottom, rows with `1px solid var(--rule-light)`, column names in JetBrains Mono
5. Column stats section: raised panel with `var(--sidebar-bg)` background, `3px solid var(--accent)` top bar
6. Select dropdowns: JetBrains Mono, `1px solid var(--rule)` border, `var(--paper)` background, no border-radius
7. Remove all `rounded-*`, `bg-slate-*`, `text-slate-*`, `border-slate-*` classes

**Acceptance**: Dashboard visually matches design-mockups/01-ink-and-paper.html aesthetic.

#### Task 1.4: Explore Page Restyle

**Files to modify**: `src/routes/explore.tsx`

1. Apply same token system: paper background, ink text, editorial typography
2. Controls panel: `var(--sidebar-bg)` background, square borders
3. Filter checkboxes: square styling, JetBrains Mono labels
4. Results table: editorial table pattern (2px header border, 1px row borders, mono column names)
5. Section headers with numbered pattern: "01 Controls", "02 Results"

**Acceptance**: Explore page follows Ink & Paper aesthetic with no dark-theme remnants.

#### Task 1.5: Profile Page Restyle

**Files to modify**: `src/routes/profile.tsx`

1. Apply token system throughout
2. Profile input slots: `var(--sidebar-bg)` panels with rule borders
3. "Build profile" button: square, `1px solid var(--ink)` border, `var(--paper)` background, accent color on hover
4. Summary cards: Fraunces large numbers, JetBrains Mono labels
5. Percentile cards: `var(--sidebar-bg)` with `3px solid var(--accent)` top bar

**Acceptance**: Profile page matches editorial aesthetic.

#### Task 1.6: SQL Console Restyle

**Files to modify**: `src/routes/sql.tsx`

1. Schema sidebar: `var(--sidebar-bg)` background, JetBrains Mono column list
2. SQL editor textarea: JetBrains Mono, `var(--paper)` background, `1px solid var(--rule)` border
3. Results table: editorial table pattern
4. Buttons: square, bordered, no rounded corners
5. Search input: same form control pattern as other pages

**Acceptance**: SQL console matches editorial aesthetic.

#### Task 1.7: Extract Shared Components

**Files to create**: `src/components/stat-card.tsx`, `src/components/data-table.tsx`, `src/components/section-header.tsx`
**Files to modify**: `src/routes/index.tsx`, `src/routes/profile.tsx`, `src/routes/explore.tsx`, `src/routes/sql.tsx`

1. Extract `StatCard` component (currently duplicated in `index.tsx` and `profile.tsx`)
2. Extract `DataTable` component (editorial-styled table used in all 4 pages)
3. Extract `SectionHeader` component (numbered header with border pattern)
4. Extract shared formatting utilities (`asNumber`, `formatNumber`, `percent`) to `src/lib/format.ts`
5. Deduplicate `asNumber`/`asNullableNumber` functions (currently in 3+ files)

**Acceptance**: No duplicated component/utility code across routes. Components render identically.

#### Phase 1 Verification
- [x] All pages use Ink & Paper tokens (no slate-*, no rounded-*, no system fonts)
- [x] Google Fonts (Fraunces, Source Serif 4, JetBrains Mono) load correctly
- [x] Paper texture visible on all pages
- [x] Navigation active state shows red underline
- [x] `pnpm check-types` passes
- [x] `pnpm test --run` passes
- [x] Visual parity with `design-mockups/01-ink-and-paper.html` aesthetic

---

### Phase 2: Core UX Upgrades

**Goal**: Transform each page from basic data display into a genuine exploration tool. Depends on Phase 1 completion.

#### Task 2.1: Column Atlas Page

**Files to create**: `src/routes/columns.tsx`
**Files to modify**: `src/routes/__root.tsx` (add nav link)

A dedicated page for browsing the dataset's 365 columns like a library.

1. **Search**: text input filtering columns by name (case-insensitive substring)
2. **Tag filters**: checkboxes for demographic / ocean / fetish / derived / other
3. **Sort modes**: dropdown with options:
   - Name (A-Z)
   - Lowest null ratio (most complete first)
   - Highest null ratio (most gated first)
   - Lowest cardinality (best for pivots)
   - Highest cardinality
4. **Column rows** showing:
   - Column name in JetBrains Mono
   - Logical type badge (categorical / numeric / text)
   - Null ratio as inline bar (4px height, accent color) + percentage
   - Approx cardinality
   - Caveat footnotes as square labels (e.g., `GATED`, `COMPUTED`)
5. **Click interaction**: clicking a column row opens the Column Inspector (Task 2.2)
6. **Data source**: `getSchema()` client API call, filtering/sorting in-browser

**Acceptance**: User can search, filter, sort all 365 columns. Each row shows metadata at a glance. Click opens inspector.

#### Task 2.2: Column Inspector Panel

**Files to create**: `src/components/column-inspector.tsx`
**Files to modify**: `src/routes/columns.tsx`, optionally `src/routes/index.tsx`

A slide-in or inline detail panel showing everything about one column.

1. **Header**: column name, logical type, caveat badges
2. **Stats section** (via DuckDB-WASM query):
   - Categorical: top 12 values with counts + bar chart, tail size (`N distinct - 12`)
   - Numeric: quantile summary (min, p25, median, p75, max, mean, stddev)
3. **Missingness section**:
   - Null count and percentage
   - Null meaning badge (GATED / LATE_ADDED / UNKNOWN)
   - Explanation text from caveat definitions
4. **Navigation links** ("Explore with..."):
   - "Cross-tab with [column]" → link to `/explore?x=thisCol&y=suggestedCol`
   - "Open in SQL" → link to `/sql` with pre-filled query
   - "View in Profile" → link to `/profile` if column is demographic
5. **Design**: raised panel with `var(--sidebar-bg)`, `3px solid var(--accent)` top bar

**Acceptance**: Inspector shows comprehensive column detail. Stats load via DuckDB-WASM. Navigation links work.

#### Task 2.3: Missingness Lens

**Files to create**: `src/components/missingness-badge.tsx`, `src/components/sample-size-display.tsx`
**Files to modify**: `src/routes/explore.tsx`, `src/routes/index.tsx`, `src/routes/profile.tsx`
**Schema changes**: add `nullMeaning` to column metadata (see Section 4)

Expose null meaning throughout the UI so users understand what missing data means.

1. **Null Meaning Badge**: small square label next to column names in dropdowns and results:
   - `GATED` — structural, often interpretable as 0/false
   - `LATE ADDED` — cohort-related, don't treat as 0
   - `UNKNOWN` — default
2. **Sample Size Display**: wherever results appear, show:
   - `N total` (dataset size)
   - `N non-null` for the relevant column(s)
   - For cross-tabs: `N used` (both X and Y non-null)
3. **Integration points**:
   - Column selectors on Explore, Dashboard, Profile
   - Results headers on Explore, Dashboard
   - Column Inspector detail panel

**Acceptance**: Null meaning badges appear on column selectors. Sample sizes displayed alongside all results.

#### Task 2.4: Explore Pivot Matrix

**Files to modify**: `src/routes/explore.tsx`
**Files to create**: `src/components/pivot-matrix.tsx`

Transform the flat crosstab list into a real pivot table when both columns are categorical.

1. **Matrix layout**: X values as columns, Y values as rows, counts in cells
2. **Marginals**: row totals, column totals, grand total
3. **Normalization modes** (toggle):
   - Counts (default)
   - Row % (each row sums to 100)
   - Column %
   - Overall %
4. **Top-N control**: "Show top N categories" for each axis (default 12), everything else grouped as "Other"
5. **Cell interaction**: click a cell to show:
   - Cell count, % of row, % of column
   - "Open this cohort in Profile" link
   - "Generate SQL for this cohort" link
6. **Association strength**: compute Cramer's V from the contingency table via DuckDB-WASM
   - Display as "Association: V = 0.12 (weak)" with thresholds: <0.1 negligible, 0.1-0.3 weak, 0.3-0.5 moderate, >0.5 strong
   - Always show `N used` alongside
7. **Fallback**: when one or both columns are numeric, keep the current flat table format (pivot only makes sense for categorical x categorical)

**Acceptance**: Categorical x categorical shows pivot matrix with marginals. Normalization toggle works. Cramer's V computed and displayed. Cell click shows detail.

#### Task 2.5: Dashboard Recipes

**Files to modify**: `src/routes/index.tsx`

Enhance the dashboard from basic stats display to a trust-building overview.

1. **Tag breakdown panel**: show how many columns per tag (demographic: 64, fetish: 196, etc.)
2. **Missingness histogram**: bucket columns by null ratio (0-10%, 10-25%, 25-50%, 50-75%, 75-100%) and show counts — helps users understand dataset completeness
3. **"Most analysis-friendly columns"** section: top 10 columns with lowest null ratio + lowest cardinality (good pivot candidates)
4. **"Most gated columns"** section: top 10 columns with highest null ratio + caveat `gated_missingness`
5. **Improved column stats**: integrate Column Inspector behavior inline (show caveat badges, null meaning, distribution preview)

**Acceptance**: Dashboard provides trustworthy overview of dataset shape. Tag breakdown and missingness histogram render correctly.

#### Phase 2 Verification
- [x] Column Atlas page accessible from nav, search/filter/sort work
- [x] Column Inspector shows stats, missingness, navigation links
- [x] Null meaning badges appear on Explore and Dashboard column selectors
- [x] Sample sizes (N total, N non-null, N used) shown on all result displays
- [x] Pivot matrix renders for categorical x categorical with marginals
- [x] Normalization modes (count, row%, col%, overall%) toggle correctly
- [x] Cramer's V computed and displayed with N used
- [x] Dashboard shows tag breakdown and missingness histogram
- [x] `pnpm check-types` passes
- [x] `pnpm test --run` passes

---

### Phase 3: Advanced Features

**Goal**: Add analysis power that makes the app feel like a real research tool. Depends on Phase 2 completion.

#### Task 3.1: Profile Cohort Guardrails

**Files to modify**: `src/routes/profile.tsx`

1. **Prominent N display**: show cohort size front-and-center (already exists, but make it the visual anchor)
2. **Warning tiers**:
   - `N < 100`: amber warning "Treat patterns as unstable"
   - `N < 30`: red warning "Too small for reliable comparisons"
3. **Suppress small cells**: in percentile card results, suppress or gray out breakdowns where underlying count < 10
4. **Always show N**: every percentage displayed must have its N alongside

**Acceptance**: Warnings appear for small cohorts. Small-cell values suppressed.

#### Task 3.2: Profile Over-Indexing Cards

**Files to modify**: `src/routes/profile.tsx`

For categorical variables, show what's distinctive about the cohort vs. the full dataset.

1. Select a set of "safe" categorical columns (demographic + personality, configurable)
2. For each, compute: `cohort_pct / global_pct` ratio for each value
3. Show top 8 over-indexed values across all candidate columns
4. Display as: "This cohort is **1.8x** as likely to answer [value] for [column]"
5. Only show ratios where both cohort N and global N meet minimum thresholds (N >= 30)

**Acceptance**: Over-indexing cards show meaningful distinctions. Ratios only displayed for adequate sample sizes.

#### Task 3.3: Profile Side-by-Side Comparison

**Files to modify**: `src/routes/profile.tsx`

Let users define two cohorts and compare them.

1. **Dual filter panels**: Cohort A (left) and Cohort B (right), each with 3 demographic filter slots
2. **Delta display**:
   - Numeric metrics: show `Δ mean` and `Δ median` between cohorts
   - Categorical over-indexing: show which values each cohort over-indexes on
3. **Always show**: both Ns, both cohort shares, warning tiers for each

**Acceptance**: Two cohorts can be defined and compared. Deltas computed correctly. N displayed for both.

#### Task 3.4: Relationship Finder

**Files to create**: `src/routes/relationships.tsx`, `scripts/precompute-relationships.ts`
**Files to modify**: `src/routes/__root.tsx` (add nav link)

For a chosen target column, show which other columns are most related.

1. **Build-time precomputation** (`scripts/precompute-relationships.ts`):
   - For reasonable columns (exclude nullRatio > 0.7, cardinality > 100):
     - Categorical x categorical: Cramer's V
     - Numeric x numeric: Pearson correlation
     - Numeric x categorical: eta-squared (variance explained)
   - Output: `src/lib/schema/relationships.generated.json` (~top 20 per column)
2. **Runtime page**:
   - Select target column
   - Show ranked related columns with strength metric and type
   - Click a relationship → opens Explore with those two columns preselected
3. **Design**: editorial table with strength bars

**Acceptance**: Precomputed relationships load instantly. Rankings feel meaningful. Click-through to Explore works.

#### Task 3.5: SQL Console Upgrades

**Files to modify**: `src/routes/sql.tsx`

1. **Templates sidebar section**: 5-6 starter templates:
   - Distribution (categorical): `SELECT col, count(*) ... GROUP BY 1 ORDER BY 2 DESC`
   - Distribution (numeric): `SELECT min, p25, median, p75, max, avg ...`
   - Cross-tab: `SELECT x, y, count(*) ... GROUP BY 1, 2`
   - Cohort filter: `SELECT ... WHERE demographic = 'value'`
   - Correlation: `SELECT corr(x, y), count(*) ...`
   - Clicking a template inserts working SQL with placeholder column names
2. **Click-to-insert**: clicking a column in the sidebar inserts its properly quoted identifier (e.g., `"column name (id)"`) at the cursor position, instead of appending `-- comment`
3. **Query metadata bar**: below results, show:
   - Rows returned
   - Limit applied
   - "Results may be truncated" when rows = limit

**Acceptance**: Templates insert working SQL. Column click inserts quoted identifier. Query metadata displayed.

#### Phase 3 Verification
- [x] Profile warns on small cohorts (N < 100 amber, N < 30 red)
- [x] Small-cell suppression active (count < 10 not shown) for implemented profile/explore/dashboard surfaces
- [x] Over-indexing cards show meaningful categorical distinctions
- [ ] Side-by-side comparison works for two cohorts with deltas
- [ ] Relationship Finder loads precomputed data and ranks columns
- [ ] Click-through from Relationship Finder to Explore works
- [x] SQL templates insert valid queries
- [x] Column click inserts quoted identifier
- [x] `pnpm check-types` passes
- [x] `pnpm test --run` passes

---

### Phase 4: Polish & Deploy

**Goal**: Final refinements, exploration notebook, MCP Service B deployment.

#### Task 4.1: Exploration Notebook

**Files to create**: `src/routes/notebook.tsx`, `src/lib/notebook-store.ts`
**Files to modify**: `src/routes/__root.tsx` (add nav link), Explore/Profile/SQL pages (add "Add to Notebook" button)

Local-storage-backed notebook for collecting findings.

1. **"Add to Notebook" button** on Explore results, Profile summaries, SQL results
2. **Notebook entries** store:
   - Title (auto-generated from query context, editable)
   - Query definition (columns, filters, SQL)
   - Results snapshot (the data at time of save)
   - User notes (free-text)
   - Timestamp
3. **Notebook page**: list saved entries, edit notes, delete entries
4. **Export**: JSON export for reproducibility, print-friendly view
5. **Storage**: localStorage (no server persistence needed for v2)

**Acceptance**: Notebook saves and displays entries. Export works. Entries persist across page reloads.

#### Task 4.2: Small-Cell Hygiene (Global)

**Files to create**: `src/lib/cell-hygiene.ts`
**Files to modify**: all route files that display counts/percentages

1. Define global threshold constant: `MIN_CELL_COUNT = 10`
2. In any table displaying counts by category:
   - Suppress rows where count < threshold (replace with "[suppressed]" or hide)
   - Always display N alongside percentages
3. For high-cardinality text columns: default to showing top values only, no row-level browsing

**Acceptance**: No table shows breakdown rows with count < 10. All percentages have N displayed.

#### Task 4.3: MCP Service B Deployment

**Files to modify**: `mcp-server/Dockerfile`, Railway config
**Relevant docs**: `docs/design/deployment.md`

1. Deploy MCP server as Railway Service B (separate from web app)
2. Verify all 5 tools work against production parquet data
3. Document the MCP endpoint URL and connection instructions

**Acceptance**: MCP server reachable at Railway URL. All tools return valid responses.

#### Task 4.4: URL State for Exploration

**Files to modify**: `src/routes/explore.tsx`, `src/routes/columns.tsx`, `src/routes/profile.tsx`

1. Sync key state to URL search params (x, y, filters on Explore; selected column on Columns; cohort filters on Profile)
2. Support deep-linking: opening a URL with params restores the exact view
3. Enable cross-page navigation links (e.g., Column Inspector "Explore with..." links)

**Acceptance**: Exploration state is shareable via URL. Deep links restore correct view.

#### Phase 4 Verification
- [ ] Notebook saves entries to localStorage and restores on reload
- [ ] "Add to Notebook" button appears on Explore, Profile, SQL results
- [ ] Export (JSON) works
- [ ] Small-cell suppression applied globally
- [x] MCP Service B deployed and service reachable in Railway project (deployment/tool-level verification completed)
- [ ] URL state synced for Explore, Columns, Profile
- [ ] Deep links work
- [x] Full regression run for implemented scope: `pnpm check-types`, `pnpm test --run`, `pnpm lint`, and `pnpm build`

---

## 4. Schema Enhancement Plan

### 4.1 Add `nullMeaning` to Column Metadata

Status: Implemented in this execution pass (`contracts.ts`, `types.ts`, `metadata.ts`, `null-meaning.ts`, and `profile-schema.mjs`).

**File to modify**: `scripts/profile-schema.mjs`
**File to modify**: `src/lib/schema/types.ts`
**File to modify**: `src/lib/api/contracts.ts`

Add a `nullMeaning` field to each column entry in `columns.generated.json`:

```typescript
type NullMeaning = "GATED" | "LATE_ADDED" | "NOT_APPLICABLE" | "UNKNOWN";
```

Heuristic for assignment in `profile-schema.mjs`:
- If column has caveat `gated_missingness` AND nullRatio > 0.3 → `GATED`
- If column has caveat `late_added_questions` → `LATE_ADDED`
- If column is sex-gated (pattern match on name) → `NOT_APPLICABLE`
- Else → `UNKNOWN`

These can be refined with manual overrides in a separate mapping file if needed.

### 4.2 Add `displayName` to Column Metadata

Status: Deferred.

Many columns have long names like `"Engaging with or fantasizing about what arouses me feels therapeutic or healing to me" (vmq8jqw)`. Adding a short `displayName` (e.g., "Therapeutic arousal") improves UI readability.

**Approach**: Generate from column name by:
1. Stripping the `(id)` suffix
2. Truncating to ~40 characters with ellipsis if needed
3. Manual overrides for key columns (demographics, OCEAN, derived scores)

Store in a separate `src/lib/schema/display-names.ts` mapping file rather than regenerating the full JSON.

### 4.3 Update Contracts and Types

Status: Implemented.

Add to `ColumnMetadataSchema` in `src/lib/api/contracts.ts`:
```typescript
nullMeaning: z.enum(["GATED", "LATE_ADDED", "NOT_APPLICABLE", "UNKNOWN"]).default("UNKNOWN"),
```

Add to `ColumnMetadata` in `src/lib/schema/types.ts`:
```typescript
nullMeaning?: "GATED" | "LATE_ADDED" | "NOT_APPLICABLE" | "UNKNOWN";
```

---

## 5. Files Index

### Files to Create

| File | Phase | Purpose |
|------|-------|---------|
| `src/components/stat-card.tsx` | 1 | Reusable stat card component |
| `src/components/data-table.tsx` | 1 | Reusable editorial-styled data table |
| `src/components/section-header.tsx` | 1 | Numbered section header component |
| `src/lib/format.ts` | 1 | Shared formatting utilities |
| `src/routes/columns.tsx` | 2 | Column Atlas page |
| `src/components/column-inspector.tsx` | 2 | Column detail panel |
| `src/components/missingness-badge.tsx` | 2 | Null meaning badge component |
| `src/components/sample-size-display.tsx` | 2 | N display component |
| `src/components/pivot-matrix.tsx` | 2 | Pivot table component |
| `src/components/ui/button.tsx` | 1 | shadcn button primitive |
| `src/components/ui/input.tsx` | 1 | shadcn input primitive |
| `src/components/ui/textarea.tsx` | 1 | shadcn textarea primitive |
| `src/components/ui/select.tsx` | 1 | shadcn select primitive |
| `src/components/ui/checkbox.tsx` | 1 | shadcn checkbox primitive |
| `src/components/ui/badge.tsx` | 1 | shadcn badge primitive |
| `src/components/ui/table.tsx` | 1 | shadcn table primitive |
| `src/lib/utils.ts` | 1 | `cn()` utility for class merging |
| `src/lib/schema/null-meaning.ts` | 4 | nullMeaning inference utility |
| `src/routes/relationships.tsx` | 3 | Relationship Finder page |
| `scripts/precompute-relationships.ts` | 3 | Build-time relationship computation |
| `src/lib/schema/relationships.generated.json` | 3 | Precomputed relationship data |
| `src/lib/schema/display-names.ts` | 4 | Short display names for columns |
| `src/routes/notebook.tsx` | 4 | Exploration Notebook page |
| `src/lib/notebook-store.ts` | 4 | localStorage notebook persistence |
| `src/lib/cell-hygiene.ts` | 4 | Small-cell suppression utilities |

### Files to Modify

| File | Phase | Changes |
|------|-------|---------|
| `src/styles.css` | 1 | Design tokens, fonts, paper texture |
| `src/routes/__root.tsx` | 1, 2, 3, 4 | Restyle nav, add new page links |
| `src/routes/index.tsx` | 1, 2 | Restyle, add dashboard recipes |
| `src/routes/explore.tsx` | 1, 2 | Restyle, pivot matrix, Cramer's V |
| `src/routes/profile.tsx` | 1, 3 | Restyle, guardrails, over-indexing, comparison |
| `src/routes/sql.tsx` | 1, 3 | Restyle, templates, click-to-insert |
| `src/lib/schema/types.ts` | 4 | Add nullMeaning type |
| `src/lib/api/contracts.ts` | 4 | Add nullMeaning to schema |
| `src/lib/schema/metadata.ts` | 4 | Derive `nullMeaning` in API schema output |
| `scripts/profile-schema.mjs` | 4 | Compute nullMeaning per column |

---

## 6. Reusable Infrastructure

### Existing Utilities to Leverage

| Utility | Location | Use For |
|---------|----------|---------|
| `useDuckDBQuery(sql)` | `src/lib/duckdb/use-query.ts` | All client-side data queries |
| `useDuckDB()` | `src/lib/duckdb/provider.tsx` | Direct DuckDB access for complex multi-step queries |
| `quoteIdentifier()` | `src/lib/duckdb/sql-helpers.ts` | Safe column name quoting in generated SQL |
| `quoteLiteral()` | `src/lib/duckdb/sql-helpers.ts` | Safe value quoting in WHERE clauses |
| `buildWhereClause()` | `src/lib/duckdb/sql-helpers.ts` | Filter-to-SQL conversion |
| `getSchema()` | `src/lib/client/api.ts` | Fetching column metadata (all pages need this) |
| `getCaveatKeysForColumn()` | `src/lib/schema/caveats.ts` | Looking up caveats for badges |
| `CAVEAT_DEFINITIONS` | `src/lib/schema/caveats.ts` | Rendering caveat explanations |
| `getSchemaMetadata()` | `src/lib/schema/metadata.ts` | Server-side metadata access |

### Patterns to Follow

- **Data fetching**: `useEffect` + `getSchema()` for metadata, `useDuckDBQuery(sql)` for data
- **SQL generation**: `useMemo` to build SQL from state, pass to `useDuckDBQuery`
- **API contract**: all server endpoints use `okResponse()` / `errorResponse()` from `api-response.ts`
- **Type safety**: Zod schemas in `contracts.ts` for all API boundaries

---

## 7. Dependency Order

```
Phase 1 (Design System)
  └── Task 1.1 CSS Tokens
  └── Task 1.2 Root/Nav (depends on 1.1)
  └── Tasks 1.3-1.6 Page Restyles (depend on 1.1, independent of each other)
  └── Task 1.7 Shared Components (depends on 1.3-1.6 being complete)

Phase 2 (Core UX) — depends on Phase 1
  └── Task 2.1 Column Atlas (independent)
  └── Task 2.2 Column Inspector (depends on 2.1 for housing)
  └── Task 2.3 Missingness Lens (independent, can parallelize with 2.1/2.2)
  └── Task 2.4 Explore Pivot Matrix (independent)
  └── Task 2.5 Dashboard Recipes (independent)

Phase 3 (Advanced) — depends on Phase 2
  └── Tasks 3.1-3.3 Profile upgrades (depend on missingness lens from 2.3)
  └── Task 3.4 Relationship Finder (independent, benefits from Column Atlas)
  └── Task 3.5 SQL Console Upgrades (independent)

Phase 4 (Polish) — depends on Phase 3
  └── Task 4.1 Notebook (depends on Explore/Profile/SQL being feature-complete)
  └── Task 4.2 Small-Cell Hygiene (can run anytime)
  └── Task 4.3 MCP Service B (independent)
  └── Task 4.4 URL State (depends on pages being feature-complete)
```

---

## 8. Open Questions

1. **Font self-hosting vs. Google Fonts CDN**: Google Fonts CDN is simpler but adds an external dependency and a FOUT flash. Self-hosting gives more control. Recommendation: start with Google Fonts CDN, switch to self-hosted if latency is noticeable.

2. **Relationship precomputation scope**: 365 columns produce ~66k pairs. Filtering to columns with nullRatio < 0.7 and cardinality < 100 reduces this significantly. Need to verify the filtered set size and computation time before committing to build-time vs. on-demand.

3. **Notebook persistence**: localStorage is simple but limited (~5MB). If users generate many large snapshots, may need IndexedDB. Start with localStorage, migrate if needed.

4. **Column display names**: Manual curation of 365 display names is labor-intensive. Start with automated truncation + manual overrides for the ~50 most important columns (demographics, OCEAN, derived scores).
</file>

<file path="src/components/column-inspector.tsx">
import { useMemo } from "react";

import { CAVEAT_DEFINITIONS } from "@/lib/schema/caveats";
import { asNullableNumber, asNumber, formatNumber, formatPercent } from "@/lib/format";
import { quoteIdentifier } from "@/lib/duckdb/sql-helpers";
import { useDuckDBQuery } from "@/lib/duckdb/use-query";
import { MissingnessBadge } from "./missingness-badge";
import { SampleSizeDisplay } from "./sample-size-display";
import { ScrollArea } from "./ui/scroll-area";
import type { SchemaData } from "@/lib/api/contracts";
import { DataTable } from "./data-table";
import { SectionHeader } from "./section-header";

interface ColumnInspectorProps {
  column: SchemaData["columns"][number] | null;
  allColumns: SchemaData["columns"];
}

interface CategoryRow {
  value: string;
  count: number;
  percentage: number;
}

function encodeSql(sql: string): string {
  return encodeURIComponent(sql);
}

function candidateValueKeys(value: string): string[] {
  const trimmed = value.trim();
  if (trimmed.length === 0) {
    return [trimmed];
  }

  const candidates = new Set<string>([trimmed]);
  const numeric = Number(trimmed);

  if (Number.isFinite(numeric)) {
    candidates.add(String(numeric));
    if (Number.isInteger(numeric)) {
      candidates.add(String(Math.trunc(numeric)));
    }
  }

  if (/^-?\d+\.0+$/.test(trimmed)) {
    candidates.add(trimmed.replace(/\.0+$/, ""));
  }

  return [...candidates];
}

function formatValueWithLabel(value: string, valueLabels?: Record<string, string>): string {
  if (!valueLabels || value === "NULL") {
    return value;
  }

  for (const key of candidateValueKeys(value)) {
    const label = valueLabels[key];
    if (label) {
      return `${value} - ${label}`;
    }
  }

  return value;
}

export function ColumnInspector({ column, allColumns }: ColumnInspectorProps) {
  const quotedColumn = column ? quoteIdentifier(column.name) : "";

  const countsSql = useMemo(() => {
    if (!column) return null;

    return `
      SELECT
        count(*)::BIGINT AS total_count,
        count(${quotedColumn})::BIGINT AS non_null_count
      FROM data
    `;
  }, [column, quotedColumn]);

  const numericSql = useMemo(() => {
    if (!column || column.logicalType !== "numeric") return null;

    return `
      SELECT
        avg(${quotedColumn})::DOUBLE AS mean,
        stddev_samp(${quotedColumn})::DOUBLE AS stddev,
        min(${quotedColumn})::DOUBLE AS min_value,
        quantile_cont(${quotedColumn}, 0.25)::DOUBLE AS p25,
        median(${quotedColumn})::DOUBLE AS median_value,
        quantile_cont(${quotedColumn}, 0.75)::DOUBLE AS p75,
        max(${quotedColumn})::DOUBLE AS max_value
      FROM data
      WHERE ${quotedColumn} IS NOT NULL
    `;
  }, [column, quotedColumn]);

  const categoricalSql = useMemo(() => {
    if (!column || column.logicalType === "numeric") return null;

    return `
      WITH totals AS (
        SELECT count(${quotedColumn})::DOUBLE AS non_null_count
        FROM data
      ),
      top_values AS (
        SELECT
          cast(${quotedColumn} AS VARCHAR) AS value,
          count(*)::BIGINT AS cnt
        FROM data
        WHERE ${quotedColumn} IS NOT NULL
        GROUP BY 1
        ORDER BY cnt DESC
        LIMIT 12
      )
      SELECT
        top_values.value,
        top_values.cnt,
        CASE
          WHEN totals.non_null_count = 0 THEN 0
          ELSE (top_values.cnt::DOUBLE / totals.non_null_count) * 100
        END AS pct
      FROM top_values
      CROSS JOIN totals
      ORDER BY top_values.cnt DESC
    `;
  }, [column, quotedColumn]);

  const categoricalTailSql = useMemo(() => {
    if (!column || column.logicalType === "numeric") return null;

    return `
      SELECT
        greatest((approx_count_distinct(${quotedColumn}) - 12)::BIGINT, 0::BIGINT) AS tail_size
      FROM data
      WHERE ${quotedColumn} IS NOT NULL
    `;
  }, [column, quotedColumn]);

  const countsQuery = useDuckDBQuery(countsSql);
  const numericQuery = useDuckDBQuery(numericSql);
  const categoricalQuery = useDuckDBQuery(categoricalSql);
  const tailQuery = useDuckDBQuery(categoricalTailSql);

  const counts = useMemo(() => {
    const row = countsQuery.data?.rows[0];
    if (!row) {
      return { total: 0, nonNull: 0 };
    }

    return {
      total: asNumber(row[0]),
      nonNull: asNumber(row[1]),
    };
  }, [countsQuery.data]);

  const categoryRows = useMemo<CategoryRow[]>(() => {
    if (!categoricalQuery.data) return [];

    return categoricalQuery.data.rows.map((row) => ({
      value: String(row[0] ?? "NULL"),
      count: asNumber(row[1]),
      percentage: asNumber(row[2]),
    }));
  }, [categoricalQuery.data]);

  const suggestedColumn = useMemo(() => {
    if (!column) return null;

    const overlap = allColumns.find(
      (candidate) =>
        candidate.name !== column.name &&
        candidate.logicalType === "categorical" &&
        candidate.tags.some((tag) => column.tags.includes(tag)),
    );

    if (overlap) return overlap.name;

    return allColumns.find((candidate) => candidate.name !== column.name)?.name ?? null;
  }, [allColumns, column]);

  if (!column) {
    return (
      <aside className="raised-panel">
        <SectionHeader number="02" title="Column Inspector" subtitle="Select a column to inspect." />
      </aside>
    );
  }

  const numericRow = numericQuery.data?.rows[0];
  const numericStats = numericRow
    ? {
        min: asNullableNumber(numericRow[2]),
        p25: asNullableNumber(numericRow[3]),
        median: asNullableNumber(numericRow[4]),
        p75: asNullableNumber(numericRow[5]),
        max: asNullableNumber(numericRow[6]),
        mean: asNullableNumber(numericRow[0]),
        stddev: asNullableNumber(numericRow[1]),
      }
    : null;

  const caveatDefinitions = column.caveatKeys.map((key) => CAVEAT_DEFINITIONS[key]);
  const tailSize = asNumber(tailQuery.data?.rows[0]?.[0] ?? 0, 0);

  const exploreHref = suggestedColumn
    ? `/explore?x=${encodeURIComponent(column.name)}&y=${encodeURIComponent(suggestedColumn)}`
    : "/explore";

  const sqlHref = `/sql?sql=${encodeSql(
    `SELECT ${quotedColumn} AS value, count(*)::BIGINT AS count\nFROM data\nGROUP BY 1\nORDER BY count DESC\nLIMIT 50`,
  )}`;

  return (
    <aside className="raised-panel space-y-5">
      <SectionHeader
        number="02"
        title="Column Inspector"
        subtitle={
          <span className="flex flex-wrap items-center gap-2">
            <span className="mono-value">{column.name}</span>
            <span className="null-badge">{column.logicalType}</span>
            <MissingnessBadge meaning={column.nullMeaning} />
          </span>
        }
      />

      <SampleSizeDisplay total={counts.total} nonNull={counts.nonNull} />

      {countsQuery.error ? <p className="alert alert--error">{countsQuery.error}</p> : null}

      {column.logicalType === "numeric" ? (
        <div>
          <p className="mono-label">Numeric Summary</p>
          {numericStats ? (
            <DataTable
              rows={[
                { label: "Min", value: numericStats.min },
                { label: "P25", value: numericStats.p25 },
                { label: "Median", value: numericStats.median },
                { label: "P75", value: numericStats.p75 },
                { label: "Max", value: numericStats.max },
                { label: "Mean", value: numericStats.mean },
                { label: "Stddev", value: numericStats.stddev },
              ]}
              rowKey={(row) => row.label}
              columns={[
                {
                  id: "metric",
                  header: "Metric",
                  cell: (row) => row.label,
                },
                {
                  id: "value",
                  header: "Value",
                  align: "right",
                  cell: (row) => (row.value == null ? "n/a" : row.value.toFixed(3)),
                },
              ]}
            />
          ) : (
            <p className="section-subtitle">No numeric values available.</p>
          )}
        </div>
      ) : (
        <div>
          <p className="mono-label">Top Values</p>
          <DataTable
            rows={categoryRows}
            rowKey={(row) => row.value}
            columns={[
              {
                id: "value",
                header: "Value",
                cell: (row) => formatValueWithLabel(row.value, column.valueLabels),
              },
              {
                id: "count",
                header: "Count",
                align: "right",
                cell: (row) => formatNumber(row.count),
              },
              {
                id: "pct",
                header: "%",
                align: "right",
                cell: (row) => formatPercent(row.percentage, 2),
              },
            ]}
            emptyMessage="No categorical values available"
          />
          {tailSize > 0 ? (
            <p className="section-subtitle">Additional values beyond top 12: {formatNumber(tailSize)}</p>
          ) : null}
        </div>
      )}

      <div>
        <p className="mono-label">Missingness Context</p>
        <div className="space-y-2">
          <p className="mono-value">Null ratio: {formatPercent(column.nullRatio * 100, 1)}</p>
          <p className="mono-value">Null meaning: <MissingnessBadge meaning={column.nullMeaning} /></p>
        </div>
      </div>

      <div>
        <p className="mono-label">Caveats</p>
        <ScrollArea className={caveatDefinitions.length > 3 ? "max-h-[320px]" : ""}>
          {caveatDefinitions.map((definition) => (
            <article key={definition.key} className="caveat-item">
              <p className="caveat-title">{definition.title}</p>
              <p className="caveat-description">{definition.description}</p>
              <p className="caveat-guidance">{definition.guidance}</p>
            </article>
          ))}
        </ScrollArea>
      </div>

      <div>
        <p className="mono-label">Explore With</p>
        <div className="mt-2 flex flex-wrap gap-2">
          <a className="editorial-button" href={exploreHref}>
            Cross-tab
          </a>
          <a className="editorial-button" href={sqlHref}>
            Open in SQL
          </a>
          {column.tags.includes("demographic") ? (
            <a className="editorial-button" href="/profile">
              View in Profile
            </a>
          ) : null}
        </div>
      </div>
    </aside>
  );
}
</file>

<file path="src/components/data-table.tsx">
import type { ReactNode } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

interface DataTableColumn<Row> {
  id: string;
  header: ReactNode;
  align?: "left" | "right";
  headerClassName?: string;
  cellClassName?: string;
  cell: (row: Row, index: number) => ReactNode;
}

interface DataTableProps<Row> {
  columns: Array<DataTableColumn<Row>>;
  rows: Row[];
  rowKey: (row: Row, index: number) => string;
  emptyMessage?: string;
  className?: string;
}

function getAlignClass(align: "left" | "right" | undefined): string {
  return align === "right" ? "numeric" : "";
}

export function DataTable<Row>({
  columns,
  rows,
  rowKey,
  emptyMessage = "No rows",
  className,
}: DataTableProps<Row>) {
  return (
    <Table className={className}>
      <TableHeader>
        <TableRow>
          {columns.map((column) => (
            <TableHead
              key={column.id}
              className={`${getAlignClass(column.align)} ${column.headerClassName ?? ""}`.trim()}
            >
              {column.header}
            </TableHead>
          ))}
        </TableRow>
      </TableHeader>
      <TableBody>
        {rows.length === 0 ? (
          <TableRow>
            <TableCell colSpan={columns.length}>{emptyMessage}</TableCell>
          </TableRow>
        ) : (
          rows.map((row, rowIndex) => (
            <TableRow key={rowKey(row, rowIndex)}>
              {columns.map((column) => (
                <TableCell
                  key={column.id}
                  className={`${getAlignClass(column.align)} ${column.cellClassName ?? ""}`.trim()}
                >
                  {column.cell(row, rowIndex)}
                </TableCell>
              ))}
            </TableRow>
          ))
        )}
      </TableBody>
    </Table>
  );
}
</file>

<file path="src/components/missingness-badge.tsx">
import type { NullMeaning } from "@/lib/schema/null-meaning";
import { Badge } from "@/components/ui/badge";

interface MissingnessBadgeProps {
  meaning: NullMeaning | undefined;
}

const LABELS: Record<NullMeaning, string> = {
  GATED: "Gated",
  LATE_ADDED: "Late Added",
  NOT_APPLICABLE: "N/A",
  UNKNOWN: "Unknown",
};

export function MissingnessBadge({ meaning }: MissingnessBadgeProps) {
  const resolved = meaning ?? "UNKNOWN";
  const variant =
    resolved === "GATED"
      ? "accent"
      : resolved === "LATE_ADDED"
        ? "warm"
        : resolved === "NOT_APPLICABLE"
          ? "cool"
          : "default";

  return <Badge variant={variant}>{LABELS[resolved]}</Badge>;
}
</file>

<file path="src/components/pivot-matrix.tsx">
import { useMemo } from "react";

import { formatNumber, formatPercent } from "@/lib/format";

type PrimitiveValue = string | number | boolean | null;

export type PivotNormalization = "count" | "row" | "column" | "overall";

export interface PivotInputRow {
  x: PrimitiveValue;
  y: PrimitiveValue;
  count: number;
}

export interface PivotCellDetail {
  x: string;
  y: string;
  count: number;
  rowPercent: number;
  columnPercent: number;
  overallPercent: number;
  rowTotal: number;
  columnTotal: number;
  grandTotal: number;
}

interface PivotMatrixProps {
  rows: PivotInputRow[];
  topN: number;
  normalization: PivotNormalization;
  minCellCount?: number;
  onCellClick?: (detail: PivotCellDetail) => void;
}

function label(value: PrimitiveValue): string {
  return value == null ? "NULL" : String(value);
}

function sortedTopKeys(totals: Map<string, number>, topN: number): string[] {
  return [...totals.entries()]
    .sort((left, right) => right[1] - left[1])
    .slice(0, topN)
    .map(([key]) => key);
}

function displayCellValue(
  normalization: PivotNormalization,
  count: number,
  rowTotal: number,
  columnTotal: number,
  grandTotal: number,
  minCellCount: number,
): string {
  if (count > 0 && count < minCellCount) {
    return "[suppressed]";
  }

  if (normalization === "count") {
    return formatNumber(count);
  }

  if (normalization === "row") {
    return formatPercent(rowTotal > 0 ? (count / rowTotal) * 100 : 0, 1);
  }

  if (normalization === "column") {
    return formatPercent(columnTotal > 0 ? (count / columnTotal) * 100 : 0, 1);
  }

  return formatPercent(grandTotal > 0 ? (count / grandTotal) * 100 : 0, 1);
}

export function PivotMatrix({
  rows,
  topN,
  normalization,
  minCellCount = 10,
  onCellClick,
}: PivotMatrixProps) {
  const matrix = useMemo(() => {
    const xTotals = new Map<string, number>();
    const yTotals = new Map<string, number>();

    for (const row of rows) {
      const xValue = label(row.x);
      const yValue = label(row.y);
      xTotals.set(xValue, (xTotals.get(xValue) ?? 0) + row.count);
      yTotals.set(yValue, (yTotals.get(yValue) ?? 0) + row.count);
    }

    const topX = sortedTopKeys(xTotals, topN);
    const topY = sortedTopKeys(yTotals, topN);

    const topXSet = new Set(topX);
    const topYSet = new Set(topY);

    const hasOtherX = xTotals.size > topX.length;
    const hasOtherY = yTotals.size > topY.length;

    const xLabels = hasOtherX ? [...topX, "Other"] : topX;
    const yLabels = hasOtherY ? [...topY, "Other"] : topY;

    const cellCounts = new Map<string, number>();

    const resolveX = (value: string) => {
      if (topXSet.has(value)) return value;
      return hasOtherX ? "Other" : value;
    };

    const resolveY = (value: string) => {
      if (topYSet.has(value)) return value;
      return hasOtherY ? "Other" : value;
    };

    for (const row of rows) {
      const xValue = resolveX(label(row.x));
      const yValue = resolveY(label(row.y));
      const key = `${yValue}\u0000${xValue}`;
      cellCounts.set(key, (cellCounts.get(key) ?? 0) + row.count);
    }

    const rowTotals = new Map<string, number>();
    const columnTotals = new Map<string, number>();

    for (const yValue of yLabels) {
      let rowTotal = 0;
      for (const xValue of xLabels) {
        const count = cellCounts.get(`${yValue}\u0000${xValue}`) ?? 0;
        rowTotal += count;
        columnTotals.set(xValue, (columnTotals.get(xValue) ?? 0) + count);
      }
      rowTotals.set(yValue, rowTotal);
    }

    const grandTotal = [...rowTotals.values()].reduce((sum, value) => sum + value, 0);

    return {
      xLabels,
      yLabels,
      cellCounts,
      rowTotals,
      columnTotals,
      grandTotal,
    };
  }, [rows, topN]);

  if (matrix.grandTotal === 0) {
    return <p className="section-subtitle">No non-null rows are available for this pivot.</p>;
  }

  return (
    <div className="editorial-table-wrap">
      <table className="editorial-table">
        <thead>
          <tr>
            <th>Y \ X</th>
            {matrix.xLabels.map((xValue) => (
              <th key={xValue} className="numeric">
                {xValue}
              </th>
            ))}
            <th className="numeric">Row Total</th>
          </tr>
        </thead>
        <tbody>
          {matrix.yLabels.map((yValue) => {
            const rowTotal = matrix.rowTotals.get(yValue) ?? 0;

            return (
              <tr key={yValue}>
                <td>{yValue}</td>
                {matrix.xLabels.map((xValue) => {
                  const count = matrix.cellCounts.get(`${yValue}\u0000${xValue}`) ?? 0;
                  const columnTotal = matrix.columnTotals.get(xValue) ?? 0;
                  const detail: PivotCellDetail = {
                    x: xValue,
                    y: yValue,
                    count,
                    rowPercent: rowTotal > 0 ? (count / rowTotal) * 100 : 0,
                    columnPercent: columnTotal > 0 ? (count / columnTotal) * 100 : 0,
                    overallPercent: matrix.grandTotal > 0 ? (count / matrix.grandTotal) * 100 : 0,
                    rowTotal,
                    columnTotal,
                    grandTotal: matrix.grandTotal,
                  };

                  return (
                    <td key={`${yValue}-${xValue}`} className="numeric">
                      <button
                        type="button"
                        className="mono-value cursor-pointer border-0 bg-transparent p-0 text-right hover:text-[var(--accent)]"
                        onClick={() => onCellClick?.(detail)}
                      >
                        {displayCellValue(
                          normalization,
                          count,
                          rowTotal,
                          columnTotal,
                          matrix.grandTotal,
                          minCellCount,
                        )}
                      </button>
                    </td>
                  );
                })}
                <td className="numeric">{formatNumber(rowTotal)}</td>
              </tr>
            );
          })}
          <tr>
            <td>Total</td>
            {matrix.xLabels.map((xValue) => (
              <td key={`total-${xValue}`} className="numeric">
                {formatNumber(matrix.columnTotals.get(xValue) ?? 0)}
              </td>
            ))}
            <td className="numeric">{formatNumber(matrix.grandTotal)}</td>
          </tr>
        </tbody>
      </table>
    </div>
  );
}
</file>

<file path="src/components/sample-size-display.tsx">
import { formatNumber } from "@/lib/format";

interface SampleSizeDisplayProps {
  total: number;
  nonNull?: number;
  used?: number;
  className?: string;
}

export function SampleSizeDisplay({ total, nonNull, used, className }: SampleSizeDisplayProps) {
  return (
    <div className={`sample-size ${className ?? ""}`.trim()}>
      <span className="sample-size-item">N total: {formatNumber(total)}</span>
      {typeof nonNull === "number" ? (
        <span className="sample-size-item">N non-null: {formatNumber(nonNull)}</span>
      ) : null}
      {typeof used === "number" ? (
        <span className="sample-size-item">N used: {formatNumber(used)}</span>
      ) : null}
    </div>
  );
}
</file>

<file path="src/components/section-header.tsx">
import type { ReactNode } from "react";

interface SectionHeaderProps {
  number: string;
  title: string;
  subtitle?: ReactNode;
  className?: string;
}

export function SectionHeader({ number, title, subtitle, className }: SectionHeaderProps) {
  return (
    <header className={className}>
      <h2 className="section-header">
        <span className="section-number">{number}</span>
        <span>{title}</span>
      </h2>
      {subtitle ? <p className="section-subtitle">{subtitle}</p> : null}
    </header>
  );
}
</file>

<file path="src/components/stat-card.tsx">
import type { ReactNode } from "react";

interface StatCardProps {
  label: string;
  value: ReactNode;
  note?: ReactNode;
  className?: string;
}

export function StatCard({ label, value, note, className }: StatCardProps) {
  return (
    <div className={`stat-cell ${className ?? ""}`.trim()}>
      <p className="stat-cell-label">{label}</p>
      <p className="stat-cell-value">{value}</p>
      {note ? <p className="stat-cell-note">{note}</p> : null}
    </div>
  );
}
</file>

<file path="src/lib/client/api.ts">
import type { CrosstabData, QueryData, SchemaData, StatsData } from "@/lib/api/contracts";

interface ApiSuccess<T> {
  ok: true;
  data: T;
  meta?: Record<string, unknown>;
}

interface ApiFailure {
  ok: false;
  error: {
    code: string;
    message: string;
    details?: unknown;
  };
}

type ApiEnvelope<T> = ApiSuccess<T> | ApiFailure;

async function fetchEnvelope<T>(url: string, init?: RequestInit): Promise<ApiSuccess<T>> {
  const response = await fetch(url, init);
  const envelope = (await response.json()) as ApiEnvelope<T>;

  if (!response.ok || !envelope.ok) {
    const errorMessage = envelope.ok
      ? `Request failed with status ${response.status}`
      : `${envelope.error.code}: ${envelope.error.message}`;

    throw new Error(errorMessage);
  }

  return envelope;
}

export async function getSchema() {
  return fetchEnvelope<SchemaData>("/api/schema", {
    method: "GET",
  });
}

export async function getStats(column: string) {
  return fetchEnvelope<StatsData>(`/api/stats/${encodeURIComponent(column)}`, {
    method: "GET",
  });
}

export interface CrosstabParams {
  x: string;
  y: string;
  limit?: number;
  filters?: Record<
    string,
    string | number | boolean | null | Array<string | number | boolean | null>
  >;
}

export async function getCrosstab(params: CrosstabParams) {
  const url = new URL("/api/crosstab", window.location.origin);
  url.searchParams.set("x", params.x);
  url.searchParams.set("y", params.y);

  if (params.limit) {
    url.searchParams.set("limit", String(params.limit));
  }

  if (params.filters && Object.keys(params.filters).length > 0) {
    url.searchParams.set("filters", JSON.stringify(params.filters));
  }

  return fetchEnvelope<CrosstabData>(url.toString(), {
    method: "GET",
  });
}

export interface QueryParams {
  sql: string;
  limit?: number;
}

export async function runQuery(params: QueryParams) {
  return fetchEnvelope<QueryData>("/api/query", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(params),
  });
}
</file>

<file path="src/lib/duckdb/init.ts">
import * as duckdb from "@duckdb/duckdb-wasm";

import duckdbMvpWasm from "@duckdb/duckdb-wasm/dist/duckdb-mvp.wasm?url";
import duckdbMvpWorker from "@duckdb/duckdb-wasm/dist/duckdb-browser-mvp.worker.js?url";
import duckdbEhWasm from "@duckdb/duckdb-wasm/dist/duckdb-eh.wasm?url";
import duckdbEhWorker from "@duckdb/duckdb-wasm/dist/duckdb-browser-eh.worker.js?url";

const PARQUET_URL = "/BKSPublic.parquet";

let dbPromise: Promise<duckdb.AsyncDuckDB> | null = null;

async function createDb(): Promise<duckdb.AsyncDuckDB> {
  const bundles: duckdb.DuckDBBundles = {
    mvp: {
      mainModule: duckdbMvpWasm,
      mainWorker: duckdbMvpWorker,
    },
    eh: {
      mainModule: duckdbEhWasm,
      mainWorker: duckdbEhWorker,
    },
  };

  const bundle = await duckdb.selectBundle(bundles);

  const logger = new duckdb.ConsoleLogger();
  const worker = new Worker(bundle.mainWorker!);
  const db = new duckdb.AsyncDuckDB(logger, worker);
  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);

  await db.registerFileURL("BKSPublic.parquet", PARQUET_URL, duckdb.DuckDBDataProtocol.HTTP, false);

  const conn = await db.connect();
  await conn.query(
    `CREATE OR REPLACE VIEW data AS SELECT * FROM read_parquet('BKSPublic.parquet')`,
  );
  await conn.close();

  return db;
}

export function getDuckDB(): Promise<duckdb.AsyncDuckDB> {
  if (!dbPromise) {
    dbPromise = createDb();
  }
  return dbPromise;
}
</file>

<file path="src/lib/duckdb/provider.tsx">
import { createContext, useContext, useEffect, useState } from "react";
import type { AsyncDuckDB } from "@duckdb/duckdb-wasm";

import { getDuckDB } from "./init";

interface DuckDBContextValue {
  db: AsyncDuckDB | null;
  loading: boolean;
  error: string | null;
}

const DuckDBContext = createContext<DuckDBContextValue>({
  db: null,
  loading: true,
  error: null,
});

export function DuckDBProvider({ children }: { children: React.ReactNode }) {
  const [db, setDb] = useState<AsyncDuckDB | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let cancelled = false;

    getDuckDB()
      .then((instance) => {
        if (!cancelled) {
          setDb(instance);
          setLoading(false);
        }
      })
      .catch((err: unknown) => {
        if (!cancelled) {
          setError(err instanceof Error ? err.message : "Failed to initialize DuckDB-WASM");
          setLoading(false);
        }
      });

    return () => {
      cancelled = true;
    };
  }, []);

  return (
    <DuckDBContext value={{ db, loading, error }}>
      {children}
    </DuckDBContext>
  );
}

export function useDuckDB(): DuckDBContextValue {
  return useContext(DuckDBContext);
}
</file>

<file path="src/lib/duckdb/sql-helpers.ts">
export function quoteIdentifier(identifier: string): string {
  return `"${identifier.replaceAll('"', '""')}"`;
}

export function quoteLiteral(value: string | number | boolean | null): string {
  if (value === null) return "NULL";
  if (typeof value === "number") return String(value);
  if (typeof value === "boolean") return value ? "TRUE" : "FALSE";
  return `'${value.replaceAll("'", "''")}'`;
}

export type FilterValue = string | number | boolean | null;
export type FilterInput = FilterValue | FilterValue[];

export function buildWhereClause(filters: Record<string, FilterInput> | undefined): string {
  if (!filters || Object.keys(filters).length === 0) return "";

  const predicates: string[] = [];

  for (const [columnName, rawValue] of Object.entries(filters)) {
    const col = quoteIdentifier(columnName);

    if (Array.isArray(rawValue)) {
      const nonNull = rawValue.filter((v) => v !== null);
      const hasNull = rawValue.length !== nonNull.length;
      const inPred = nonNull.length > 0
        ? `${col} IN (${nonNull.map((v) => quoteLiteral(v)).join(", ")})`
        : "";

      if (hasNull && inPred) predicates.push(`(${inPred} OR ${col} IS NULL)`);
      else if (hasNull) predicates.push(`${col} IS NULL`);
      else if (inPred) predicates.push(inPred);
      continue;
    }

    if (rawValue === null) {
      predicates.push(`${col} IS NULL`);
      continue;
    }

    predicates.push(`${col} = ${quoteLiteral(rawValue)}`);
  }

  return predicates.length === 0 ? "" : `WHERE ${predicates.join(" AND ")}`;
}
</file>

<file path="src/lib/duckdb/use-query.ts">
import { useCallback, useEffect, useRef, useState } from "react";

import { useDuckDB } from "./provider";

export interface DuckDBQueryResult {
  columns: string[];
  rows: unknown[][];
}

interface UseDuckDBQueryReturn {
  data: DuckDBQueryResult | null;
  loading: boolean;
  error: string | null;
  /** Re-run the query manually. */
  refetch: () => void;
}

function normalizeValue(value: unknown): unknown {
  if (value == null) return null;
  if (typeof value === "bigint") {
    const n = Number(value);
    return Number.isSafeInteger(n) ? n : value.toString();
  }
  return value;
}

/**
 * Run a SQL query against the in-browser DuckDB-WASM instance.
 *
 * The query is re-executed whenever `sql` changes (referential equality).
 * Pass `null` or `""` for `sql` to skip execution.
 */
export function useDuckDBQuery(sql: string | null): UseDuckDBQueryReturn {
  const { db, loading: dbLoading, error: dbError } = useDuckDB();

  const [data, setData] = useState<DuckDBQueryResult | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const generationRef = useRef(0);

  const execute = useCallback(async () => {
    if (!db || !sql) {
      return;
    }

    const generation = ++generationRef.current;
    setLoading(true);
    setError(null);

    let conn;
    try {
      conn = await db.connect();
      const arrowResult = await conn.query(sql);

      if (generation !== generationRef.current) return;

      const columns = arrowResult.schema.fields.map((f) => f.name);
      const rows: unknown[][] = [];

      for (let rowIdx = 0; rowIdx < arrowResult.numRows; rowIdx++) {
        const row: unknown[] = [];
        for (let colIdx = 0; colIdx < columns.length; colIdx++) {
          row.push(normalizeValue(arrowResult.getChildAt(colIdx)?.get(rowIdx)));
        }
        rows.push(row);
      }

      setData({ columns, rows });
      setLoading(false);
    } catch (err: unknown) {
      if (generation !== generationRef.current) return;
      setError(err instanceof Error ? err.message : "Query execution failed");
      setData(null);
      setLoading(false);
    } finally {
      if (conn) {
        await conn.close();
      }
    }
  }, [db, sql]);

  useEffect(() => {
    if (dbError) {
      setError(dbError);
      setLoading(false);
      return;
    }

    if (dbLoading) {
      setLoading(true);
      return;
    }

    if (!sql) {
      setData(null);
      setLoading(false);
      return;
    }

    void execute();
  }, [sql, dbLoading, dbError, execute]);

  const refetch = useCallback(() => {
    void execute();
  }, [execute]);

  return { data, loading, error, refetch };
}
</file>

<file path="src/lib/schema/caveats.ts">
export type CaveatKey =
  | "binned_or_collapsed"
  | "combined_or_merged"
  | "computed_column"
  | "negated_scale"
  | "opaque_composite"
  | "gated_missingness"
  | "late_added_questions";

export interface CaveatDefinition {
  key: CaveatKey;
  title: string;
  description: string;
  guidance: string;
}

export const CAVEAT_DEFINITIONS: Record<CaveatKey, CaveatDefinition> = {
  binned_or_collapsed: {
    key: "binned_or_collapsed",
    title: "Binned or Collapsed",
    description:
      "This value was collapsed from a finer-grained original survey scale during data cleaning.",
    guidance:
      "Interpret as broad buckets, not the full original response distribution.",
  },
  combined_or_merged: {
    key: "combined_or_merged",
    title: "Combined or Merged",
    description:
      "This column combines multiple source questions or categories into one derived field.",
    guidance:
      "Use caution when comparing to the original GT survey wording.",
  },
  computed_column: {
    key: "computed_column",
    title: "Computed",
    description:
      "This value is algorithmically computed (average/total/derived score), not a direct survey answer.",
    guidance:
      "Treat as a modelled score rather than a literal response option.",
  },
  negated_scale: {
    key: "negated_scale",
    title: "Negated Scale",
    description:
      "This column uses an inverted arousal scale where more negative values indicate higher arousal.",
    guidance:
      "Interpret values by scale labels rather than signed magnitude (for example -8 is highest arousal).",
  },
  opaque_composite: {
    key: "opaque_composite",
    title: "Opaque Composite Score",
    description:
      "This column contains an encoded composite score derived from multiple signals, and the formula is not documented.",
    guidance:
      "Avoid direct ordinal interpretation. Prefer direct survey-response columns when possible.",
  },
  gated_missingness: {
    key: "gated_missingness",
    title: "Gated Missingness",
    description:
      "Many questions are shown only after prerequisite answers. Missing values may be structural, not random.",
    guidance:
      "When domain-appropriate, consider NA as implicit zero or not-applicable rather than unknown.",
  },
  late_added_questions: {
    key: "late_added_questions",
    title: "Late-Added Questions",
    description:
      "Some questions were added later in survey history, which can create cohort-related missingness.",
    guidance:
      "Compare missingness rates before assuming behavioral differences.",
  },
};

export const GLOBAL_CAVEAT_KEYS: CaveatKey[] = ["gated_missingness", "late_added_questions"];

const COLUMN_CAVEAT_PATTERNS: Array<{ pattern: RegExp; keys: CaveatKey[] }> = [
  { pattern: /^politics$/i, keys: ["binned_or_collapsed"] },
  { pattern: /^bmi$/i, keys: ["binned_or_collapsed"] },
  { pattern: /^straightness$/i, keys: ["binned_or_collapsed", "computed_column"] },
  { pattern: /^sexcount$/i, keys: ["binned_or_collapsed"] },
  {
    pattern: /How "sexually liberated" was your upbringing\? \(fs700v2\)/i,
    keys: ["binned_or_collapsed"],
  },
  { pattern: /^childhood_adversity$/i, keys: ["combined_or_merged"] },
  { pattern: /^childhood_gender_tolerance$/i, keys: ["combined_or_merged"] },
  { pattern: /^TotalMentalIllness$/i, keys: ["combined_or_merged"] },
  {
    pattern: /preferred relationship style.*\(4jib23m\)/i,
    keys: ["combined_or_merged"],
  },
  {
    pattern:
      /(opennessvariable|consciensiousnessvariable|extroversionvariable|neuroticismvariable|agreeablenessvariable|powerlessnessvariable|totalfetishcategory|bondageaverage)/i,
    keys: ["computed_column"],
  },
  {
    pattern: /^(whowears|ascore)$/i,
    keys: ["opaque_composite"],
  },
  {
    pattern: /^(normalsex|cunnilingus)$/i,
    keys: ["negated_scale"],
  },
  {
    pattern: /I find blowjobs.*\(yuc275j\)/i,
    keys: ["negated_scale"],
  },
  {
    pattern: /I find cunnilingus:.*\(jn2b355\)/i,
    keys: ["negated_scale"],
  },
  {
    pattern: /I find dirtytalking erotic.*\(947wne3\)/i,
    keys: ["negated_scale"],
  },
  {
    pattern: /^Total[A-Za-z0-9_]+/,
    keys: ["computed_column"],
  },
];

function dedupe(keys: CaveatKey[]): CaveatKey[] {
  return [...new Set(keys)];
}

export function getCaveatKeysForColumn(columnName: string): CaveatKey[] {
  const specific = COLUMN_CAVEAT_PATTERNS.flatMap((entry) =>
    entry.pattern.test(columnName) ? entry.keys : [],
  );

  return dedupe([...specific, ...GLOBAL_CAVEAT_KEYS]);
}

export function getCaveatsForColumn(columnName: string): CaveatDefinition[] {
  return getCaveatKeysForColumn(columnName).map((key) => CAVEAT_DEFINITIONS[key]);
}

export function getGlobalCaveats(): CaveatDefinition[] {
  return GLOBAL_CAVEAT_KEYS.map((key) => CAVEAT_DEFINITIONS[key]);
}

export function formatCaveatHint(columnName: string): string {
  const keys = getCaveatKeysForColumn(columnName);
  if (keys.length === 0) {
    return "No caveats.";
  }

  return keys.map((key) => CAVEAT_DEFINITIONS[key].title).join(", ");
}
</file>

<file path="src/lib/notebook-store.ts">
export interface NotebookEntry {
  id: string;
  title: string;
  queryDefinition: {
    type: "crosstab" | "profile" | "sql" | "stats";
    params: Record<string, unknown>;
  };
  resultsSnapshot: {
    columns?: string[];
    rows?: unknown[][];
    summary?: Record<string, unknown>;
  };
  notes: string;
  createdAt: string;
  updatedAt: string;
}

const STORAGE_KEY = "bks-notebook-entries";

function generateId(): string {
  return crypto.randomUUID();
}

function readEntries(): NotebookEntry[] {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return [];
    return JSON.parse(raw) as NotebookEntry[];
  } catch {
    return [];
  }
}

function writeEntries(entries: NotebookEntry[]): void {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(entries));
}

export function getNotebookEntries(): NotebookEntry[] {
  return readEntries();
}

export function getNotebookEntry(id: string): NotebookEntry | null {
  const entries = readEntries();
  return entries.find((entry) => entry.id === id) ?? null;
}

export function addNotebookEntry(
  entry: Omit<NotebookEntry, "id" | "createdAt" | "updatedAt">,
): NotebookEntry {
  const now = new Date().toISOString();
  const newEntry: NotebookEntry = {
    ...entry,
    id: generateId(),
    createdAt: now,
    updatedAt: now,
  };

  const entries = readEntries();
  entries.push(newEntry);
  writeEntries(entries);

  return newEntry;
}

export function updateNotebookEntry(
  id: string,
  updates: Partial<Pick<NotebookEntry, "title" | "notes">>,
): NotebookEntry | null {
  const entries = readEntries();
  const index = entries.findIndex((entry) => entry.id === id);
  if (index === -1) return null;

  const updated: NotebookEntry = {
    ...entries[index],
    ...updates,
    updatedAt: new Date().toISOString(),
  };

  entries[index] = updated;
  writeEntries(entries);

  return updated;
}

export function deleteNotebookEntry(id: string): boolean {
  const entries = readEntries();
  const index = entries.findIndex((entry) => entry.id === id);
  if (index === -1) return false;

  entries.splice(index, 1);
  writeEntries(entries);

  return true;
}

export function exportNotebookAsJson(): string {
  const entries = readEntries();
  return JSON.stringify(entries, null, 2);
}
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="src/routes/columns.tsx">
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { useEffect, useMemo, useState } from "react";

import { ColumnInspector } from "@/components/column-inspector";
import { MissingnessBadge } from "@/components/missingness-badge";
import { SectionHeader } from "@/components/section-header";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import type { SchemaData } from "@/lib/api/contracts";
import { getSchema } from "@/lib/client/api";
import { formatNumber, formatPercent } from "@/lib/format";

export const Route = createFileRoute("/columns")({
  validateSearch: (search) => ({
    column: typeof search.column === "string" ? search.column : undefined,
    q: typeof search.q === "string" ? search.q : undefined,
    tags: typeof search.tags === "string" ? search.tags : undefined,
    sort: typeof search.sort === "string" ? search.sort : undefined,
  }),
  component: ColumnsPage,
});

type SortMode =
  | "name"
  | "null_low"
  | "null_high"
  | "cardinality_low"
  | "cardinality_high";

const TAGS = ["demographic", "ocean", "fetish", "derived", "other"] as const;

function ColumnsPage() {
  const search = Route.useSearch();
  const navigate = useNavigate();

  const [schema, setSchema] = useState<SchemaData | null>(null);
  const [schemaError, setSchemaError] = useState<string | null>(null);

  const [searchTerm, setSearchTerm] = useState(search.q ?? "");
  const [selectedTags, setSelectedTags] = useState<string[]>(
    search.tags ? search.tags.split(",").filter(Boolean) : [],
  );
  const [sortMode, setSortMode] = useState<SortMode>(
    (search.sort as SortMode) ?? "name",
  );
  const [selectedColumnName, setSelectedColumnName] = useState<string | null>(
    search.column ?? null,
  );

  useEffect(() => {
    void navigate({
      to: "/columns",
      search: {
        column: selectedColumnName || undefined,
        q: searchTerm || undefined,
        tags: selectedTags.length > 0 ? selectedTags.join(",") : undefined,
        sort: sortMode !== "name" ? sortMode : undefined,
      },
      replace: true,
    });
  }, [selectedColumnName, searchTerm, selectedTags, sortMode, navigate]);

  useEffect(() => {
    let cancelled = false;

    void getSchema()
      .then((response) => {
        if (cancelled) return;
        setSchema(response.data);
        if (!selectedColumnName) {
          setSelectedColumnName(response.data.columns[0]?.name ?? null);
        }
      })
      .catch((error: Error) => {
        if (!cancelled) setSchemaError(error.message);
      });

    return () => {
      cancelled = true;
    };
  }, []);

  const filteredColumns = useMemo(() => {
    if (!schema) return [];

    const term = searchTerm.trim().toLowerCase();

    const filtered = schema.columns.filter((column) => {
      const matchesTerm = term.length === 0 || column.name.toLowerCase().includes(term);
      const matchesTags =
        selectedTags.length === 0 || selectedTags.some((tag) => column.tags.includes(tag as typeof column.tags[number]));
      return matchesTerm && matchesTags;
    });

    const sorted = [...filtered];
    sorted.sort((left, right) => {
      switch (sortMode) {
        case "null_low":
          return left.nullRatio - right.nullRatio;
        case "null_high":
          return right.nullRatio - left.nullRatio;
        case "cardinality_low":
          return left.approxCardinality - right.approxCardinality;
        case "cardinality_high":
          return right.approxCardinality - left.approxCardinality;
        case "name":
        default:
          return left.name.localeCompare(right.name);
      }
    });

    return sorted;
  }, [schema, searchTerm, selectedTags, sortMode]);

  const selectedColumn = useMemo(() => {
    if (!schema || !selectedColumnName) return null;
    return schema.columns.find((column) => column.name === selectedColumnName) ?? null;
  }, [schema, selectedColumnName]);

  return (
    <div className="page">
      <header className="page-header">
        <h1 className="page-title">Column Atlas</h1>
        <p className="page-subtitle">Search, filter, and sort columns. Select one to inspect its distribution and caveats.</p>
      </header>

      {schemaError ? <section className="alert alert--error">Failed to load schema: {schemaError}</section> : null}

      <section className="grid gap-8 xl:grid-cols-[1.2fr,0.8fr]">
        <div className="editorial-panel space-y-4">
          <SectionHeader number="01" title="Atlas" />

          <div className="grid gap-4 lg:grid-cols-2">
            <label className="editorial-label">
              Search Columns
              <Input
                value={searchTerm}
                onChange={(event) => setSearchTerm(event.target.value)}
                placeholder="Type a column name"
              />
            </label>

            <label className="editorial-label">
              Sort
              <Select value={sortMode} onValueChange={(value) => setSortMode(value as SortMode)}>
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="name">Name (A-Z)</SelectItem>
                  <SelectItem value="null_low">Lowest null ratio</SelectItem>
                  <SelectItem value="null_high">Highest null ratio</SelectItem>
                  <SelectItem value="cardinality_low">Lowest cardinality</SelectItem>
                  <SelectItem value="cardinality_high">Highest cardinality</SelectItem>
                </SelectContent>
              </Select>
            </label>
          </div>

          <div>
            <p className="mono-label">Tag Filters</p>
            <div className="mt-2 grid gap-2 sm:grid-cols-2 lg:grid-cols-3">
              {TAGS.map((tag) => {
                const checked = selectedTags.includes(tag);
                return (
                  <label key={tag} className="flex items-center gap-2 border border-[var(--rule)] bg-[var(--paper)] px-2 py-1.5">
                    <Checkbox
                      checked={checked}
                      onCheckedChange={(value) => {
                        if (value === true) {
                          setSelectedTags((current) => [...current, tag]);
                        } else {
                          setSelectedTags((current) => current.filter((item) => item !== tag));
                        }
                      }}
                    />
                    <span className="mono-value">{tag}</span>
                  </label>
                );
              })}
            </div>
          </div>

          <p className="mono-value text-[var(--ink-faded)]">Showing {formatNumber(filteredColumns.length)} columns</p>

          <ScrollArea className="max-h-[calc(100vh-380px)] min-h-[300px] border border-[var(--rule)]">
            {filteredColumns.map((column) => {
              const active = column.name === selectedColumnName;

              return (
                <button
                  key={column.name}
                  type="button"
                  className={`w-full border-b border-[var(--rule-light)] px-3 py-2 text-left ${
                    active ? "bg-[var(--paper-warm)]" : "bg-[var(--paper)]"
                  }`}
                  onClick={() => setSelectedColumnName(column.name)}
                >
                  <div className="flex flex-wrap items-center justify-between gap-2">
                    <span className="mono-value text-[var(--ink)]">{column.name}</span>
                    <div className="flex flex-wrap items-center gap-1">
                      <span className="null-badge">{column.logicalType}</span>
                      <MissingnessBadge meaning={column.nullMeaning} />
                    </div>
                  </div>
                  <div className="mt-1 grid gap-2 md:grid-cols-[1fr,auto,auto] md:items-end">
                    <div>
                      <p className="mono-value text-[var(--ink-faded)]">Null ratio: {formatPercent(column.nullRatio * 100, 1)}</p>
                      <div className="inline-ratio">
                        <span style={{ width: `${Math.max(0, Math.min(100, column.nullRatio * 100))}%` }} />
                      </div>
                    </div>
                    <p className="mono-value text-[var(--ink-faded)]">Cardinality: {formatNumber(column.approxCardinality)}</p>
                    <p className="mono-value text-[var(--ink-faded)]">Caveats: {column.caveatKeys.length}</p>
                  </div>
                </button>
              );
            })}
          </ScrollArea>
        </div>

        <div className="xl:sticky xl:top-4 xl:self-start">
          <ColumnInspector column={selectedColumn} allColumns={schema?.columns ?? []} />
        </div>
      </section>
    </div>
  );
}
</file>

<file path="src/routes/notebook.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { useCallback, useState } from "react";

import { SectionHeader } from "@/components/section-header";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  getNotebookEntries,
  updateNotebookEntry,
  deleteNotebookEntry,
  exportNotebookAsJson,
  type NotebookEntry,
} from "@/lib/notebook-store";

export const Route = createFileRoute("/notebook")({
  component: NotebookPage,
});

function formatDateline(iso: string): string {
  const date = new Date(iso);
  return date
    .toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    })
    .toUpperCase();
}

function resultsSummaryText(entry: NotebookEntry): string {
  const { resultsSnapshot } = entry;

  if (resultsSnapshot.rows && resultsSnapshot.rows.length > 0) {
    const colCount = resultsSnapshot.columns?.length ?? 0;
    return `${resultsSnapshot.rows.length} row${resultsSnapshot.rows.length === 1 ? "" : "s"}${colCount > 0 ? `, ${colCount} column${colCount === 1 ? "" : "s"}` : ""}`;
  }

  if (resultsSnapshot.summary && Object.keys(resultsSnapshot.summary).length > 0) {
    return `${Object.keys(resultsSnapshot.summary).length} summary field${Object.keys(resultsSnapshot.summary).length === 1 ? "" : "s"}`;
  }

  return "No results snapshot";
}

function NotebookPage() {
  const [entries, setEntries] = useState<NotebookEntry[]>(() =>
    getNotebookEntries().sort(
      (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),
    ),
  );

  const [editingTitleId, setEditingTitleId] = useState<string | null>(null);
  const [editingNotesId, setEditingNotesId] = useState<string | null>(null);
  const [editTitleValue, setEditTitleValue] = useState("");
  const [editNotesValue, setEditNotesValue] = useState("");

  const refreshEntries = useCallback(() => {
    setEntries(
      getNotebookEntries().sort(
        (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),
      ),
    );
  }, []);

  const handleTitleClick = useCallback((entry: NotebookEntry) => {
    setEditingTitleId(entry.id);
    setEditTitleValue(entry.title);
  }, []);

  const handleTitleBlur = useCallback(
    (id: string) => {
      updateNotebookEntry(id, { title: editTitleValue });
      setEditingTitleId(null);
      refreshEntries();
    },
    [editTitleValue, refreshEntries],
  );

  const handleNotesClick = useCallback((entry: NotebookEntry) => {
    setEditingNotesId(entry.id);
    setEditNotesValue(entry.notes);
  }, []);

  const handleNotesBlur = useCallback(
    (id: string) => {
      updateNotebookEntry(id, { notes: editNotesValue });
      setEditingNotesId(null);
      refreshEntries();
    },
    [editNotesValue, refreshEntries],
  );

  const handleDelete = useCallback(
    (id: string) => {
      if (!window.confirm("Delete this notebook entry? This cannot be undone.")) return;
      deleteNotebookEntry(id);
      refreshEntries();
    },
    [refreshEntries],
  );

  const handleExport = useCallback(() => {
    const json = exportNotebookAsJson();
    const blob = new Blob([json], { type: "application/json;charset=utf-8" });
    const href = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = href;
    link.download = `bks-notebook-${Date.now()}.json`;
    link.click();
    URL.revokeObjectURL(href);
  }, []);

  return (
    <div className="page">
      <header className="page-header">
        <h1 className="page-title">Research Notebook</h1>
        <p className="page-subtitle">
          Saved findings from explorations, profiles, and SQL queries.
        </p>
      </header>

      <section className="editorial-panel space-y-4">
        <SectionHeader number="01" title="Entries" />

        {entries.length === 0 ? (
          <div className="alert--warn alert">
            No entries yet. Add findings from Explore, Profile, or SQL pages.
          </div>
        ) : (
          <div>
            {entries.map((entry) => (
              <div key={entry.id} className="caveat-item">
                <div className="flex items-start justify-between gap-3">
                  <div className="min-w-0 flex-1">
                    {editingTitleId === entry.id ? (
                      <Input
                        autoFocus
                        value={editTitleValue}
                        onChange={(e) => setEditTitleValue(e.target.value)}
                        onBlur={() => handleTitleBlur(entry.id)}
                        onKeyDown={(e) => {
                          if (e.key === "Enter") handleTitleBlur(entry.id);
                        }}
                      />
                    ) : (
                      <h3
                        className="caveat-title cursor-pointer"
                        onClick={() => handleTitleClick(entry)}
                        title="Click to edit title"
                      >
                        {entry.title}
                      </h3>
                    )}

                    <div className="mt-1 flex flex-wrap items-center gap-2">
                      <span className="null-badge">
                        {entry.queryDefinition.type}
                      </span>
                      <span className="dateline">
                        {formatDateline(entry.createdAt)}
                      </span>
                    </div>

                    <p className="mono-value mt-1.5 text-[var(--ink-faded)]">
                      {resultsSummaryText(entry)}
                    </p>

                    <div className="mt-2">
                      {editingNotesId === entry.id ? (
                        <Textarea
                          autoFocus
                          className="min-h-[60px]"
                          value={editNotesValue}
                          onChange={(e) => setEditNotesValue(e.target.value)}
                          onBlur={() => handleNotesBlur(entry.id)}
                        />
                      ) : (
                        <p
                          className="caveat-description cursor-pointer"
                          onClick={() => handleNotesClick(entry)}
                          title="Click to edit notes"
                        >
                          {entry.notes || "Click to add notes..."}
                        </p>
                      )}
                    </div>
                  </div>

                  <Button
                    variant="accent"
                    size="sm"
                    onClick={() => handleDelete(entry.id)}
                    type="button"
                  >
                    Delete
                  </Button>
                </div>
              </div>
            ))}
          </div>
        )}
      </section>

      <section className="raised-panel space-y-4">
        <SectionHeader number="02" title="Export" />
        <Button
          variant="default"
          onClick={handleExport}
          disabled={entries.length === 0}
          type="button"
        >
          Export as JSON
        </Button>
      </section>
    </div>
  );
}
</file>

<file path="src/routes/relationships.tsx">
import { createFileRoute, Link } from "@tanstack/react-router";
import { useMemo, useState } from "react";

import { SectionHeader } from "@/components/section-header";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { formatNumber } from "@/lib/format";
import relationshipData from "@/lib/schema/relationships.generated.json";

export const Route = createFileRoute("/relationships")({
  component: RelationshipsPage,
});

type Relationship = {
  column: string;
  metric: string;
  value: number;
  n: number;
};

type RelationshipData = {
  generatedAt: string;
  columnCount: number;
  pairCount: number;
  relationships: Record<string, Relationship[]>;
};

const data = relationshipData as RelationshipData;

const columnNames = Object.keys(data.relationships).sort((a, b) =>
  a.localeCompare(b)
);

function strengthLabel(value: number): string {
  if (value < 0.1) return "negligible";
  if (value < 0.3) return "weak";
  if (value < 0.5) return "moderate";
  return "strong";
}

function metricLabel(metric: string): string {
  if (metric === "cramers_v") return "Cramer\u2019s V";
  if (metric === "correlation") return "Correlation";
  return metric;
}

function RelationshipsPage() {
  const [selectedColumn, setSelectedColumn] = useState(columnNames[0] ?? "");

  const relationships = useMemo(() => {
    if (!selectedColumn) return [];
    return data.relationships[selectedColumn] ?? [];
  }, [selectedColumn]);

  const maxValue = useMemo(() => {
    if (relationships.length === 0) return 1;
    return Math.max(...relationships.map((r) => r.value));
  }, [relationships]);

  return (
    <div className="page">
      <header className="page-header">
        <h1 className="page-title">Relationship Finder</h1>
        <p className="page-subtitle">
          Precomputed pairwise associations between survey columns.
          Categorical pairs use Cramer&rsquo;s V; numeric pairs use Pearson
          correlation.
        </p>
        <p className="dateline">
          {formatNumber(data.columnCount)} columns &middot;{" "}
          {formatNumber(data.pairCount)} relationships
        </p>
      </header>

      <section className="raised-panel space-y-4">
        <SectionHeader number="01" title="Target Column" />

        <label className="editorial-label">
          Select a column to see its strongest associations
          <Select value={selectedColumn} onValueChange={setSelectedColumn}>
            <SelectTrigger>
              <SelectValue placeholder="Choose a column" />
            </SelectTrigger>
            <SelectContent>
              {columnNames.map((name) => (
                <SelectItem key={name} value={name}>
                  {name}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </label>
      </section>

      <section className="editorial-panel space-y-4">
        <SectionHeader
          number="02"
          title="Top Related Columns"
          subtitle={
            relationships.length > 0
              ? `${relationships.length} associations for "${selectedColumn}"`
              : "No associations found for this column"
          }
        />

        {relationships.length > 0 ? (
          <div className="editorial-table-wrap">
            <table className="editorial-table">
              <thead>
                <tr>
                  <th>Related Column</th>
                  <th>Metric</th>
                  <th className="numeric">Strength</th>
                  <th>Label</th>
                  <th className="numeric">N</th>
                  <th style={{ width: "120px" }}>Strength</th>
                </tr>
              </thead>
              <tbody>
                {relationships.map((rel) => {
                  const label = strengthLabel(rel.value);
                  const barWidth =
                    maxValue > 0 ? (rel.value / maxValue) * 100 : 0;

                  return (
                    <tr key={rel.column}>
                      <td>
                        <Link
                          to="/explore"
                          search={{ x: selectedColumn, y: rel.column }}
                          className="mono-value"
                          style={{
                            color: "var(--accent)",
                            borderBottom: "1px solid var(--rule-light)",
                          }}
                        >
                          {rel.column}
                        </Link>
                      </td>
                      <td>
                        <span className="null-badge">
                          {metricLabel(rel.metric)}
                        </span>
                      </td>
                      <td className="numeric">
                        <span className="mono-value">
                          {rel.value.toFixed(4)}
                        </span>
                      </td>
                      <td>
                        <span
                          className="null-badge"
                          style={
                            label === "strong"
                              ? {
                                  borderColor: "var(--accent)",
                                  color: "var(--accent)",
                                }
                              : label === "moderate"
                                ? {
                                    borderColor: "#8f5a2b",
                                    color: "#8f5a2b",
                                  }
                                : undefined
                          }
                        >
                          {label}
                        </span>
                      </td>
                      <td className="numeric">
                        <span className="mono-value">
                          {formatNumber(rel.n)}
                        </span>
                      </td>
                      <td>
                        <div className="inline-ratio">
                          <span
                            style={{
                              width: `${barWidth}%`,
                            }}
                          />
                        </div>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        ) : (
          <p className="section-subtitle">
            Select a column above to view its relationships.
          </p>
        )}
      </section>
    </div>
  );
}
</file>

<file path="src/router.tsx">
import { createRouter } from "@tanstack/react-router";
import { routeTree } from "./routeTree.gen";

export function getRouter() {
  const router = createRouter({
    routeTree,
    scrollRestoration: true,
  });

  return router;
}

declare module "@tanstack/react-router" {
  interface Register {
    router: ReturnType<typeof getRouter>;
  }
}
</file>

<file path="repomix-notes.md">
# Repomix Notes — Excluded Content

## Excluded: design-mockups/ (4 HTML files, ~21k tokens)
Four self-contained HTML design mockups exploring different visual directions for the app:
- `01-ink-and-paper.html` — Editorial research journal aesthetic (cream, ink, Fraunces/Source Serif fonts). This was the chosen direction.
- `02-phosphor.html` — Dark/neon terminal aesthetic
- `03-velvet.html` — Rich, warm luxury aesthetic
- `04-signal.html` — Clean, minimal data-viz aesthetic

## Excluded: mcp-server/ (~5.8k tokens)
Python MCP server for AI agent access to the dataset. Key details:
- **File**: `mcp-server/server.py` (~600 lines) — FastMCP server with 5 tools: `get_schema`, `get_stats`, `cross_tabulate`, `query_data`, `search_columns`
- **Transport**: streamable-http (for Railway deployment), stdio (for local use)
- **Safety**: Read-only SQL enforcement, row limits (default 1000, max 10000), timeout guards, typed error envelopes matching API contracts
- **Deployed**: https://bks-mcp-server-production.up.railway.app (Railway Service B)
- **Dockerfile**: Installs mcp>=1.0.0 and duckdb>=1.0.0 via uv, copies data + server, exposes port 8000
- **pyproject.toml**: Minimal config with mcp and duckdb dependencies

## Excluded: test files (~7k tokens)
8 test files with 121 passing tests (Vitest):
- `contracts.test.ts` (42 tests) — Zod schema validation for all API contracts
- `sql-guards.test.ts` + `sql-guards.extended.test.ts` (42 tests) — SQL read-only enforcement, normalization, quoting
- `caveats.test.ts` + `caveats.extended.test.ts` (16 tests) — Caveat pattern matching and formatting
- `metadata.test.ts` (8 tests) — Schema metadata loading and querying
- `api-response.test.ts` (9 tests) — JSON envelope helpers
- `db.test.ts` (4 tests) — Query execution error handling

## Excluded: columns.generated.json (~26k tokens)
Auto-generated schema metadata for all 365 columns. Each entry contains:
- `name`, `logicalType` (categorical|numeric|boolean|text), `nullRatio`, `approxCardinality`
- `categoryTag` (demographic|ocean|fetish|derived|other)
- Regenerate with: `pnpm profile-schema`

## Summary: Big Kink Survey (970k cleaned).md (~45k tokens)

The Big Kink Survey is a large-scale online survey collecting data on human sexuality, kinks, fetishes, and sexual preferences. Participants were recruited primarily through Reddit, FetLife, Twitter, Facebook, and other online platforms. The survey explores relationships between demographic characteristics, childhood experiences, personality traits, and sexual interests.

The full dataset contains ~970k responses; the cleaned public subsample has 15,503 rows (stratified by age bin and biological sex) and 365 columns.

### Survey Structure (5 parts)
1. **Demographics**: gender identity, trans/cis status, HRT usage, sexual orientation, ethnicity, relationship style, location, physical characteristics, political orientation, sexual history
2. **Childhood & Upbringing**: religion, cultural attitudes, social class, locus of control, spanking/abuse history, parental configuration, Big Five personality traits
3. **Sexual Fantasy & Pornography**: emotional states in fantasy, porn consumption patterns, sex work experience, consent preferences, dom/sub orientation
4. **Vanilla Sex Acts**: oral, anal, positions, specific acts, breast size preferences, energy level preferences
5. **Fetish Categories**: hierarchical gating — broad category endorsement, then detailed follow-ups only for endorsed categories (13 "uncommon" + 17 "common" categories)

### Gating Logic
Questions are conditional on previous answers. Key gates: trans-specific questions gate on trans identity; menstrual/HRT questions gate on assigned sex; religion follow-ups gate on having a religion; abuse detail questions gate on reporting abuse; porn preference questions gate on consuming porn; each fetish category's detailed questions gate on endorsing that category. This creates substantial structural missingness — NULLs typically mean "not applicable" rather than "refused to answer."

### Derived Variables
- `biomale` (1=male, 0=female), `gendermale`, `cis`, `gendered` (binary vs nonbinary)
- Big Five composites (e.g., `opennessvariable = openness2 - openness`)
- HRT duration on ordinal scales, binary gender preference for attraction

### Data Quality Caveats
- Rating scales compressed from 0-8 to 0-5/1-5
- Questions added mid-collection create time-cohort missingness (menstrual cycle Nov 2024, horniness May 2025, sex work Oct 2024)
- Gated missingness often represents implicit zeros, not true missing data
- Some vanilla arousal scales use counterintuitive negative scoring
- Only 19 of 365 columns have zero nulls; 64% have >50% null rates (by design)
- The 19 universal columns (age, biomale, OCEAN scores, politics, etc.) are safe starting points for analysis
</file>

<file path="tsconfig.json">
{
  "include": ["**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "target": "ES2022",
    "jsx": "react-jsx",
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "verbatimModuleSyntax": false,
    "noEmit": true,

    /* Linting */
    "skipLibCheck": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import { tanstackStart } from '@tanstack/react-start/plugin/vite'
import { nitro } from 'nitro/vite'
import viteReact from '@vitejs/plugin-react'
import viteTsConfigPaths from 'vite-tsconfig-paths'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
  plugins: [
    viteTsConfigPaths({
      projects: ['./tsconfig.json'],
    }),
    tailwindcss(),
    tanstackStart(),
    nitro(),
    viteReact(),
  ],
})
</file>

<file path="docs/design/architecture.md">
# Architecture

## Stack
- **Framework**: TanStack Start (React) + Nitro (server runtime)
- **Styling**: Tailwind v4
- **Build**: Vite 7, TypeScript strict mode
- **Data engine (web/API)**: DuckDB CLI (`duckdb -json`) over `data/BKSPublic.parquet`
- **Data engine (metadata generation)**: `@duckdb/node-api` in `scripts/profile-schema.mjs`
- **Data engine (MCP)**: DuckDB Python bindings in `mcp-server/server.py`
- **Deploy**: Railway (web service + optional MCP service)

## Key Technical Decisions

### Nitro plugin required for deployment
TanStack Start needs `nitro` from `nitro/vite` in `vite.config.ts` to produce `.output/` build artifacts. Without it, Vite outputs to `dist/` which does not include the Nitro server runtime.

### `verbatimModuleSyntax` disabled
TanStack docs warn that `verbatimModuleSyntax: true` can leak server bundles into client bundles. `tsconfig.json` sets it to `false`.

### Entry files
`src/router.tsx` exports `getRouter()`. `src/routeTree.gen.ts` is auto-generated by TanStack during `pnpm dev`/`pnpm build`.

### API route model
Server routes under `src/routes/api/*` are thin wrappers that:
1. Validate request boundaries via Zod contracts in `src/lib/api/contracts.ts`.
2. Apply SQL/read-only guardrails in `src/lib/server/sql-guards.ts`.
3. Execute bounded queries via `src/lib/server/db.ts`.
4. Return typed JSON envelopes (`ok`/`error`) via `src/lib/server/api-response.ts`.

### Why DuckDB CLI in the server layer
`@duckdb/node-api` is used for schema profiling scripts but currently avoided as the primary runtime engine because Nitro build/bundling with native `.node` bindings is fragile. Runtime API queries execute via the `duckdb` binary and JSON output, with timeout and row-limit controls. A fallback to `@duckdb/node-api` activates automatically when the CLI binary is not available (e.g., on Railway), with bigint normalization for JSON compatibility.

## Data and Metadata Flow
1. Source parquet lives at `data/BKSPublic.parquet`.
2. `pnpm sync-public-data` copies parquet to `public/BKSPublic.parquet`.
3. `pnpm profile-schema` regenerates `src/lib/schema/columns.generated.json`.
4. `/api/schema`, `/api/stats/$column`, `/api/crosstab`, `/api/query` consume that metadata and parquet data.
5. UI pages (`/`, `/explore`, `/profile`, `/sql`) call the API endpoints.

## Current Route Coverage

### UI Pages
- `/about` — intro page: dataset background, methodology caveats, feature guide, credits (links to Aella's blog post)
- `/` — dashboard with schema stats, global caveats, missingness histogram, tag breakdown, column inspector
- `/explore` — cross-tab explorer with pivot matrix, Cramer's V, normalization modes, demographic filters, cell drilldown, notebook save
- `/columns` — Column Atlas with search, tag filters, sort modes, Column Inspector panel, URL state sync
- `/profile` — cohort builder with single/compare modes, percentile cards, over-indexing signals, small-N warnings, notebook save
- `/relationships` — Relationship Finder with precomputed Cramer's V and Pearson correlations for 159 columns
- `/sql` — SQL console with templates, click-to-insert quoted identifiers, CSV export, notebook save
- `/notebook` — Research Notebook with localStorage persistence, inline editing, JSON export

### API Endpoints
- `/api/health`, `/api/schema`, `/api/query`, `/api/stats/$column`, `/api/crosstab`

## Shared Components
- `src/components/pivot-matrix.tsx` — pivot table with normalization, marginals, small-cell suppression
- `src/components/column-inspector.tsx` — column detail panel with stats queries
- `src/components/data-table.tsx` — generic editorial data table
- `src/components/missingness-badge.tsx` — null meaning badge (GATED, LATE_ADDED, etc.)
- `src/components/sample-size-display.tsx` — N/non-null/used display
- `src/components/section-header.tsx` — numbered section headers
- `src/components/stat-card.tsx` — stat display card

## Ad-Hoc Data Queries (for agents)

The `duckdb` CLI is installed locally and can query the parquet file directly. This is the fastest way to inspect data without starting the dev server.

```bash
# Basic query
duckdb -c "SELECT column_name, count(*) FROM read_parquet('data/BKSPublic.parquet') WHERE column_name IS NOT NULL GROUP BY 1 ORDER BY 2 DESC"

# JSON output (for piping/parsing)
duckdb -json -c "SELECT DISTINCT whowears FROM read_parquet('data/BKSPublic.parquet') WHERE whowears IS NOT NULL"

# Describe all columns
duckdb -c "DESCRIBE SELECT * FROM read_parquet('data/BKSPublic.parquet')"

# Sample rows
duckdb -c "SELECT * FROM read_parquet('data/BKSPublic.parquet') LIMIT 5"
```

Note: `@duckdb/node-api` and Python `duckdb` are also available but require their respective runtimes. The CLI is the simplest option — no imports or environment setup needed.

## Key Libraries
- `src/lib/notebook-store.ts` — localStorage CRUD for notebook entries
- `src/lib/cell-hygiene.ts` — small-cell suppression (MIN_CELL_COUNT = 10)
- `src/lib/format.ts` — number/percent formatting utilities
- `src/lib/schema/null-meaning.ts` — null meaning inference (NOT_APPLICABLE, GATED, LATE_ADDED, UNKNOWN)
- `src/lib/schema/metadata.ts` — schema metadata access layer
- `src/lib/schema/relationships.generated.json` — precomputed pairwise associations (3,065 entries)
- `src/lib/duckdb/use-query.ts` — React hook for DuckDB-WASM queries
- `src/lib/duckdb/sql-helpers.ts` — SQL quoting and WHERE clause builder
</file>

<file path="src/lib/api/contracts.ts">
import { z } from "zod";

export const LogicalTypeSchema = z.enum([
  "categorical",
  "numeric",
  "boolean",
  "text",
  "unknown",
]);

export const CategoryTagSchema = z.enum([
  "demographic",
  "ocean",
  "fetish",
  "derived",
  "other",
]);

export const CaveatKeySchema = z.enum([
  "binned_or_collapsed",
  "combined_or_merged",
  "computed_column",
  "negated_scale",
  "opaque_composite",
  "gated_missingness",
  "late_added_questions",
]);

export const NullMeaningSchema = z.enum([
  "GATED",
  "LATE_ADDED",
  "NOT_APPLICABLE",
  "UNKNOWN",
]);

export const CaveatSchema = z.object({
  key: CaveatKeySchema,
  title: z.string(),
  description: z.string(),
  guidance: z.string(),
});

export const ColumnMetadataSchema = z.object({
  name: z.string(),
  duckdbType: z.string(),
  logicalType: LogicalTypeSchema,
  nullRatio: z.number().min(0).max(1),
  approxCardinality: z.number().int().nonnegative(),
  tags: z.array(CategoryTagSchema),
  valueLabels: z.record(z.string(), z.string()).optional(),
  nullMeaning: NullMeaningSchema.default("UNKNOWN"),
  caveatKeys: z.array(CaveatKeySchema).default([]),
});

export const DatasetMetadataSchema = z.object({
  name: z.string(),
  sourcePath: z.string(),
  generatedAt: z.string(),
  rowCount: z.number().int().nonnegative(),
  columnCount: z.number().int().nonnegative(),
});

export const SchemaDataSchema = z.object({
  dataset: DatasetMetadataSchema,
  columns: z.array(ColumnMetadataSchema),
  caveats: z.object({
    global: z.array(CaveatKeySchema),
    definitions: z.array(CaveatSchema),
  }),
});

export const QueryRequestSchema = z.object({
  sql: z.string().trim().min(1),
  limit: z.number().int().positive().max(10_000).optional(),
});

export const QueryDataSchema = z.object({
  columns: z.array(z.string()),
  rows: z.array(z.array(z.unknown())),
});

export const FilterValueSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);

export const FiltersSchema = z.record(
  z.string(),
  z.union([FilterValueSchema, z.array(FilterValueSchema)]),
);

export const CrosstabRequestSchema = z.object({
  x: z.string().min(1),
  y: z.string().min(1),
  limit: z.number().int().positive().max(1_000).optional(),
  filters: FiltersSchema.optional(),
});

export const CrosstabRowSchema = z.object({
  x: z.union([z.string(), z.number(), z.boolean(), z.null()]),
  y: z.union([z.string(), z.number(), z.boolean(), z.null()]),
  count: z.number().int().nonnegative(),
});

export const CrosstabDataSchema = z.object({
  x: z.string(),
  y: z.string(),
  rows: z.array(CrosstabRowSchema),
});

export const NumericStatsSchema = z.object({
  kind: z.literal("numeric"),
  totalCount: z.number().int().nonnegative(),
  nonNullCount: z.number().int().nonnegative(),
  nullCount: z.number().int().nonnegative(),
  mean: z.number().nullable(),
  stddev: z.number().nullable(),
  min: z.number().nullable(),
  p25: z.number().nullable(),
  median: z.number().nullable(),
  p75: z.number().nullable(),
  max: z.number().nullable(),
});

export const CategoryCountSchema = z.object({
  value: z.union([z.string(), z.number(), z.boolean(), z.null()]),
  count: z.number().int().nonnegative(),
  percentage: z.number().min(0).max(100),
});

export const CategoricalStatsSchema = z.object({
  kind: z.literal("categorical"),
  totalCount: z.number().int().nonnegative(),
  nonNullCount: z.number().int().nonnegative(),
  nullCount: z.number().int().nonnegative(),
  topValues: z.array(CategoryCountSchema),
});

export const StatsDataSchema = z.object({
  column: z.string(),
  logicalType: LogicalTypeSchema,
  caveatKeys: z.array(CaveatKeySchema),
  stats: z.union([NumericStatsSchema, CategoricalStatsSchema]),
});

export const ApiErrorSchema = z.object({
  code: z.string(),
  message: z.string(),
  details: z.unknown().optional(),
});

export const ApiSuccessEnvelopeSchema = <T extends z.ZodTypeAny>(dataSchema: T) =>
  z.object({
    ok: z.literal(true),
    data: dataSchema,
    meta: z.record(z.string(), z.unknown()).optional(),
  });

export const ApiErrorEnvelopeSchema = z.object({
  ok: z.literal(false),
  error: ApiErrorSchema,
});

export type QueryRequest = z.infer<typeof QueryRequestSchema>;
export type CrosstabRequest = z.infer<typeof CrosstabRequestSchema>;
export type SchemaData = z.infer<typeof SchemaDataSchema>;
export type QueryData = z.infer<typeof QueryDataSchema>;
export type CrosstabData = z.infer<typeof CrosstabDataSchema>;
export type StatsData = z.infer<typeof StatsDataSchema>;
export type ApiError = z.infer<typeof ApiErrorSchema>;
</file>

<file path="src/lib/schema/metadata.ts">
import rawSchemaMetadata from "./columns.generated.json";
import { isHiddenColumn } from "./column-flags";
import { getCaveatKeysForColumn } from "./caveats";
import { inferNullMeaning } from "./null-meaning";
import type { ColumnMetadata, SchemaMetadata } from "./types";
import { getValueLabels } from "./value-labels";

const schemaMetadata = rawSchemaMetadata as SchemaMetadata;

const columnByName = new Map<string, ColumnMetadata>(
  schemaMetadata.columns.map((column) => [column.name, column]),
);

export function getSchemaMetadata(): SchemaMetadata {
  return schemaMetadata;
}

export function getColumnMetadata(columnName: string): ColumnMetadata | undefined {
  return columnByName.get(columnName);
}

export function listAllColumns(): ColumnMetadata[] {
  return schemaMetadata.columns;
}

export function listColumns(): ColumnMetadata[] {
  return listAllColumns().filter((column) => !isHiddenColumn(column.name));
}

export function listColumnsWithCaveats() {
  return listColumns().map((column) => {
    const caveatKeys = getCaveatKeysForColumn(column.name);
    const valueLabels = getValueLabels(column.name);

    return {
      ...column,
      ...(valueLabels ? { valueLabels } : {}),
      nullMeaning: column.nullMeaning ?? inferNullMeaning(column.name, column.nullRatio, caveatKeys),
      caveatKeys,
    };
  });
}
</file>

<file path="src/lib/schema/types.ts">
export type LogicalType = "categorical" | "numeric" | "boolean" | "text" | "unknown";

export type CategoryTag = "demographic" | "ocean" | "fetish" | "derived" | "other";

export type NullMeaning = "GATED" | "LATE_ADDED" | "NOT_APPLICABLE" | "UNKNOWN";

export interface ColumnMetadata {
  name: string;
  duckdbType: string;
  logicalType: LogicalType;
  nullRatio: number;
  approxCardinality: number;
  tags: CategoryTag[];
  nullMeaning?: NullMeaning;
  valueLabels?: Record<string, string>;
}

export interface DatasetMetadata {
  name: string;
  sourcePath: string;
  generatedAt: string;
  rowCount: number;
  columnCount: number;
}

export interface SchemaMetadata {
  dataset: DatasetMetadata;
  columns: ColumnMetadata[];
}
</file>

<file path="src/routes/__root.tsx">
import {
  HeadContent,
  Link,
  Outlet,
  Scripts,
  createRootRoute,
} from "@tanstack/react-router";

import { DuckDBProvider } from "@/lib/duckdb/provider";
import appCss from "../styles.css?url";

export const Route = createRootRoute({
  head: () => ({
    meta: [
      { charSet: "utf-8" },
      { name: "viewport", content: "width=device-width, initial-scale=1" },
      { title: "Big Kink Survey Explorer" },
    ],
    links: [{ rel: "stylesheet", href: appCss }],
  }),
  component: RootComponent,
  shellComponent: RootDocument,
});

function RootDocument({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <head>
        <HeadContent />
      </head>
      <body>
        {children}
        <Scripts />
      </body>
    </html>
  );
}

const navLinks = [
  { to: "/about", label: "About" },
  { to: "/", label: "Dashboard" },
  { to: "/explore", label: "Explore" },
  { to: "/columns", label: "Columns" },
  { to: "/profile", label: "Profile" },
  { to: "/relationships", label: "Relationships" },
  { to: "/sql", label: "SQL" },
  { to: "/notebook", label: "Notebook" },
] as const;

function RootComponent() {
  return (
    <DuckDBProvider>
      <div className="app-shell">
        <nav className="app-nav">
          <div className="nav-inner">
            <Link to="/" className="brand-link">
              <span className="brand-title">Big Kink Survey Explorer</span>
              <span className="brand-subtitle">Editorial Analysis Workspace</span>
            </Link>
            <div className="nav-links">
              {navLinks.map((link) => (
                <Link
                  key={link.to}
                  to={link.to}
                  className="nav-link"
                  activeProps={{ className: "nav-link nav-link-active" }}
                >
                  {link.label}
                </Link>
              ))}
            </div>
          </div>
        </nav>
        <main className="app-main">
          <Outlet />
        </main>
      </div>
    </DuckDBProvider>
  );
}
</file>

<file path="src/routes/explore.tsx">
import { createFileRoute, Link } from "@tanstack/react-router";
import { useCallback, useEffect, useMemo, useState } from "react";

import { DataTable } from "@/components/data-table";
import { MissingnessBadge } from "@/components/missingness-badge";
import { PivotMatrix, type PivotCellDetail, type PivotNormalization } from "@/components/pivot-matrix";
import { SampleSizeDisplay } from "@/components/sample-size-display";
import { SectionHeader } from "@/components/section-header";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import type { SchemaData } from "@/lib/api/contracts";
import { getSchema } from "@/lib/client/api";
import { MIN_CELL_COUNT, shouldSuppressCell } from "@/lib/cell-hygiene";
import { addNotebookEntry } from "@/lib/notebook-store";
import { buildWhereClause, quoteIdentifier, quoteLiteral } from "@/lib/duckdb/sql-helpers";
import { asNumber, formatNumber, formatPercent } from "@/lib/format";
import { useDuckDBQuery } from "@/lib/duckdb/use-query";

export const Route = createFileRoute("/explore")({
  validateSearch: (search) => ({
    x: typeof search.x === "string" ? search.x : undefined,
    y: typeof search.y === "string" ? search.y : undefined,
  }),
  component: ExplorePage,
});

const NORMALIZATION_OPTIONS: Array<{ value: PivotNormalization; label: string }> = [
  { value: "count", label: "Counts" },
  { value: "row", label: "Row %" },
  { value: "column", label: "Column %" },
  { value: "overall", label: "Overall %" },
];
const NONE_FILTER = "__none_filter__";

function associationLabel(cramersV: number): string {
  if (cramersV < 0.1) return "negligible";
  if (cramersV < 0.3) return "weak";
  if (cramersV < 0.5) return "moderate";
  return "strong";
}

function computeCramersV(rows: Array<{ x: string; y: string; count: number }>): { value: number; nUsed: number } {
  if (rows.length === 0) {
    return { value: 0, nUsed: 0 };
  }

  const rowTotals = new Map<string, number>();
  const colTotals = new Map<string, number>();
  let total = 0;

  for (const row of rows) {
    rowTotals.set(row.y, (rowTotals.get(row.y) ?? 0) + row.count);
    colTotals.set(row.x, (colTotals.get(row.x) ?? 0) + row.count);
    total += row.count;
  }

  const rowCount = rowTotals.size;
  const colCount = colTotals.size;

  if (total <= 0 || rowCount < 2 || colCount < 2) {
    return { value: 0, nUsed: total };
  }

  const observed = new Map<string, number>();
  for (const row of rows) {
    observed.set(`${row.y}\u0000${row.x}`, row.count);
  }

  let chiSquare = 0;
  for (const [yValue, yTotal] of rowTotals.entries()) {
    for (const [xValue, xTotal] of colTotals.entries()) {
      const expected = (yTotal * xTotal) / total;
      if (expected <= 0) continue;

      const obs = observed.get(`${yValue}\u0000${xValue}`) ?? 0;
      chiSquare += ((obs - expected) ** 2) / expected;
    }
  }

  const denominator = total * Math.min(rowCount - 1, colCount - 1);
  if (denominator <= 0) {
    return { value: 0, nUsed: total };
  }

  return {
    value: Math.sqrt(chiSquare / denominator),
    nUsed: total,
  };
}

function ExplorePage() {
  const search = Route.useSearch();

  const [schema, setSchema] = useState<SchemaData | null>(null);
  const [schemaError, setSchemaError] = useState<string | null>(null);

  const [xColumn, setXColumn] = useState("");
  const [yColumn, setYColumn] = useState("");
  const [limit, setLimit] = useState(50);
  const [normalization, setNormalization] = useState<PivotNormalization>("count");
  const [topN, setTopN] = useState(12);

  const [filterColumn, setFilterColumn] = useState("");
  const [selectedFilterValues, setSelectedFilterValues] = useState<string[]>([]);
  const [selectedCell, setSelectedCell] = useState<PivotCellDetail | null>(null);

  useEffect(() => {
    let cancelled = false;

    void getSchema()
      .then((response) => {
        if (cancelled) return;

        const nextSchema = response.data;
        setSchema(nextSchema);

        const preferredX =
          (search.x ? nextSchema.columns.find((c) => c.name === search.x) : undefined) ??
          nextSchema.columns.find((c) => c.name === "straightness") ??
          nextSchema.columns[0];

        const preferredY =
          (search.y ? nextSchema.columns.find((c) => c.name === search.y) : undefined) ??
          nextSchema.columns.find((c) => c.name === "politics") ??
          nextSchema.columns[1];

        setXColumn(preferredX?.name ?? "");
        setYColumn(preferredY?.name ?? "");

        const firstDemoFilter = nextSchema.columns.find(
          (c) => c.tags.includes("demographic") && c.logicalType === "categorical",
        );
        setFilterColumn(firstDemoFilter?.name ?? "");
      })
      .catch((error: Error) => {
        if (!cancelled) setSchemaError(error.message);
      });

    return () => {
      cancelled = true;
    };
  }, [search.x, search.y]);

  const xMeta = useMemo(() => schema?.columns.find((c) => c.name === xColumn) ?? null, [schema, xColumn]);
  const yMeta = useMemo(() => schema?.columns.find((c) => c.name === yColumn) ?? null, [schema, yColumn]);

  const isPivotable =
    xMeta != null &&
    yMeta != null &&
    ["categorical", "boolean"].includes(xMeta.logicalType) &&
    ["categorical", "boolean"].includes(yMeta.logicalType);

  const filterOptionsSql = useMemo(() => {
    if (!filterColumn) return null;
    const quoted = quoteIdentifier(filterColumn);
    return `
      SELECT cast(${quoted} AS VARCHAR) AS value, count(*)::BIGINT AS cnt
      FROM data
      WHERE ${quoted} IS NOT NULL
      GROUP BY 1
      ORDER BY cnt DESC
      LIMIT 20
    `;
  }, [filterColumn]);

  const filterOptionsQuery = useDuckDBQuery(filterOptionsSql);

  const filterOptions = useMemo(() => {
    if (!filterOptionsQuery.data) return [];
    return filterOptionsQuery.data.rows.map((r) => ({
      value: String(r[0] ?? "NULL"),
      count: asNumber(r[1]),
    }));
  }, [filterOptionsQuery.data]);

  useEffect(() => {
    setSelectedFilterValues([]);
  }, [filterColumn]);

  const queryFilters = useMemo(() => {
    if (!filterColumn || selectedFilterValues.length === 0) return undefined;
    return {
      [filterColumn]: selectedFilterValues.map((v) => (v === "NULL" ? null : v)),
    };
  }, [filterColumn, selectedFilterValues]);

  const whereClause = useMemo(() => buildWhereClause(queryFilters), [queryFilters]);

  const crosstabSql = useMemo(() => {
    if (!xColumn || !yColumn) return null;

    const xQuoted = quoteIdentifier(xColumn);
    const yQuoted = quoteIdentifier(yColumn);

    const clauses: string[] = [];
    if (whereClause.startsWith("WHERE ")) {
      clauses.push(whereClause.replace(/^WHERE\s+/i, ""));
    }
    clauses.push(`${xQuoted} IS NOT NULL`);
    clauses.push(`${yQuoted} IS NOT NULL`);

    const fullWhere = clauses.length > 0 ? `WHERE ${clauses.join(" AND ")}` : "";

    return `
      SELECT
        cast(${xQuoted} AS VARCHAR) AS x,
        cast(${yQuoted} AS VARCHAR) AS y,
        count(*)::BIGINT AS count
      FROM data
      ${fullWhere}
      GROUP BY 1, 2
      ORDER BY count DESC
      ${isPivotable ? "" : `LIMIT ${limit}`}
    `;
  }, [xColumn, yColumn, whereClause, isPivotable, limit]);

  const sampleSizeSql = useMemo(() => {
    if (!xColumn || !yColumn) return null;

    const xQuoted = quoteIdentifier(xColumn);
    const yQuoted = quoteIdentifier(yColumn);

    return `
      SELECT
        count(*)::BIGINT AS total_count,
        count(${xQuoted})::BIGINT AS x_non_null,
        count(${yQuoted})::BIGINT AS y_non_null,
        count(*) FILTER (
          WHERE ${xQuoted} IS NOT NULL AND ${yQuoted} IS NOT NULL
        )::BIGINT AS used_count
      FROM data
      ${whereClause}
    `;
  }, [xColumn, yColumn, whereClause]);

  const crosstabQuery = useDuckDBQuery(crosstabSql);
  const sampleSizeQuery = useDuckDBQuery(sampleSizeSql);

  const rows = useMemo(() => {
    if (!crosstabQuery.data) return [];
    return crosstabQuery.data.rows.map((r) => ({
      x: String(r[0] ?? "NULL"),
      y: String(r[1] ?? "NULL"),
      count: asNumber(r[2]),
    }));
  }, [crosstabQuery.data]);

  const sampleSizes = useMemo(() => {
    const row = sampleSizeQuery.data?.rows[0];
    if (!row) {
      return {
        total: 0,
        xNonNull: 0,
        yNonNull: 0,
        used: 0,
      };
    }

    return {
      total: asNumber(row[0]),
      xNonNull: asNumber(row[1]),
      yNonNull: asNumber(row[2]),
      used: asNumber(row[3]),
    };
  }, [sampleSizeQuery.data]);

  const association = useMemo(() => {
    if (!isPivotable) return null;
    return computeCramersV(rows);
  }, [rows, isPivotable]);

  const demographicColumns = useMemo(() => {
    if (!schema) return [];
    return schema.columns.filter(
      (c) => c.tags.includes("demographic") && c.logicalType === "categorical",
    );
  }, [schema]);

  const sqlForCell = useMemo(() => {
    if (!selectedCell || !xColumn || !yColumn) return null;

    const predicates: string[] = [];
    if (queryFilters) {
      for (const [columnName, rawValue] of Object.entries(queryFilters)) {
        if (!Array.isArray(rawValue)) continue;
        const normalized = rawValue.filter((value) => value !== null);
        if (normalized.length > 0) {
          predicates.push(
            `${quoteIdentifier(columnName)} IN (${normalized.map((value) => quoteLiteral(value)).join(", ")})`,
          );
        }
      }
    }

    predicates.push(`${quoteIdentifier(xColumn)} = ${quoteLiteral(selectedCell.x)}`);
    predicates.push(`${quoteIdentifier(yColumn)} = ${quoteLiteral(selectedCell.y)}`);

    return `
SELECT *
FROM data
WHERE ${predicates.join("\n  AND ")}
LIMIT 250
`.trim();
  }, [selectedCell, xColumn, yColumn, queryFilters]);

  const sqlHref = sqlForCell ? `/sql?sql=${encodeURIComponent(sqlForCell)}` : "/sql";

  const [notebookSaved, setNotebookSaved] = useState(false);

  const saveToNotebook = useCallback(() => {
    if (!xColumn || !yColumn || rows.length === 0) return;

    addNotebookEntry({
      title: `Cross-tab: ${xColumn} × ${yColumn}`,
      queryDefinition: {
        type: "crosstab",
        params: {
          x: xColumn,
          y: yColumn,
          normalization,
          filterColumn: filterColumn || undefined,
          filterValues: selectedFilterValues.length > 0 ? selectedFilterValues : undefined,
        },
      },
      resultsSnapshot: {
        columns: ["x", "y", "count"],
        rows: rows.slice(0, 50).map((r) => [r.x, r.y, r.count]),
        summary: association ? { cramersV: association.value, nUsed: association.nUsed } : {},
      },
      notes: "",
    });

    setNotebookSaved(true);
    setTimeout(() => setNotebookSaved(false), 2000);
  }, [xColumn, yColumn, rows, normalization, filterColumn, selectedFilterValues, association]);

  return (
    <div className="page">
      <header className="page-header">
        <h1 className="page-title">Cross-Tab Explorer</h1>
        <p className="page-subtitle">Cross-tabulate any two variables. Normalize, filter by demographics, and measure association strength.</p>
      </header>

      {schemaError ? <section className="alert alert--error">Failed to load schema: {schemaError}</section> : null}

      {schema ? (
        <section className="raised-panel space-y-4">
          <SectionHeader number="01" title="Controls" />

          <div className="grid gap-4 lg:grid-cols-2">
            <label className="editorial-label">
              X Column
              <Select value={xColumn} onValueChange={setXColumn}>
                <SelectTrigger>
                  <SelectValue placeholder="Select X" />
                </SelectTrigger>
                <SelectContent>
                  {schema.columns.map((column) => (
                    <SelectItem key={column.name} value={column.name}>
                      {column.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              {xMeta ? <MissingnessBadge meaning={xMeta.nullMeaning} /> : null}
            </label>

            <label className="editorial-label">
              Y Column
              <Select value={yColumn} onValueChange={setYColumn}>
                <SelectTrigger>
                  <SelectValue placeholder="Select Y" />
                </SelectTrigger>
                <SelectContent>
                  {schema.columns.map((column) => (
                    <SelectItem key={column.name} value={column.name}>
                      {column.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              {yMeta ? <MissingnessBadge meaning={yMeta.nullMeaning} /> : null}
            </label>

            <label className="editorial-label">
              Optional Demographic Filter
              <Select
                value={filterColumn || NONE_FILTER}
                onValueChange={(value) => setFilterColumn(value === NONE_FILTER ? "" : value)}
              >
                <SelectTrigger>
                  <SelectValue placeholder="None" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={NONE_FILTER}>None</SelectItem>
                  {demographicColumns.map((column) => (
                    <SelectItem key={column.name} value={column.name}>
                      {column.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </label>

            <label className="editorial-label">
              Result Row Limit (non-pivot)
              <Input
                type="number"
                name="result_limit"
                min={1}
                max={1000}
                value={limit}
                onChange={(event) =>
                  setLimit(Math.max(1, Math.min(1000, Number(event.target.value) || 1)))
                }
              />
            </label>

            {isPivotable ? (
              <>
                <label className="editorial-label">
                  Normalization
                  <Select value={normalization} onValueChange={(value) => setNormalization(value as PivotNormalization)}>
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      {NORMALIZATION_OPTIONS.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          {option.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </label>

                <label className="editorial-label">
                  Show Top N Categories Per Axis
                  <Input
                    type="number"
                    name="top_n"
                    min={3}
                    max={30}
                    value={topN}
                    onChange={(event) =>
                      setTopN(Math.max(3, Math.min(30, Number(event.target.value) || 3)))
                    }
                  />
                </label>
              </>
            ) : null}
          </div>

          {filterColumn && filterOptions.length > 0 ? (
            <div>
              <p className="mono-label">Filter Values</p>
              <div className="mt-2 grid gap-2 sm:grid-cols-2 lg:grid-cols-3">
                {filterOptions.map((option) => {
                  const checked = selectedFilterValues.includes(option.value);
                  return (
                    <label
                      key={option.value}
                      className="flex items-center justify-between border border-[var(--rule)] bg-[var(--paper)] px-2.5 py-2"
                    >
                      <span className="mono-value truncate pr-2">{option.value}</span>
                      <span className="mono-value text-[var(--ink-faded)]">{formatNumber(option.count)}</span>
                      <Checkbox
                        className="ml-3"
                        checked={checked}
                        onCheckedChange={(nextChecked) => {
                          if (nextChecked === true) {
                            setSelectedFilterValues((current) => [...current, option.value]);
                          } else {
                            setSelectedFilterValues((current) =>
                              current.filter((value) => value !== option.value),
                            );
                          }
                        }}
                      />
                    </label>
                  );
                })}
              </div>
            </div>
          ) : null}
        </section>
      ) : (
        <section className="editorial-panel">Loading schema metadata...</section>
      )}

      <section className="editorial-panel space-y-4">
        <SectionHeader number="02" title="Results" />

        <SampleSizeDisplay
          total={sampleSizes.total}
          nonNull={Math.min(sampleSizes.xNonNull, sampleSizes.yNonNull)}
          used={sampleSizes.used}
        />
        <p className="mono-value">
          N non-null {xColumn || "X"}: {formatNumber(sampleSizes.xNonNull)} | N non-null {yColumn || "Y"}:{" "}
          {formatNumber(sampleSizes.yNonNull)}
        </p>

        {association ? (
          <p className="mono-value">
            Association: V = {association.value.toFixed(3)} ({associationLabel(association.value)}) | N used: {formatNumber(association.nUsed)}
          </p>
        ) : null}

        {rows.length > 0 ? (
          <button
            type="button"
            className="editorial-button"
            onClick={saveToNotebook}
          >
            {notebookSaved ? "Saved!" : "Add to Notebook"}
          </button>
        ) : null}

        {crosstabQuery.loading ? <p className="section-subtitle">Running crosstab query...</p> : null}
        {crosstabQuery.error ? <p className="alert alert--error">{crosstabQuery.error}</p> : null}

        {!crosstabQuery.loading && !crosstabQuery.error ? (
          isPivotable ? (
            <PivotMatrix
              rows={rows}
              topN={topN}
              normalization={normalization}
              minCellCount={MIN_CELL_COUNT}
              onCellClick={setSelectedCell}
            />
          ) : (
            <DataTable
              rows={rows}
              rowKey={(row, index) => `${row.x}-${row.y}-${index}`}
              columns={[
                { id: "x", header: xColumn || "X", cell: (row) => row.x },
                { id: "y", header: yColumn || "Y", cell: (row) => row.y },
                {
                  id: "count",
                  header: "Count",
                  align: "right",
                  cell: (row) =>
                    shouldSuppressCell(row.count)
                      ? "[suppressed]"
                      : formatNumber(row.count),
                },
              ]}
              emptyMessage="No matching rows"
            />
          )
        ) : null}

        {selectedCell ? (
          <aside className="raised-panel space-y-2">
            <SectionHeader number="03" title="Selected Cell" />
            <p className="mono-value">{xColumn}: {selectedCell.x}</p>
            <p className="mono-value">{yColumn}: {selectedCell.y}</p>
            <p className="mono-value">Count: {formatNumber(selectedCell.count)}</p>
            <p className="mono-value">% of row: {formatPercent(selectedCell.rowPercent, 2)}</p>
            <p className="mono-value">% of column: {formatPercent(selectedCell.columnPercent, 2)}</p>
            <p className="mono-value">% overall: {formatPercent(selectedCell.overallPercent, 2)}</p>

            <div className="flex flex-wrap gap-2 pt-1">
              <Link to="/profile" className="editorial-button">
                Open this cohort in Profile
              </Link>
              <a href={sqlHref} className="editorial-button">
                Generate SQL for this cohort
              </a>
            </div>
          </aside>
        ) : null}
      </section>
    </div>
  );
}
</file>

<file path="src/routes/index.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { useEffect, useMemo, useState } from "react";

import { DataTable } from "@/components/data-table";
import { MissingnessBadge } from "@/components/missingness-badge";
import { SampleSizeDisplay } from "@/components/sample-size-display";
import { SectionHeader } from "@/components/section-header";
import { StatCard } from "@/components/stat-card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import type { SchemaData } from "@/lib/api/contracts";
import { getSchema } from "@/lib/client/api";
import { formatNumber, formatPercent, asNumber, asNullableNumber } from "@/lib/format";
import { quoteIdentifier } from "@/lib/duckdb/sql-helpers";
import { useDuckDBQuery } from "@/lib/duckdb/use-query";
import { shouldSuppressCell } from "@/lib/cell-hygiene";

export const Route = createFileRoute("/")({
  component: DashboardPage,
});

interface MissingnessBucket {
  label: string;
  min: number;
  max: number;
}

const MISSINGNESS_BUCKETS: MissingnessBucket[] = [
  { label: "0-10%", min: 0, max: 0.1 },
  { label: "10-25%", min: 0.1, max: 0.25 },
  { label: "25-50%", min: 0.25, max: 0.5 },
  { label: "50-75%", min: 0.5, max: 0.75 },
  { label: "75-100%", min: 0.75, max: 1.01 },
];

function DashboardPage() {
  const [schema, setSchema] = useState<SchemaData | null>(null);
  const [schemaError, setSchemaError] = useState<string | null>(null);
  const [selectedColumn, setSelectedColumn] = useState<string>("");

  useEffect(() => {
    let cancelled = false;

    void getSchema()
      .then((response) => {
        if (cancelled) return;
        setSchema(response.data);
        const preferred = response.data.columns.find((column) => column.name === "straightness");
        setSelectedColumn(preferred?.name ?? response.data.columns[0]?.name ?? "");
      })
      .catch((error: Error) => {
        if (!cancelled) setSchemaError(error.message);
      });

    return () => {
      cancelled = true;
    };
  }, []);

  const selectedMeta = useMemo(() => {
    if (!schema || !selectedColumn) return null;
    return schema.columns.find((c) => c.name === selectedColumn) ?? null;
  }, [schema, selectedColumn]);

  const isNumeric = selectedMeta?.logicalType === "numeric";
  const quoted = selectedColumn ? quoteIdentifier(selectedColumn) : "";

  const countsSql = useMemo(() => {
    if (!selectedColumn) return null;
    return `
      SELECT
        count(*)::BIGINT AS total_count,
        count(${quoted})::BIGINT AS non_null_count,
        (count(*) - count(${quoted}))::BIGINT AS null_count
      FROM data
    `;
  }, [selectedColumn, quoted]);

  const numericSql = useMemo(() => {
    if (!selectedColumn || !isNumeric) return null;
    return `
      SELECT
        avg(${quoted})::DOUBLE AS mean,
        stddev_samp(${quoted})::DOUBLE AS stddev,
        min(${quoted})::DOUBLE AS min_val,
        quantile_cont(${quoted}, 0.25)::DOUBLE AS p25,
        median(${quoted})::DOUBLE AS median_val,
        quantile_cont(${quoted}, 0.75)::DOUBLE AS p75,
        max(${quoted})::DOUBLE AS max_val
      FROM data
      WHERE ${quoted} IS NOT NULL
    `;
  }, [selectedColumn, isNumeric, quoted]);

  const categoricalSql = useMemo(() => {
    if (!selectedColumn || isNumeric) return null;
    return `
      SELECT
        cast(${quoted} AS VARCHAR) AS value,
        count(*)::BIGINT AS cnt
      FROM data
      WHERE ${quoted} IS NOT NULL
      GROUP BY 1
      ORDER BY cnt DESC
      LIMIT 12
    `;
  }, [selectedColumn, isNumeric, quoted]);

  const countsQuery = useDuckDBQuery(countsSql);
  const numericQuery = useDuckDBQuery(numericSql);
  const categoricalQuery = useDuckDBQuery(categoricalSql);

  const statsLoading = countsQuery.loading || (isNumeric ? numericQuery.loading : categoricalQuery.loading);
  const statsError = countsQuery.error ?? (isNumeric ? numericQuery.error : categoricalQuery.error);

  const stats = useMemo(() => {
    if (!countsQuery.data) return null;
    const row = countsQuery.data.rows[0];
    if (!row) return null;

    const totalCount = asNumber(row[0]);
    const nonNullCount = asNumber(row[1]);
    const nullCount = asNumber(row[2]);
    const logicalType = selectedMeta?.logicalType ?? "unknown";

    if (isNumeric && numericQuery.data?.rows[0]) {
      const nr = numericQuery.data.rows[0];
      return {
        logicalType,
        totalCount,
        nonNullCount,
        nullCount,
        kind: "numeric" as const,
        mean: asNullableNumber(nr[0]),
        stddev: asNullableNumber(nr[1]),
        min: asNullableNumber(nr[2]),
        p25: asNullableNumber(nr[3]),
        median: asNullableNumber(nr[4]),
        p75: asNullableNumber(nr[5]),
        max: asNullableNumber(nr[6]),
      };
    }

    if (!isNumeric && categoricalQuery.data) {
      const topValues = categoricalQuery.data.rows.map((r) => {
        const count = asNumber(r[1]);
        return {
          value: (r[0] ?? null) as string | number | boolean | null,
          count,
          percentage: nonNullCount > 0 ? (count / nonNullCount) * 100 : 0,
        };
      });

      return {
        logicalType,
        totalCount,
        nonNullCount,
        nullCount,
        kind: "categorical" as const,
        topValues,
      };
    }

    return null;
  }, [countsQuery.data, numericQuery.data, categoricalQuery.data, isNumeric, selectedMeta]);

  const topMissingColumns = useMemo(() => {
    if (!schema) return [];
    return [...schema.columns].sort((a, b) => b.nullRatio - a.nullRatio).slice(0, 8);
  }, [schema]);

  const tagBreakdown = useMemo(() => {
    if (!schema) return [];

    const counts = new Map<string, number>();
    for (const column of schema.columns) {
      for (const tag of column.tags) {
        counts.set(tag, (counts.get(tag) ?? 0) + 1);
      }
    }

    return [...counts.entries()]
      .sort((left, right) => right[1] - left[1])
      .map(([tag, count]) => ({ tag, count }));
  }, [schema]);

  const missingnessHistogram = useMemo(() => {
    if (!schema) return [];
    return MISSINGNESS_BUCKETS.map((bucket) => {
      const count = schema.columns.filter(
        (column) => column.nullRatio >= bucket.min && column.nullRatio < bucket.max,
      ).length;
      return {
        bucket: bucket.label,
        count,
      };
    });
  }, [schema]);

  const analysisFriendlyColumns = useMemo(() => {
    if (!schema) return [];
    return [...schema.columns]
      .sort((left, right) => {
        if (left.nullRatio !== right.nullRatio) {
          return left.nullRatio - right.nullRatio;
        }
        return left.approxCardinality - right.approxCardinality;
      })
      .slice(0, 10);
  }, [schema]);

  const gatedColumns = useMemo(() => {
    if (!schema) return [];
    return schema.columns
      .filter((column) => column.caveatKeys.includes("gated_missingness"))
      .sort((left, right) => right.nullRatio - left.nullRatio)
      .slice(0, 10);
  }, [schema]);

  return (
    <div className="page">
      <header className="page-header">
        <h1 className="page-title">Dataset Dashboard</h1>
        <p className="page-subtitle">
          Dataset shape, caveats, missingness, and high-signal variables.
        </p>
        <p className="dateline">Updated {new Date().toLocaleDateString("en-US")}</p>
      </header>

      {schemaError ? <section className="alert alert--error">Failed to load schema: {schemaError}</section> : null}

      {schema ? (
        <>
          <section className="stat-grid grid-cols-1 md:grid-cols-3">
            <StatCard label="Rows" value={formatNumber(schema.dataset.rowCount)} />
            <StatCard label="Columns" value={formatNumber(schema.dataset.columnCount)} />
            <StatCard
              label="Generated"
              value={new Date(schema.dataset.generatedAt).toLocaleDateString("en-US")}
              note={new Date(schema.dataset.generatedAt).toLocaleTimeString("en-US")}
            />
          </section>

          <section className="grid gap-8 lg:grid-cols-2">
            <div>
              <SectionHeader number="01" title="Global Caveats" />
              <div className="mt-3">
                {schema.caveats.global.map((key) => {
                  const definition = schema.caveats.definitions.find((item) => item.key === key);
                  if (!definition) return null;

                  return (
                    <article key={key} className="caveat-item">
                      <p className="caveat-title">{definition.title}</p>
                      <p className="caveat-description">{definition.description}</p>
                      <p className="caveat-guidance">{definition.guidance}</p>
                    </article>
                  );
                })}
              </div>
            </div>

            <div>
              <SectionHeader number="02" title="Highest Missingness Columns" />
              <div className="mt-3">
                <DataTable
                  rows={topMissingColumns}
                  rowKey={(row) => row.name}
                  columns={[
                    {
                      id: "column",
                      header: "Column",
                      cell: (row) => (
                        <div className="space-y-1">
                          <span>{row.name}</span>
                          <div>
                            <MissingnessBadge meaning={row.nullMeaning} />
                          </div>
                        </div>
                      ),
                    },
                    {
                      id: "null",
                      header: "Null Ratio",
                      align: "right",
                      cell: (row) => formatPercent(row.nullRatio * 100, 1),
                    },
                  ]}
                />
              </div>
            </div>
          </section>

          <section className="grid gap-8 lg:grid-cols-2">
            <div>
              <SectionHeader number="03" title="Tag Breakdown" />
              <div className="mt-3">
                <DataTable
                  rows={tagBreakdown}
                  rowKey={(row) => row.tag}
                  columns={[
                    { id: "tag", header: "Tag", cell: (row) => row.tag },
                    { id: "count", header: "Columns", align: "right", cell: (row) => formatNumber(row.count) },
                  ]}
                />
              </div>
            </div>

            <div>
              <SectionHeader number="04" title="Missingness Histogram" />
              <div className="mt-3">
                <DataTable
                  rows={missingnessHistogram}
                  rowKey={(row) => row.bucket}
                  columns={[
                    { id: "bucket", header: "Bucket", cell: (row) => row.bucket },
                    { id: "count", header: "Columns", align: "right", cell: (row) => formatNumber(row.count) },
                  ]}
                />
              </div>
            </div>
          </section>

          <section className="grid gap-8 lg:grid-cols-2">
            <div>
              <SectionHeader number="05" title="Most Analysis-Friendly Columns" />
              <div className="mt-3">
                <DataTable
                  rows={analysisFriendlyColumns}
                  rowKey={(row) => row.name}
                  columns={[
                    { id: "name", header: "Column", cell: (row) => row.name },
                    {
                      id: "null",
                      header: "Null %",
                      align: "right",
                      cell: (row) => formatPercent(row.nullRatio * 100, 1),
                    },
                    {
                      id: "cardinality",
                      header: "Cardinality",
                      align: "right",
                      cell: (row) => formatNumber(row.approxCardinality),
                    },
                  ]}
                />
              </div>
            </div>

            <div>
              <SectionHeader number="06" title="Most Gated Columns" />
              <div className="mt-3">
                <DataTable
                  rows={gatedColumns}
                  rowKey={(row) => row.name}
                  columns={[
                    {
                      id: "name",
                      header: "Column",
                      cell: (row) => (
                        <div className="space-y-1">
                          <span>{row.name}</span>
                          <div>
                            <MissingnessBadge meaning={row.nullMeaning} />
                          </div>
                        </div>
                      ),
                    },
                    {
                      id: "null",
                      header: "Null %",
                      align: "right",
                      cell: (row) => formatPercent(row.nullRatio * 100, 1),
                    },
                  ]}
                />
              </div>
            </div>
          </section>

          <section className="raised-panel space-y-4">
            <SectionHeader number="07" title="Column Inspector (Inline)" />

            <label className="editorial-label max-w-[460px]">
              Column
              <Select value={selectedColumn} onValueChange={setSelectedColumn}>
                <SelectTrigger>
                  <SelectValue placeholder="Select a column" />
                </SelectTrigger>
                <SelectContent>
                  {schema.columns.map((column) => (
                    <SelectItem key={column.name} value={column.name}>
                      {column.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </label>

            {selectedMeta ? (
              <div className="space-y-3">
                <div className="flex flex-wrap items-center gap-2">
                  <span className="mono-value">{selectedMeta.name}</span>
                  <span className="null-badge">{selectedMeta.logicalType}</span>
                  <MissingnessBadge meaning={selectedMeta.nullMeaning} />
                </div>
                {stats ? (
                  <SampleSizeDisplay total={stats.totalCount} nonNull={stats.nonNullCount} used={stats.nonNullCount} />
                ) : null}
              </div>
            ) : null}

            {statsLoading ? <p className="section-subtitle">Loading stats...</p> : null}
            {statsError ? <p className="alert alert--error">{statsError}</p> : null}

            {stats && !statsLoading ? (
              <>
                {stats.kind === "numeric" ? (
                  <DataTable
                    rows={[
                      { metric: "Mean", value: stats.mean },
                      { metric: "Stddev", value: stats.stddev },
                      { metric: "Min", value: stats.min },
                      { metric: "P25", value: stats.p25 },
                      { metric: "Median", value: stats.median },
                      { metric: "P75", value: stats.p75 },
                      { metric: "Max", value: stats.max },
                    ]}
                    rowKey={(row) => row.metric}
                    columns={[
                      { id: "metric", header: "Metric", cell: (row) => row.metric },
                      {
                        id: "value",
                        header: "Value",
                        align: "right",
                        cell: (row) => (row.value == null ? "n/a" : row.value.toFixed(3)),
                      },
                    ]}
                  />
                ) : (
                  <DataTable
                    rows={stats.topValues}
                    rowKey={(row) => String(row.value ?? "NULL")}
                    columns={[
                      { id: "value", header: "Value", cell: (row) => String(row.value ?? "NULL") },
                      {
                        id: "count",
                        header: "Count",
                        align: "right",
                        cell: (row) =>
                          shouldSuppressCell(row.count) ? "[suppressed]" : formatNumber(row.count),
                      },
                      {
                        id: "pct",
                        header: "%",
                        align: "right",
                        cell: (row) =>
                          shouldSuppressCell(row.count) ? "[suppressed]" : formatPercent(row.percentage, 2),
                      },
                    ]}
                  />
                )}
              </>
            ) : null}
          </section>
        </>
      ) : (
        <section className="editorial-panel">Loading schema metadata...</section>
      )}
    </div>
  );
}
</file>

<file path="src/routes/profile.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { useCallback, useEffect, useMemo, useState } from "react";

import { DataTable } from "@/components/data-table";
import { SectionHeader } from "@/components/section-header";
import { StatCard } from "@/components/stat-card";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import type { SchemaData } from "@/lib/api/contracts";
import { getSchema } from "@/lib/client/api";
import { MIN_CELL_COUNT, shouldSuppressCell } from "@/lib/cell-hygiene";
import { useDuckDB } from "@/lib/duckdb/provider";
import { quoteIdentifier, quoteLiteral } from "@/lib/duckdb/sql-helpers";
import { asNumber, formatNumber, formatPercent } from "@/lib/format";
import { addNotebookEntry } from "@/lib/notebook-store";

export const Route = createFileRoute("/profile")({
  component: ProfilePage,
});

interface ProfileSummary {
  totalSize: number;
  cohortSize: number;
  cohortSharePercent: number;
  uniquenessPercentile: number;
  percentileCards: Array<{
    metric: string;
    cohortMedian: number | null;
    globalPercentile: number | null;
  }>;
  overIndexing: Array<{
    columnName: string;
    value: string;
    cohortCount: number;
    globalCount: number;
    cohortPct: number;
    globalPct: number;
    ratio: number;
  }>;
}

interface ComparisonResult {
  a: ProfileSummary;
  b: ProfileSummary;
}

interface ComparisonPercentileRow {
  metric: string;
  medianA: number | null;
  medianB: number | null;
  delta: number | null;
}

type Mode = "single" | "compare";

const NONE = "__none__";

type FilterPair = { column: string; value: string };

function getWarning(cohortSize: number) {
  if (cohortSize < 30) {
    return {
      kind: "critical" as const,
      message: "N < 30: Too small for reliable comparisons.",
    };
  }
  if (cohortSize < 100) {
    return {
      kind: "warn" as const,
      message: "N < 100: Treat patterns as unstable.",
    };
  }
  return null;
}

function ProfilePage() {
  const { db } = useDuckDB();
  const [schema, setSchema] = useState<SchemaData | null>(null);
  const [schemaError, setSchemaError] = useState<string | null>(null);

  const [mode, setMode] = useState<Mode>("single");

  // Single-cohort state
  const [selectedColumns, setSelectedColumns] = useState<[string, string, string]>(["", "", ""]);
  const [selectedValues, setSelectedValues] = useState<Record<string, string>>({});
  const [valueOptionsByColumn, setValueOptionsByColumn] = useState<Record<string, string[]>>({});

  // Compare-cohort state
  const [columnsA, setColumnsA] = useState<[string, string, string]>(["", "", ""]);
  const [valuesA, setValuesA] = useState<Record<string, string>>({});
  const [valueOptionsA, setValueOptionsA] = useState<Record<string, string[]>>({});

  const [columnsB, setColumnsB] = useState<[string, string, string]>(["", "", ""]);
  const [valuesB, setValuesB] = useState<Record<string, string>>({});
  const [valueOptionsB, setValueOptionsB] = useState<Record<string, string[]>>({});

  const [summary, setSummary] = useState<ProfileSummary | null>(null);
  const [comparison, setComparison] = useState<ComparisonResult | null>(null);
  const [runError, setRunError] = useState<string | null>(null);
  const [running, setRunning] = useState(false);
  const [notebookSaved, setNotebookSaved] = useState(false);

  useEffect(() => {
    let cancelled = false;

    void getSchema()
      .then((response) => {
        if (cancelled) return;
        setSchema(response.data);

        const demographicColumns = response.data.columns
          .filter((c) => c.tags.includes("demographic") && c.logicalType === "categorical")
          .slice(0, 3)
          .map((c) => c.name);

        const defaults: [string, string, string] = [
          demographicColumns[0] ?? "",
          demographicColumns[1] ?? "",
          demographicColumns[2] ?? "",
        ];

        setSelectedColumns(defaults);
        setColumnsA([...defaults]);
        setColumnsB([...defaults]);
      })
      .catch((error: Error) => {
        if (!cancelled) setSchemaError(error.message);
      });

    return () => {
      cancelled = true;
    };
  }, []);

  // Load value options for single-cohort columns
  useEffect(() => {
    if (!db) return;

    const activeColumns = selectedColumns.filter((column) => Boolean(column));
    if (activeColumns.length === 0) return;

    let cancelled = false;

    void loadValueOptions(activeColumns)
      .then((next) => {
        if (!cancelled) setValueOptionsByColumn(next);
      })
      .catch(() => {
        if (!cancelled) setValueOptionsByColumn({});
      });

    return () => {
      cancelled = true;
    };
  }, [selectedColumns, db]);

  // Load value options for cohort A columns
  useEffect(() => {
    if (!db) return;

    const activeColumns = columnsA.filter((column) => Boolean(column));
    if (activeColumns.length === 0) return;

    let cancelled = false;

    void loadValueOptions(activeColumns)
      .then((next) => {
        if (!cancelled) setValueOptionsA(next);
      })
      .catch(() => {
        if (!cancelled) setValueOptionsA({});
      });

    return () => {
      cancelled = true;
    };
  }, [columnsA, db]);

  // Load value options for cohort B columns
  useEffect(() => {
    if (!db) return;

    const activeColumns = columnsB.filter((column) => Boolean(column));
    if (activeColumns.length === 0) return;

    let cancelled = false;

    void loadValueOptions(activeColumns)
      .then((next) => {
        if (!cancelled) setValueOptionsB(next);
      })
      .catch(() => {
        if (!cancelled) setValueOptionsB({});
      });

    return () => {
      cancelled = true;
    };
  }, [columnsB, db]);

  const loadValueOptions = useCallback(
    async (activeColumns: string[]): Promise<Record<string, string[]>> => {
      if (!db) return {};

      const entries = await Promise.all(
        activeColumns.map(async (column) => {
          const quoted = quoteIdentifier(column);
          const sql = `
            SELECT cast(${quoted} AS VARCHAR) AS value, count(*)::BIGINT AS cnt
            FROM data
            WHERE ${quoted} IS NOT NULL
            GROUP BY 1
            ORDER BY cnt DESC
            LIMIT 20
          `;

          const conn = await db.connect();
          try {
            const result = await conn.query(sql);
            const values: string[] = [];
            for (let i = 0; i < result.numRows; i++) {
              values.push(String(result.getChildAt(0)?.get(i) ?? "NULL"));
            }
            return [column, values] as const;
          } finally {
            await conn.close();
          }
        }),
      );

      const next: Record<string, string[]> = {};
      for (const [column, options] of entries) {
        next[column] = options;
      }
      return next;
    },
    [db],
  );

  const availableDemographicColumns = useMemo(() => {
    if (!schema) return [];
    return schema.columns.filter(
      (c) => c.tags.includes("demographic") && c.logicalType === "categorical",
    );
  }, [schema]);

  const filterPairs = useMemo(() => {
    return selectedColumns
      .map((column) => ({ column, value: selectedValues[column] }))
      .filter((item): item is FilterPair => Boolean(item.column && item.value));
  }, [selectedColumns, selectedValues]);

  const filterPairsA = useMemo(() => {
    return columnsA
      .map((column) => ({ column, value: valuesA[column] }))
      .filter((item): item is FilterPair => Boolean(item.column && item.value));
  }, [columnsA, valuesA]);

  const filterPairsB = useMemo(() => {
    return columnsB
      .map((column) => ({ column, value: valuesB[column] }))
      .filter((item): item is FilterPair => Boolean(item.column && item.value));
  }, [columnsB, valuesB]);

  const canRun = mode === "single"
    ? filterPairs.length > 0 && !running && !!db
    : filterPairsA.length > 0 && filterPairsB.length > 0 && !running && !!db;

  const buildCondition = useCallback((pairs: FilterPair[]) => {
    return pairs
      .map((pair) => `${quoteIdentifier(pair.column)} = ${quoteLiteral(pair.value)}`)
      .join(" AND ");
  }, []);

  const runSingleCohort = useCallback(
    async (condition: string): Promise<ProfileSummary> => {
      if (!db) throw new Error("DuckDB not available");

      const conn = await db.connect();
      try {
        const runSql = async (sql: string) => {
          const result = await conn.query(sql);
          const rows: unknown[][] = [];
          for (let i = 0; i < result.numRows; i++) {
            const row: unknown[] = [];
            for (let c = 0; c < result.schema.fields.length; c++) {
              let val = result.getChildAt(c)?.get(i);
              if (typeof val === "bigint") val = Number(val);
              row.push(val ?? null);
            }
            rows.push(row);
          }
          return rows;
        };

        const sizeRows = await runSql(`
          SELECT
            count(*)::BIGINT AS total_size,
            count(*) FILTER (WHERE ${condition})::BIGINT AS cohort_size
          FROM data
        `);

        const totalSize = asNumber(sizeRows[0]?.[0]);
        const cohortSize = asNumber(sizeRows[0]?.[1]);
        const cohortSharePercent = totalSize > 0 ? (cohortSize / totalSize) * 100 : 0;
        const uniquenessPercentile = Math.max(0, Math.min(100, 100 - cohortSharePercent));

        const metricCandidates = [
          "totalfetishcategory",
          "powerlessnessvariable",
          "opennessvariable",
          "extroversionvariable",
          "neuroticismvariable",
        ].filter((metric) => schema?.columns.some((c) => c.name === metric));

        const percentileCards = await Promise.all(
          metricCandidates.map(async (metric) => {
            const rows = await runSql(`
              WITH cohort AS (
                SELECT quantile_cont(${quoteIdentifier(metric)}, 0.5)::DOUBLE AS cohort_median
                FROM data
                WHERE ${condition} AND ${quoteIdentifier(metric)} IS NOT NULL
              )
              SELECT
                (SELECT cohort_median FROM cohort) AS cohort_median,
                CASE
                  WHEN (SELECT cohort_median FROM cohort) IS NULL THEN NULL
                  ELSE (
                    SELECT
                      100.0 *
                      SUM(CASE WHEN ${quoteIdentifier(metric)} <= (SELECT cohort_median FROM cohort) THEN 1 ELSE 0 END)::DOUBLE /
                      COUNT(*)::DOUBLE
                    FROM data
                    WHERE ${quoteIdentifier(metric)} IS NOT NULL
                  )
                END AS percentile
            `);

            return {
              metric,
              cohortMedian: rows[0]?.[0] == null ? null : Number(rows[0][0]),
              globalPercentile: rows[0]?.[1] == null ? null : Number(rows[0][1]),
            };
          }),
        );

        const candidateCategoricalColumns =
          schema?.columns
            .filter(
              (column) =>
                column.logicalType === "categorical" &&
                (column.tags.includes("demographic") || column.tags.includes("ocean")),
            )
            .slice(0, 30)
            .map((column) => column.name) ?? [];

        const overIndexingRows =
          candidateCategoricalColumns.length === 0
            ? []
            : await runSql(`
                WITH counts AS (
                  ${candidateCategoricalColumns
                    .map((columnName) => {
                      const quoted = quoteIdentifier(columnName);
                      return `
                        SELECT
                          ${quoteLiteral(columnName)} AS column_name,
                          cast(${quoted} AS VARCHAR) AS value,
                          SUM(CASE WHEN ${condition} THEN 1 ELSE 0 END)::DOUBLE AS cohort_count,
                          COUNT(*)::DOUBLE AS global_count
                        FROM data
                        WHERE ${quoted} IS NOT NULL
                        GROUP BY 1, 2
                      `;
                    })
                    .join(" UNION ALL ")}
                ),
                sizes AS (
                  SELECT
                    count(*) FILTER (WHERE ${condition})::DOUBLE AS cohort_size,
                    count(*)::DOUBLE AS global_size
                  FROM data
                ),
                scored AS (
                  SELECT
                    counts.column_name,
                    counts.value,
                    counts.cohort_count,
                    counts.global_count,
                    CASE WHEN sizes.cohort_size = 0 THEN 0 ELSE counts.cohort_count / sizes.cohort_size END AS cohort_pct,
                    CASE WHEN sizes.global_size = 0 THEN 0 ELSE counts.global_count / sizes.global_size END AS global_pct
                  FROM counts
                  CROSS JOIN sizes
                ),
                ranked AS (
                  SELECT
                    column_name,
                    value,
                    cohort_count,
                    global_count,
                    cohort_pct,
                    global_pct,
                    CASE WHEN global_pct <= 0 THEN NULL ELSE cohort_pct / global_pct END AS ratio
                  FROM scored
                )
                SELECT
                  column_name,
                  value,
                  cohort_count,
                  global_count,
                  cohort_pct,
                  global_pct,
                  ratio
                FROM ranked
                WHERE cohort_count >= 30
                  AND global_count >= 30
                  AND ratio IS NOT NULL
                ORDER BY ratio DESC, cohort_count DESC
                LIMIT 8
              `);

        const overIndexing = overIndexingRows.map((row) => ({
          columnName: String(row[0] ?? ""),
          value: String(row[1] ?? ""),
          cohortCount: asNumber(row[2]),
          globalCount: asNumber(row[3]),
          cohortPct: asNumber(row[4]) * 100,
          globalPct: asNumber(row[5]) * 100,
          ratio: asNumber(row[6]),
        }));

        return {
          totalSize,
          cohortSize,
          cohortSharePercent,
          uniquenessPercentile,
          percentileCards,
          overIndexing,
        };
      } finally {
        await conn.close();
      }
    },
    [db, schema],
  );

  const runProfile = useCallback(async () => {
    if (mode === "single") {
      if (filterPairs.length === 0 || !db) {
        setRunError("Select at least one demographic value before running profile analysis.");
        return;
      }

      setRunning(true);
      setRunError(null);
      setComparison(null);

      try {
        const condition = buildCondition(filterPairs);
        const result = await runSingleCohort(condition);
        setSummary(result);
      } catch (error) {
        setRunError(error instanceof Error ? error.message : "Failed to run profile analysis.");
      } finally {
        setRunning(false);
      }
    } else {
      if (filterPairsA.length === 0 || filterPairsB.length === 0 || !db) {
        setRunError("Select at least one demographic value for each cohort.");
        return;
      }

      setRunning(true);
      setRunError(null);
      setSummary(null);

      try {
        const conditionA = buildCondition(filterPairsA);
        const conditionB = buildCondition(filterPairsB);
        const [a, b] = await Promise.all([
          runSingleCohort(conditionA),
          runSingleCohort(conditionB),
        ]);
        setComparison({ a, b });
      } catch (error) {
        setRunError(error instanceof Error ? error.message : "Failed to run comparison analysis.");
      } finally {
        setRunning(false);
      }
    }
  }, [mode, db, filterPairs, filterPairsA, filterPairsB, buildCondition, runSingleCohort]);

  const warning = useMemo(() => {
    if (!summary) return null;
    return getWarning(summary.cohortSize);
  }, [summary]);

  const comparisonPercentileRows = useMemo((): ComparisonPercentileRow[] => {
    if (!comparison) return [];
    const { a, b } = comparison;

    const metricsSet = new Set([
      ...a.percentileCards.map((c) => c.metric),
      ...b.percentileCards.map((c) => c.metric),
    ]);

    return Array.from(metricsSet).map((metric) => {
      const cardA = a.percentileCards.find((c) => c.metric === metric);
      const cardB = b.percentileCards.find((c) => c.metric === metric);
      const medianA = cardA?.cohortMedian ?? null;
      const medianB = cardB?.cohortMedian ?? null;
      const delta = medianA != null && medianB != null ? medianB - medianA : null;
      return { metric, medianA, medianB, delta };
    });
  }, [comparison]);

  const renderFilterSlots = (
    columns: [string, string, string],
    setColumns: React.Dispatch<React.SetStateAction<[string, string, string]>>,
    values: Record<string, string>,
    setValues: React.Dispatch<React.SetStateAction<Record<string, string>>>,
    valueOptions: Record<string, string[]>,
  ) => (
    <div className="grid gap-4 md:grid-cols-3">
      {[0, 1, 2].map((slot) => {
        const column = columns[slot] ?? "";
        const options = valueOptions[column] ?? [];

        return (
          <div key={`slot-${slot}`} className="space-y-2 border border-[var(--rule)] bg-[var(--paper)] p-3">
            <label className="editorial-label">
              Field {slot + 1}
              <Select
                value={column || NONE}
                onValueChange={(value) => {
                  const resolved = value === NONE ? "" : value;
                  const next = [...columns] as [string, string, string];
                  next[slot] = resolved;
                  setColumns(next);
                }}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select a column" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={NONE}>None</SelectItem>
                  {availableDemographicColumns.map((item) => (
                    <SelectItem key={item.name} value={item.name}>
                      {item.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </label>

            <label className="editorial-label">
              Value
              <Select
                value={values[column] || NONE}
                onValueChange={(value) => {
                  const resolved = value === NONE ? "" : value;
                  setValues((current) => ({
                    ...current,
                    [column]: resolved,
                  }));
                }}
                disabled={!column || options.length === 0}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select value" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={NONE}>None</SelectItem>
                  {options.map((option) => (
                    <SelectItem key={option} value={option}>
                      {option}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </label>
          </div>
        );
      })}
    </div>
  );

  const renderWarningBanner = (cohortSize: number) => {
    const w = getWarning(cohortSize);
    if (!w) return null;
    return (
      <p className={`alert ${w.kind === "critical" ? "alert--critical" : "alert--warn"}`}>
        {w.message}
      </p>
    );
  };

  const saveToNotebook = useCallback(() => {
    const activeSummary = mode === "single" ? summary : null;
    const activeComparison = mode === "compare" ? comparison : null;

    if (!activeSummary && !activeComparison) return;

    const filters = mode === "single" ? filterPairs : [...filterPairsA, ...filterPairsB];
    const filterDesc = filters.map((f) => `${f.column}=${f.value}`).join(", ");

    addNotebookEntry({
      title: `Profile: ${filterDesc}`,
      queryDefinition: {
        type: "profile",
        params: {
          mode,
          ...(mode === "single" ? { filters: filterPairs } : { filtersA: filterPairsA, filtersB: filterPairsB }),
        },
      },
      resultsSnapshot: {
        summary: activeSummary
          ? {
              cohortSize: activeSummary.cohortSize,
              cohortShare: activeSummary.cohortSharePercent,
              topOverIndexing: activeSummary.overIndexing.slice(0, 5).map((o) => `${o.columnName}=${o.value} (${o.ratio.toFixed(1)}x)`),
            }
          : activeComparison
            ? {
                cohortA: activeComparison.a.cohortSize,
                cohortB: activeComparison.b.cohortSize,
              }
            : {},
      },
      notes: "",
    });

    setNotebookSaved(true);
    setTimeout(() => setNotebookSaved(false), 2000);
  }, [mode, summary, comparison, filterPairs, filterPairsA, filterPairsB]);

  const deltaDirection = (delta: number): string => {
    if (delta > 0) return "higher";
    if (delta < 0) return "lower";
    return "equal";
  };

  return (
    <div className="page">
      <header className="page-header">
        <h1 className="page-title">Profile Builder</h1>
        <p className="page-subtitle">Define a demographic cohort and see what over-indexes against the full dataset.</p>
      </header>

      {schemaError ? <section className="alert alert--error">Failed to load schema: {schemaError}</section> : null}

      {schema ? (
        <section className="raised-panel space-y-4">
          <SectionHeader number="01" title="Profile Inputs" />

          <div className="flex gap-0 border border-[var(--rule)]" style={{ width: "fit-content" }}>
            <button
              type="button"
              className={`px-4 py-2 text-[0.75rem] tracking-[0.08em] uppercase font-['JetBrains_Mono',ui-monospace,monospace] border-r border-[var(--rule)] transition-colors ${
                mode === "single"
                  ? "bg-[var(--ink)] text-[var(--paper)]"
                  : "bg-[var(--paper)] text-[var(--ink)] hover:text-[var(--accent-hover)]"
              }`}
              onClick={() => {
                setMode("single");
                setComparison(null);
                setRunError(null);
              }}
            >
              Single Cohort
            </button>
            <button
              type="button"
              className={`px-4 py-2 text-[0.75rem] tracking-[0.08em] uppercase font-['JetBrains_Mono',ui-monospace,monospace] transition-colors ${
                mode === "compare"
                  ? "bg-[var(--ink)] text-[var(--paper)]"
                  : "bg-[var(--paper)] text-[var(--ink)] hover:text-[var(--accent-hover)]"
              }`}
              onClick={() => {
                setMode("compare");
                setSummary(null);
                setRunError(null);
              }}
            >
              Compare Cohorts
            </button>
          </div>

          {mode === "single" ? (
            renderFilterSlots(
              selectedColumns,
              setSelectedColumns,
              selectedValues,
              setSelectedValues,
              valueOptionsByColumn,
            )
          ) : (
            <div className="grid gap-6 md:grid-cols-2">
              <div className="space-y-3 border border-[var(--rule)] p-4">
                <p className="mono-label" style={{ fontSize: "0.75rem", letterSpacing: "0.08em", textTransform: "uppercase" }}>
                  Cohort A
                </p>
                {renderFilterSlots(columnsA, setColumnsA, valuesA, setValuesA, valueOptionsA)}
              </div>
              <div className="space-y-3 border border-[var(--rule)] p-4">
                <p className="mono-label" style={{ fontSize: "0.75rem", letterSpacing: "0.08em", textTransform: "uppercase" }}>
                  Cohort B
                </p>
                {renderFilterSlots(columnsB, setColumnsB, valuesB, setValuesB, valueOptionsB)}
              </div>
            </div>
          )}

          <Button
            type="button"
            onClick={() => {
              void runProfile();
            }}
            disabled={!canRun}
            variant="default"
          >
            {running
              ? "Running..."
              : mode === "single"
                ? "Build Profile"
                : "Compare"}
          </Button>

          {runError ? <p className="alert alert--error">{runError}</p> : null}
        </section>
      ) : (
        <section className="editorial-panel">Loading schema metadata...</section>
      )}

      {/* --- Single cohort results --- */}
      {summary ? (
        <section className="space-y-4">
          <div className="flex items-center justify-between">
            <SectionHeader number="02" title="People-Like-You Summary" />
            <button type="button" className="editorial-button" onClick={saveToNotebook}>
              {notebookSaved ? "Saved!" : "Add to Notebook"}
            </button>
          </div>

          <div className="stat-grid grid-cols-1 md:grid-cols-4">
            <StatCard label="Dataset Size" value={formatNumber(summary.totalSize)} />
            <StatCard label="Cohort Size" value={formatNumber(summary.cohortSize)} />
            <StatCard
              label="Cohort Share"
              value={formatPercent(summary.cohortSharePercent, 2)}
              note={`N = ${formatNumber(summary.cohortSize)}`}
            />
            <StatCard
              label="Uniqueness Percentile"
              value={formatPercent(summary.uniquenessPercentile, 2)}
              note={`N = ${formatNumber(summary.cohortSize)}`}
            />
          </div>

          {warning ? (
            <p className={`alert ${warning.kind === "critical" ? "alert--critical" : "alert--warn"}`}>
              {warning.message}
            </p>
          ) : null}

          <div className="raised-panel space-y-3">
            <SectionHeader number="03" title="Percentile Metrics" />
            <DataTable
              rows={summary.percentileCards}
              rowKey={(row) => row.metric}
              columns={[
                { id: "metric", header: "Metric", cell: (row) => row.metric },
                {
                  id: "cohort",
                  header: "Cohort Median",
                  align: "right",
                  cell: (row) => {
                    if (summary.cohortSize < MIN_CELL_COUNT) return "[suppressed]";
                    return row.cohortMedian == null ? "n/a" : row.cohortMedian.toFixed(3);
                  },
                },
                {
                  id: "global",
                  header: "Global Percentile",
                  align: "right",
                  cell: (row) => {
                    if (summary.cohortSize < MIN_CELL_COUNT) return "[suppressed]";
                    return row.globalPercentile == null ? "n/a" : formatPercent(row.globalPercentile, 2);
                  },
                },
                {
                  id: "n",
                  header: "N",
                  align: "right",
                  cell: () => formatNumber(summary.cohortSize),
                },
              ]}
            />
          </div>

          <div className="raised-panel space-y-3">
            <SectionHeader number="04" title="Top Over-Indexing Signals" />
            <DataTable
              rows={summary.overIndexing}
              rowKey={(row, index) => `${row.columnName}-${row.value}-${index}`}
              columns={[
                { id: "column", header: "Column", cell: (row) => row.columnName },
                { id: "value", header: "Value", cell: (row) => row.value },
                {
                  id: "ratio",
                  header: "Lift",
                  align: "right",
                  cell: (row) => `${row.ratio.toFixed(2)}x`,
                },
                {
                  id: "cohort",
                  header: "Cohort % (N)",
                  align: "right",
                  cell: (row) => {
                    if (shouldSuppressCell(row.cohortCount)) {
                      return "[suppressed]";
                    }
                    return `${formatPercent(row.cohortPct, 2)} (N=${formatNumber(row.cohortCount)})`;
                  },
                },
                {
                  id: "global",
                  header: "Global % (N)",
                  align: "right",
                  cell: (row) =>
                    `${formatPercent(row.globalPct, 2)} (N=${formatNumber(row.globalCount)})`,
                },
              ]}
              emptyMessage="No over-indexing values met the N >= 30 thresholds"
            />
          </div>
        </section>
      ) : null}

      {/* --- Comparison results --- */}
      {comparison ? (
        <section className="space-y-4">
          <div className="flex items-center justify-between">
            <SectionHeader number="02" title="Cohort Comparison" />
            <button type="button" className="editorial-button" onClick={saveToNotebook}>
              {notebookSaved ? "Saved!" : "Add to Notebook"}
            </button>
          </div>

          {/* Side-by-side cohort Ns */}
          <div className="grid gap-4 md:grid-cols-2">
            <div className="space-y-2">
              <p className="mono-label" style={{ fontSize: "0.75rem", letterSpacing: "0.08em", textTransform: "uppercase" }}>
                Cohort A
              </p>
              <div className="stat-grid grid-cols-1 md:grid-cols-3">
                <StatCard label="Dataset Size" value={formatNumber(comparison.a.totalSize)} />
                <StatCard label="Cohort Size" value={formatNumber(comparison.a.cohortSize)} />
                <StatCard
                  label="Cohort Share"
                  value={formatPercent(comparison.a.cohortSharePercent, 2)}
                  note={`N = ${formatNumber(comparison.a.cohortSize)}`}
                />
              </div>
              {renderWarningBanner(comparison.a.cohortSize)}
            </div>
            <div className="space-y-2">
              <p className="mono-label" style={{ fontSize: "0.75rem", letterSpacing: "0.08em", textTransform: "uppercase" }}>
                Cohort B
              </p>
              <div className="stat-grid grid-cols-1 md:grid-cols-3">
                <StatCard label="Dataset Size" value={formatNumber(comparison.b.totalSize)} />
                <StatCard label="Cohort Size" value={formatNumber(comparison.b.cohortSize)} />
                <StatCard
                  label="Cohort Share"
                  value={formatPercent(comparison.b.cohortSharePercent, 2)}
                  note={`N = ${formatNumber(comparison.b.cohortSize)}`}
                />
              </div>
              {renderWarningBanner(comparison.b.cohortSize)}
            </div>
          </div>

          {/* Percentile comparison with deltas */}
          <div className="raised-panel space-y-3">
            <SectionHeader number="03" title="Median Comparison" />
            {comparison.a.cohortSize < 30 || comparison.b.cohortSize < 30 ? (
              <p className="alert alert--critical">
                One or both cohorts have N &lt; 30. Delta values are suppressed.
              </p>
            ) : null}
            <DataTable
              rows={comparisonPercentileRows}
              rowKey={(row) => row.metric}
              columns={[
                { id: "metric", header: "Metric", cell: (row) => row.metric },
                {
                  id: "medianA",
                  header: "Cohort A Median",
                  align: "right",
                  cell: (row) => {
                    if (comparison.a.cohortSize < MIN_CELL_COUNT) return "[suppressed]";
                    return row.medianA == null ? "n/a" : row.medianA.toFixed(3);
                  },
                },
                {
                  id: "medianB",
                  header: "Cohort B Median",
                  align: "right",
                  cell: (row) => {
                    if (comparison.b.cohortSize < MIN_CELL_COUNT) return "[suppressed]";
                    return row.medianB == null ? "n/a" : row.medianB.toFixed(3);
                  },
                },
                {
                  id: "delta",
                  header: "Delta (B - A)",
                  align: "right",
                  cell: (row) => {
                    if (comparison.a.cohortSize < 30 || comparison.b.cohortSize < 30) {
                      return "[suppressed]";
                    }
                    if (row.delta == null) return "n/a";
                    const sign = row.delta > 0 ? "+" : "";
                    return `${sign}${row.delta.toFixed(3)} (${deltaDirection(row.delta)})`;
                  },
                },
                {
                  id: "nA",
                  header: "N (A)",
                  align: "right",
                  cell: () => formatNumber(comparison.a.cohortSize),
                },
                {
                  id: "nB",
                  header: "N (B)",
                  align: "right",
                  cell: () => formatNumber(comparison.b.cohortSize),
                },
              ]}
            />
          </div>

          {/* Over-indexing side by side */}
          <div className="grid gap-4 md:grid-cols-2">
            <div className="raised-panel space-y-3">
              <SectionHeader number="04a" title="Cohort A Over-Indexing" />
              <DataTable
                rows={comparison.a.overIndexing}
                rowKey={(row, index) => `a-${row.columnName}-${row.value}-${index}`}
                columns={[
                  { id: "column", header: "Column", cell: (row) => row.columnName },
                  { id: "value", header: "Value", cell: (row) => row.value },
                  {
                    id: "ratio",
                    header: "Lift",
                    align: "right",
                    cell: (row) => `${row.ratio.toFixed(2)}x`,
                  },
                  {
                    id: "cohort",
                    header: "Cohort % (N)",
                    align: "right",
                    cell: (row) => {
                      if (shouldSuppressCell(row.cohortCount)) {
                        return "[suppressed]";
                      }
                      return `${formatPercent(row.cohortPct, 2)} (N=${formatNumber(row.cohortCount)})`;
                    },
                  },
                ]}
                emptyMessage="No over-indexing values met the N >= 30 thresholds"
              />
            </div>
            <div className="raised-panel space-y-3">
              <SectionHeader number="04b" title="Cohort B Over-Indexing" />
              <DataTable
                rows={comparison.b.overIndexing}
                rowKey={(row, index) => `b-${row.columnName}-${row.value}-${index}`}
                columns={[
                  { id: "column", header: "Column", cell: (row) => row.columnName },
                  { id: "value", header: "Value", cell: (row) => row.value },
                  {
                    id: "ratio",
                    header: "Lift",
                    align: "right",
                    cell: (row) => `${row.ratio.toFixed(2)}x`,
                  },
                  {
                    id: "cohort",
                    header: "Cohort % (N)",
                    align: "right",
                    cell: (row) => {
                      if (shouldSuppressCell(row.cohortCount)) {
                        return "[suppressed]";
                      }
                      return `${formatPercent(row.cohortPct, 2)} (N=${formatNumber(row.cohortCount)})`;
                    },
                  },
                ]}
                emptyMessage="No over-indexing values met the N >= 30 thresholds"
              />
            </div>
          </div>
        </section>
      ) : null}
    </div>
  );
}
</file>

<file path="src/routes/sql.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";

import { DataTable } from "@/components/data-table";
import { SectionHeader } from "@/components/section-header";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Textarea } from "@/components/ui/textarea";
import type { SchemaData } from "@/lib/api/contracts";
import { getSchema } from "@/lib/client/api";
import { useDuckDB } from "@/lib/duckdb/provider";
import { addNotebookEntry } from "@/lib/notebook-store";
import { quoteIdentifier } from "@/lib/duckdb/sql-helpers";
import { formatNumber } from "@/lib/format";

export const Route = createFileRoute("/sql")({
  validateSearch: (search) => ({
    sql: typeof search.sql === "string" ? search.sql : undefined,
  }),
  component: SqlConsolePage,
});

interface QueryResult {
  columns: string[];
  rows: unknown[][];
}

const TEMPLATE_SQL: Array<{ name: string; sql: string }> = [
  {
    name: "Distribution (categorical)",
    sql: `SELECT
  {{column}},
  COUNT(*)::BIGINT AS respondents
FROM data
WHERE {{column}} IS NOT NULL
GROUP BY 1
ORDER BY respondents DESC
LIMIT 50`,
  },
  {
    name: "Distribution (numeric)",
    sql: `SELECT
  MIN({{column}})::DOUBLE AS min_value,
  QUANTILE_CONT({{column}}, 0.25)::DOUBLE AS p25,
  MEDIAN({{column}})::DOUBLE AS median_value,
  QUANTILE_CONT({{column}}, 0.75)::DOUBLE AS p75,
  MAX({{column}})::DOUBLE AS max_value,
  AVG({{column}})::DOUBLE AS avg_value
FROM data
WHERE {{column}} IS NOT NULL`,
  },
  {
    name: "Cross-tab",
    sql: `SELECT
  {{x_column}} AS x,
  {{y_column}} AS y,
  COUNT(*)::BIGINT AS respondents
FROM data
WHERE {{x_column}} IS NOT NULL
  AND {{y_column}} IS NOT NULL
GROUP BY 1, 2
ORDER BY respondents DESC
LIMIT 250`,
  },
  {
    name: "Cohort filter",
    sql: `SELECT *
FROM data
WHERE {{column}} = '{{value}}'
LIMIT 250`,
  },
  {
    name: "Correlation",
    sql: `SELECT
  CORR({{x_column}}, {{y_column}}) AS correlation,
  COUNT(*)::BIGINT AS n_used
FROM data
WHERE {{x_column}} IS NOT NULL
  AND {{y_column}} IS NOT NULL`,
  },
];

const starterSql = `SELECT
  straightness,
  politics,
  COUNT(*)::BIGINT AS respondents
FROM data
GROUP BY 1, 2
ORDER BY respondents DESC`;

function SqlConsolePage() {
  const search = Route.useSearch();
  const { db } = useDuckDB();
  const [schema, setSchema] = useState<SchemaData | null>(null);
  const [searchTerm, setSearchTerm] = useState("");

  const [sql, setSql] = useState(search.sql ?? starterSql);
  const [limit, setLimit] = useState(1000);
  const [running, setRunning] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [result, setResult] = useState<QueryResult | null>(null);
  const [rowCount, setRowCount] = useState<number | undefined>();

  const textareaRef = useRef<HTMLTextAreaElement | null>(null);

  useEffect(() => {
    if (search.sql) {
      setSql(search.sql);
    }
  }, [search.sql]);

  useEffect(() => {
    let cancelled = false;

    void getSchema()
      .then((response) => {
        if (!cancelled) setSchema(response.data);
      })
      .catch(() => {
        if (!cancelled) setSchema(null);
      });

    return () => {
      cancelled = true;
    };
  }, []);

  const filteredColumns = useMemo(() => {
    if (!schema) return [];
    if (!searchTerm.trim()) return schema.columns.slice(0, 240);

    const term = searchTerm.toLowerCase();
    return schema.columns.filter((column) => column.name.toLowerCase().includes(term)).slice(0, 240);
  }, [schema, searchTerm]);

  const execute = useCallback(async () => {
    if (!db) return;

    setRunning(true);
    setError(null);

    const conn = await db.connect();

    try {
      const limitedSql = `SELECT * FROM (${sql.trim().replace(/;+$/g, "")}) AS bounded_query LIMIT ${limit}`;
      const arrowResult = await conn.query(limitedSql);

      const columns = arrowResult.schema.fields.map((f) => f.name);
      const rows: unknown[][] = [];

      for (let i = 0; i < arrowResult.numRows; i++) {
        const row: unknown[] = [];
        for (let c = 0; c < columns.length; c++) {
          let val = arrowResult.getChildAt(c)?.get(i);
          if (typeof val === "bigint") val = Number(val);
          row.push(val ?? null);
        }
        rows.push(row);
      }

      setResult({ columns, rows });
      setRowCount(rows.length);
    } catch (executionError) {
      setError(executionError instanceof Error ? executionError.message : "Query failed");
      setResult(null);
      setRowCount(undefined);
    } finally {
      await conn.close();
      setRunning(false);
    }
  }, [db, sql, limit]);

  const insertQuotedIdentifier = useCallback((identifier: string) => {
    const quoted = quoteIdentifier(identifier);
    const textarea = textareaRef.current;

    if (!textarea) {
      setSql((current) => `${current}${current.endsWith("\n") ? "" : "\n"}${quoted}`);
      return;
    }

    const start = textarea.selectionStart ?? sql.length;
    const end = textarea.selectionEnd ?? start;

    setSql((current) => `${current.slice(0, start)}${quoted}${current.slice(end)}`);

    requestAnimationFrame(() => {
      const caret = start + quoted.length;
      textarea.focus();
      textarea.setSelectionRange(caret, caret);
    });
  }, [sql.length]);

  const [notebookSaved, setNotebookSaved] = useState(false);

  function saveToNotebook() {
    if (!result) return;

    addNotebookEntry({
      title: `SQL: ${sql.trim().slice(0, 60)}${sql.trim().length > 60 ? "..." : ""}`,
      queryDefinition: {
        type: "sql",
        params: { sql },
      },
      resultsSnapshot: {
        columns: result.columns,
        rows: result.rows.slice(0, 50),
      },
      notes: "",
    });

    setNotebookSaved(true);
    setTimeout(() => setNotebookSaved(false), 2000);
  }

  function exportCsv() {
    if (!result) return;

    const escaped = (value: unknown) => {
      const text = String(value ?? "");
      return `"${text.replaceAll('"', '""')}"`;
    };

    const header = result.columns.map(escaped).join(",");
    const lines = result.rows.map((row) => row.map(escaped).join(","));
    const csv = [header, ...lines].join("\n");

    const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
    const href = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = href;
    link.download = `bks-query-${Date.now()}.csv`;
    link.click();
    URL.revokeObjectURL(href);
  }

  return (
    <div className="page">
      <header className="page-header">
        <h1 className="page-title">SQL Console</h1>
        <p className="page-subtitle">Write DuckDB SQL against the dataset. Templates, click-to-insert column names, CSV export.</p>
      </header>

      <div className="grid gap-4 xl:grid-cols-[340px,1fr]">
        <aside className="raised-panel space-y-4">
          <SectionHeader number="01" title="Schema & Templates" />

          <div>
            <p className="mono-label">Templates</p>
            <div className="mt-2 space-y-2">
              {TEMPLATE_SQL.map((template) => (
                <Button
                  key={template.name}
                  type="button"
                  variant="ghost"
                  className="w-full justify-start"
                  onClick={() => setSql(template.sql)}
                >
                  {template.name}
                </Button>
              ))}
            </div>
          </div>

          <label className="editorial-label">
            Search Columns
            <Input
              name="schema_search"
              value={searchTerm}
              onChange={(event) => setSearchTerm(event.target.value)}
              placeholder="Filter by name"
            />
          </label>

          <ScrollArea className="max-h-[calc(100vh-520px)] min-h-[200px] border border-[var(--rule)] bg-[var(--paper)] p-1">
            {filteredColumns.map((column) => (
              <Button
                key={column.name}
                type="button"
                variant="ghost"
                className="w-full justify-start truncate px-2 py-1 text-[0.72rem] normal-case tracking-normal"
                onClick={() => insertQuotedIdentifier(column.name)}
                title={column.name}
              >
                {column.name}
              </Button>
            ))}
          </ScrollArea>
        </aside>

        <section className="editorial-panel space-y-4">
          <SectionHeader number="02" title="Editor" />

          <Textarea
            ref={textareaRef}
            className="h-64"
            value={sql}
            onChange={(event) => setSql(event.target.value)}
          />

          <div className="flex flex-wrap items-center gap-3">
            <label className="editorial-label w-[150px]">
              Limit
              <Input
                type="number"
                name="query_limit"
                min={1}
                max={10000}
                value={limit}
                onChange={(event) =>
                  setLimit(Math.max(1, Math.min(10000, Number(event.target.value) || 1)))
                }
              />
            </label>

            <Button
              type="button"
              onClick={() => {
                void execute();
              }}
              disabled={running || !db}
              variant="filled"
            >
              {running ? "Running..." : "Run Query"}
            </Button>

            <Button type="button" onClick={exportCsv} disabled={!result} variant="accent">
              Export CSV
            </Button>

            <Button type="button" onClick={saveToNotebook} disabled={!result} variant="ghost">
              {notebookSaved ? "Saved!" : "Add to Notebook"}
            </Button>
          </div>

          {error ? <p className="alert alert--error">{error}</p> : null}
        </section>
      </div>

      {result ? (
        <section className="editorial-panel space-y-3">
          <SectionHeader number="03" title="Results" />

          <div className="sample-size">
            <span className="sample-size-item">Rows returned: {formatNumber(rowCount ?? 0)}</span>
            <span className="sample-size-item">Limit applied: {formatNumber(limit)}</span>
            {rowCount === limit ? (
              <span className="sample-size-item text-[var(--accent)]">Results may be truncated</span>
            ) : null}
          </div>

          <DataTable
            rows={result.rows}
            rowKey={(_, index) => `row-${index}`}
            columns={result.columns.map((column, columnIndex) => ({
              id: column,
              header: column,
              cell: (row: unknown[]) => String(row[columnIndex] ?? "NULL"),
            }))}
          />
        </section>
      ) : null}
    </div>
  );
}
</file>

<file path="package.json">
{
  "name": "kink-survey-explorer",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite dev --port 3000",
    "build": "vite build",
    "preview": "vite preview",
    "start": "node .output/server/index.mjs",
    "sync-public-data": "node scripts/sync-public-data.mjs",
    "profile-schema": "node scripts/profile-schema.mjs",
    "check-types": "tsc --noEmit",
    "test": "vitest",
    "lint": "oxlint",
    "prepare": "husky"
  },
  "dependencies": {
    "@duckdb/duckdb-wasm": "1.33.1-dev18.0",
    "@duckdb/node-api": "1.4.4-r.1",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-slot": "^1.2.4",
    "@tailwindcss/vite": "^4.1.18",
    "@tanstack/react-devtools": "^0.7.0",
    "@tanstack/react-router": "^1.132.0",
    "@tanstack/react-router-devtools": "^1.132.0",
    "@tanstack/react-router-ssr-query": "^1.131.7",
    "@tanstack/react-start": "^1.132.0",
    "@tanstack/router-plugin": "^1.132.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.545.0",
    "nitro": "npm:nitro-nightly@3.0.1-20260212-205859-0f4c665f",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "tailwind-merge": "^3.4.0",
    "tailwindcss": "^4.1.18",
    "vite-tsconfig-paths": "^6.0.2",
    "zod": "^4.3.6"
  },
  "devDependencies": {
    "@tanstack/devtools-vite": "^0.3.11",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/react": "^16.2.0",
    "@types/node": "^22.10.2",
    "@types/react": "^19.2.0",
    "@types/react-dom": "^19.2.0",
    "@vitejs/plugin-react": "^5.0.4",
    "husky": "^9.1.7",
    "jsdom": "^27.0.0",
    "lint-staged": "^16.2.7",
    "oxlint": "^1.47.0",
    "typescript": "^5.7.2",
    "vite": "^7.1.7",
    "vitest": "^3.0.5"
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "oxlint"
    ]
  },
  "packageManager": "pnpm@10.6.3",
  "pnpm": {
    "onlyBuiltDependencies": [
      "esbuild"
    ]
  }
}
</file>

<file path="CLAUDE.md">
# Big Kink Survey Explorer

Interactive research explorer for the Big Kink Survey (~15.5k rows, 365 columns). Based on Aella's publicly released anonymized dataset. Serves both human users (browser UI with DuckDB-WASM) and AI agents (REST API + MCP server).

## Stack
- TanStack Start + React, Tailwind v4, Vite 7 + Nitro
- DuckDB-WASM (browser), DuckDB CLI + Node API (server), DuckDB Python (MCP)
- "Ink & Paper" editorial design system (Fraunces, Source Serif 4, JetBrains Mono)
- `pnpm` for JS, `uv` for Python (never pip directly)

## Commands
- `pnpm dev` — start dev server (port 3000)
- `pnpm build` — production build (outputs to `.output/`)
- `pnpm start` — run production server (`node .output/server/index.mjs`)
- `pnpm sync-public-data` — copy parquet from `data/` to `public/`
- `pnpm profile-schema` — regenerate `src/lib/schema/columns.generated.json`
- `pnpm check-types` — TypeScript validation
- `pnpm test --run` — unit tests
- `pnpm lint` — oxlint + eslint
- `duckdb -c "SQL"` — ad-hoc queries against `data/BKSPublic.parquet` (see `docs/design/architecture.md`)

## Pre-commit Contract
Every commit must pass: lint-staged → type-check → tests

## Key Files
- `PLAN.md` — v1 implementation plan with milestones M0-M6 (complete)
- `META-PLAN.md` — agent-first development philosophy
- `docs/plans/active/v2-next-steps.md` — v2 execution plan (phases 1-3 complete, phase 4 partial)
- `data/` — source parquet + column notes + survey documentation
- `src/router.tsx` — TanStack Start entry (required, exports `getRouter`)
- `src/routes/` — 9 UI pages: about, index, explore, columns, profile, relationships, sql, notebook
- `src/routes/api/` — server route API endpoints
- `src/lib/notebook-store.ts` — localStorage CRUD for notebook entries
- `src/lib/schema/relationships.generated.json` — precomputed pairwise associations
- `scripts/precompute-relationships.mjs` — generates relationships JSON
- `mcp-server/` — Python MCP server for AI agent access

## Docs (progressive disclosure — start here, dig in as needed)
- `docs/design/frontend.md` — **design system**: "Ink & Paper" editorial aesthetic, color tokens, typography, component patterns
- `docs/design/architecture.md` — stack decisions, technical rationale
- `docs/design/deployment.md` — Railway config, URLs, how to deploy
- `docs/design/mcps.md` — available MCP servers and how to use them
- `docs/schema/README.md` — schema metadata and caveat generation model
- `docs/plans/active/` — in-progress execution plans
- `docs/plans/completed/` — finished plans for context

## Deployment
- **Live**: https://bks-explorer-production.up.railway.app
- Railway project: `bks-explorer`, environment: `production`
- Deploy: `railway up` or use Railway MCP `deploy` tool

## Architectural Invariants
1. Data flows one direction: Parquet → DuckDB → Query → Component
2. API routes are thin wrappers around DuckDB SQL
3. Schema metadata is the single source of truth for columns
4. UI and agents both consume typed API contracts
5. Validate at boundaries (Zod for API inputs)
6. UI follows "Ink & Paper" design system — see `docs/design/frontend.md` for tokens/patterns

## Session Hygiene
At the end of each session or before compaction, update `docs/` with what was built, changed, or decided. Future agents should be able to read CLAUDE.md → docs/ and understand the current state without needing conversation history.
</file>

</files>
